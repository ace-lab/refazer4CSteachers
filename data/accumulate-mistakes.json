[
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(a, term(i))\n    \ti += 1\n    return a \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        a = combiner(a, term(i))    =>           \r\n        a = combiner(base, term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 1, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(base, term(i))\n    \ti += 1\n    return a \n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(j,k):\n        if j==0:\n            return base\n        elif k==j:\n            return combiner(base,term(k))\n        else:\n            return combiner(term(k),helper(j,k+1))\n    return helper(n,2)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 1)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(j,k):\n        if j==0:\n            return base\n        elif k==j:\n            return combiner(base,term(k))\n        else:\n            return combiner(term(k),helper(j,k+1))\n    return helper(n,1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    return helper(n, 1) =>           \r\n    return helper(n, 2) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        3
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        3, 
                        2
                    ]
                ]
            }
        }, 
        "Id": 2, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 2)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n<1:    =>           \r\n    if base<1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 3, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    total, k ==base, 1", 
            "UnboundLocalError: local variable 'total' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k =base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k =base, 1  =>           \r\n    total, k ==base, 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 4, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k ==base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    \n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "288", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     288", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term) =>           \r\n    return accumulate(add, 0, n, term)                                                      =>           \r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term) <=           \r\n    return _______                                                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 5, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), n)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 6, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), n)\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return term(1)\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 0:         =>           \r\n        return base    =>           \r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 7, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(m),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(m), accumulate(combiner, base, n-1, term))", 
            "NameError: name 'm' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(m), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 8, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(m), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    if combiner == add:\n        k = 0\n    else:\n        k = 1\n    \n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n        k = 0           =>           \r\n        k = 1           =>           \r\n                        =>           \r\n    else:               =>           \r\n    k = base            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 9, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    k = base\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ]
            }
        }, 
        "Id": 10, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 11, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return helper(0,base)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return helper(0,base)              =>           \r\n    return combiner(helper(0,0), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 12, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return combiner(helper(0,0), base)\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner (term(n), accumulate(combiner, base, n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 13, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return accumulate(combiner,base,n-1,term)                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 14, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n >= 1: =>           \r\n    while n > 1:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        24
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 15, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n                                                                        =>           \r\n        base += term(n)                                                 <=           \r\n        n -= 1                                                          <=           \r\n        return accumulate(combiner, base, n, term)                      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 16, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base += term(n)\n        n -= 1\n        return accumulate(combiner, base, n, term)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    combiner=lambda f:f(x,y)\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "TypeError: <lambda>() takes 1 positional argument but 2 were given", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=lambda f:f(x,y)\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    combiner = lambda f: f(x, y) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 17, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    combiner = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    b = 1\n    while b <= n:\n        total = combiner(term(b), total)\n        b += 1\n    return total \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    total = base                           =>           \r\n    b = 1                                  =>           \r\n    while b <= n:                          =>           \r\n        total = combiner(term(b), total)   =>           \r\n        b += 1                             =>           \r\n    return total                           =>           \r\n                                           =>           \r\n    result = base                          <=           \r\n    for i in range(base, n + 1):           <=           \r\n        result = combiner(result, term(i)) <=           \r\n    return result                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 18, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    for i in range(base, n + 1):\n        result = combiner(result, term(i))\n    return result \n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total * base\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n            return total * base =>           \r\n            return total + base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 19, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total + base\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        accumulation = combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n        accumulation = combiner(accumulation, term(k)) =>           \r\n        combiner(accumulation, term(k))                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 20, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return combiner(accumulate(combiner, new_base, i + 1, term), base)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate", 
            "    if i == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    if n == 0:\n        return base\n    else:\n        new_base = term(n)\n    return combiner(accumulate(combiner, new_base, n-1, term), base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                                   SideIndicator\r\n-----------                                                                                                   -------------\r\n    if n == 0:                                                                                                =>           \r\n        new_base = term(n)                                                                                    =>           \r\n    return combiner(accumulate(combiner, new_base, n-1, term), base)                                          =>           \r\n    return accumulate(combiner, base, n, term) if pred(n) else filtered_accumulate(combiner, base, n-1, term) =>           \r\n        new_base = term(n)                                                                                    =>           \r\n        return combiner(accumulate(combiner, new_base, n-1, term), base)                                      =>           \r\n'''                                                                                                           =>           \r\n    def next_pong(i, j, next):                                                                                =>           \r\n        if i == n:                                                                                            =>           \r\n            return 0                                                                                          =>           \r\n    def switch_ping():                                                                                        =>           \r\n        return 0                                                                                              =>           \r\n        return 0                                                                                              =>           \r\n    if n == 1:                                                                                                =>           \r\n        print(start, end)                                                                                     =>           \r\n    else:                                                                                                     =>           \r\n        return 0                                                                                              =>           \r\n    i = 1                                                                                                     <=           \r\n    if i == n:                                                                                                <=           \r\n        new_base = term(i)                                                                                    <=           \r\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)                                        <=           \r\n    return accumulate(combiner, base, n if pred(n) else 0, term)                                              <=           \r\n        x = term(n)                                                                                           <=           \r\n    return combiner(base, accumulate(combiner, x, n-1, term))'''                                              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 21, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    i = 1\n    if i == n:\n        return base\n    else:\n        new_base = term(i)\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    total = combiner(term(i)) + base", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, base\n    while i <= n:\n        total = combiner(term(i), total)\n        i += 1\n    return total \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    i, total = 1, base                   =>           \r\n        total = combiner(term(i), total) =>           \r\n    i, total = 1, 1                      <=           \r\n        total = combiner(term(i)) + base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 22, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        total = combiner(term(i)) + base\n        i += 1\n    return total \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 23, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        total=combiner(base,term(n))\n        return accumulate(combiner,total,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate", 
            "    return accumulate(combiner, total, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        total=combiner(base,term(n))\n        return accumulate(combiner,total,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    if n == 0:      =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69
                    ]
                ]
            }, 
            "total": {}, 
            "base": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        10, 
                        8, 
                        5, 
                        1, 
                        -4, 
                        -10, 
                        -17, 
                        -25, 
                        -34, 
                        -44, 
                        -55, 
                        -67, 
                        -80, 
                        -94, 
                        -109, 
                        -125, 
                        -142, 
                        -160, 
                        -179, 
                        -199, 
                        -220, 
                        -242, 
                        -265, 
                        -289, 
                        -314, 
                        -340, 
                        -367, 
                        -395, 
                        -424, 
                        -454, 
                        -485, 
                        -517, 
                        -550, 
                        -584, 
                        -619, 
                        -655, 
                        -692, 
                        -730, 
                        -769, 
                        -809, 
                        -850, 
                        -892, 
                        -935, 
                        -979, 
                        -1024, 
                        -1070, 
                        -1117, 
                        -1165, 
                        -1214, 
                        -1264, 
                        -1315, 
                        -1367, 
                        -1420, 
                        -1474, 
                        -1529, 
                        -1585, 
                        -1642, 
                        -1700, 
                        -1759, 
                        -1819, 
                        -1880, 
                        -1942, 
                        -2005, 
                        -2069, 
                        -2134, 
                        -2200, 
                        -2267, 
                        -2335
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69
                    ]
                ]
            }
        }, 
        "Id": 24, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def help(base,i):\n        if i==n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i+1)\n    return help(base,1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i > n:\n            return base\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help", 
            "    return help(combiner(base,term(i)),i + 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in help", 
            "    if i == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def help(base,i):\n        if i==n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i+1)\n    if n==0:\n        return base\n    return help(base,1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if i > n:                         =>           \r\n            return base                   =>           \r\n        if i == n:                        <=           \r\n            return combiner(base,term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    if n==0:\r\n        return base\r\n    return help(base, 1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}, 
            "base": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        32, 
                        39, 
                        47, 
                        56, 
                        66, 
                        77, 
                        89, 
                        102, 
                        116, 
                        131, 
                        147, 
                        164, 
                        182, 
                        201, 
                        221, 
                        242, 
                        264, 
                        287, 
                        311, 
                        336, 
                        362, 
                        389, 
                        417, 
                        446, 
                        476, 
                        507, 
                        539, 
                        572, 
                        606, 
                        641, 
                        677, 
                        714, 
                        752, 
                        791, 
                        831, 
                        872, 
                        914, 
                        957, 
                        1001, 
                        1046, 
                        1092, 
                        1139, 
                        1187, 
                        1236, 
                        1286, 
                        1337, 
                        1389, 
                        1442, 
                        1496, 
                        1551, 
                        1607, 
                        1664, 
                        1722, 
                        1781, 
                        1841, 
                        1902, 
                        1964, 
                        2027, 
                        2091, 
                        2156, 
                        2222, 
                        2289, 
                        2357, 
                        2426, 
                        2496, 
                        2567, 
                        2639, 
                        2712, 
                        2786, 
                        2861, 
                        2937, 
                        3014, 
                        3092, 
                        3171, 
                        3251
                    ]
                ]
            }
        }, 
        "Id": 25, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    return help(base, 1)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    total, i = base, 1           =>           \r\n    return total                 =>           \r\n                                 =>           \r\n    total, i = 0, 1              <=           \r\n    return combiner(base, total) <=           \r\n                                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 26, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = 0, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(base, total)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    total = base \n    while x <= n:\n        total, x = combiner(total, term(x)), x + 1\n    return total\n    # def count_up(x):\n    #     x = 1\n    #     if n == 0:\n    #         return n \n    #     while x <= n:\n    #         print (term(x))\n    #         x += 1\n    #     return\n\n    # # x, a = base, lambda x: lambda y: combiner(x, y) \n\n    # if n == 0:\n    #     return base\n\n    # return base + count_up(n)\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n        total, x = combiner(total, term(x)), x + 1               =>           \r\n        total, x = total + combiner(term(x - 1), term(x)), x + 2 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 27, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    total = base \n    while x <= n:\n        total, x = total + combiner(term(x - 1), term(x)), x + 2\n    return total\n    # def count_up(x):\n    #     x = 1\n    #     if n == 0:\n    #         return n \n    #     while x <= n:\n    #         print (term(x))\n    #         x += 1\n    #     return\n\n    # # x, a = base, lambda x: lambda y: combiner(x, y) \n\n    # if n == 0:\n    #     return base\n\n    # return base + count_up(n)\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.  The\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.  Treating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\t\"*** YOUR CODE HERE ***\"\n\tif n == 1:\n\t\treturn combiner(base,term(1)) \n\telif n == 0:\n\t\treturn combiner(base,0)\n\treturn combiner(base, accumulate(combiner, term(n), n-1, term))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    elif n == 0:                =>           \r\n        return combiner(base,0) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "base": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 28, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    if combiner == add:\n        return base + combined_terms\n    else:\n        return base * combined_terms\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    if combiner == add:              =>           \r\n        return base + combined_terms =>           \r\n        return base * combined_terms =>           \r\n    else:                            =>           \r\n    return base + combined_terms     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 29, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    return base + combined_terms\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, 0)\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return combiner(base, 0) =>           \r\n        return 0                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 30, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    count=1\n    total=term(base)\n    while count<=n:\n        total=combiner(total,term(count))\n        count=count+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combiner(total,term(count))\n        count=count+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = 1          =>           \r\n    total = base       =>           \r\n    total = term(1)    <=           \r\n    total = term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 31, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = term(base)\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(total, base)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    k = 1                        =>           \r\n    return combiner(total, base) =>           \r\n    k = base                     <=           \r\n    return total                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 32, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner,base,n,term):\n        if n==0:\n            return total\n        else:\n            total=combiner(base,term(n))\n            return partial_total(combiner,base,n-1,term)\n    return partial_total(combiner,base,n,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return base\n        else:\n            base = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate", 
            "    return partial_total(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total", 
            "    return partial_total(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total", 
            "    return partial_total(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total", 
            "    return partial_total(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total", 
            "    return partial_total(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total", 
            "    return partial_total(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in partial_total", 
            "    return total", 
            "UnboundLocalError: local variable 'total' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner,base,n,term):\n        if n==0:\n            return base\n        else:\n            base=combiner(base,term(n))\n            return partial_total(combiner,base,n-1,term)\n    return partial_total(combiner,base,n,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return base                     =>           \r\n            base = combiner(base, term(n))  =>           \r\n    if combiner==mul:                       <=           \r\n        total=1                             <=           \r\n        total=0                             <=           \r\n            return total                    <=           \r\n            total = combiner(base, term(n)) <=           \r\n    else:                                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            base = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1
                    ], 
                    [
                        1, 
                        18, 
                        8, 
                        2, 
                        8, 
                        18, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        16, 
                        15, 
                        14, 
                        13, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        20, 
                        15, 
                        12, 
                        15, 
                        20, 
                        0
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 33, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return total\r\n        else:\r\n            total = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return combiner(total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    return combiner(total)", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total, k = combiner(total, term(k)), k + 1  =>           \r\n    return total                                    =>           \r\n        total, k = combiner (total, term(k)), k + 1 <=           \r\n    return combiner(total)                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 34, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    elif n==0:\n        return base+term(0)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base,term(1))\n    elif n == 0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if base==1:\n        return base+term(1)\n    elif n==0:\n        return base+term(0)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return combiner(base,term(1)) =>           \r\n        return combiner(base,term(0)) =>           \r\n        return base + term(1)         <=           \r\n        return base + term(0)         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 35, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=1\n    if x==mul:\n        total=1\n    else:\n        total=0\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return combiner(base,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while counter <= n:\n        total, counter = combiner(total, term(counter)), counter + 1\n    return combiner(base, total)\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=1\n    if x==mul:\n        total=1\n    else:\n        total=base\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    counter = 1                                                      =>           \r\n    if combiner == mul:                                              =>           \r\n    while counter <= n:                                              =>           \r\n        total, counter = combiner(total, term(counter)), counter + 1 =>           \r\n    x = 1                                                            <=           \r\n    if x == mul:                                                     <=           \r\n    while x <= n:                                                    <=           \r\n        total, x = combiner(total, term(x)), x + 1                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = base\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 36, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return combiner(base, total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, n) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 37, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return combiner(base,term(n))\n    elif n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==0:                             =>           \r\n        return combiner(base,term(n))    =>           \r\n    elif n==1:                           =>           \r\n        return combiner(base,term(n))    =>           \r\n    if n==1:                             <=           \r\n        return term(n)                   <=           \r\n     # elif n==1:                        <=           \r\n     #     return combiner(base,term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 38, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(n)\n     # elif n==1:\n     #     return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return iter_accumulate(1,increment)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in iter_accumulate", 
            "    return combiner(term(x),iter_accumulate(increment(x)))", 
            "TypeError: iter_accumulate() missing 1 required positional argument: 'increment'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    def iter_accumulate(x):             =>           \r\n    return iter_accumulate(1)           =>           \r\n    def iter_accumulate(x,increment):   <=           \r\n    return iter_accumulate(1,increment) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 39, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x,increment):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1,increment)\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    result = base\n    while i < n:\n        result = combiner(result, term(n))\n        n -= 1\n    return result\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 0   =>           \r\n    i = -1  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 40, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = -1\n    result = base\n    while i < n:\n        result = combiner(result, term(n))\n        n -= 1\n    return result\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    from operator import add, mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                     SideIndicator\r\n-----------                                                     -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 41, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (index,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    while i <= n:", 
            "UnboundLocalError: local variable 'i' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    i, total = 1, base         =>           \r\n    index, total = 1, base     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 42, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return term(n)                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 43, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),k),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "10\n", 
            "print accumulate(mul, 2, 3, square)": "27\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n        total, k = combiner(term(k), k), k + 1     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        2, 
                        4, 
                        6, 
                        8, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        1, 
                        8, 
                        27
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        2, 
                        4, 
                        6, 
                        8, 
                        10
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        2, 
                        6, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 44, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), k), k+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "70", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     70", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    k = 1                                                                           =>           \r\n    total = base                                                                    =>           \r\n    while k <= n:                                                                   =>           \r\n        total = combiner(total, term(k))                                            =>           \r\n        k += 1                                                                      =>           \r\n    return total                                                                    =>           \r\n    if n == 0:                                                                      <=           \r\n        return base                                                                 <=           \r\n    if n == 1:                                                                      <=           \r\n        return combiner(base, term(n))                                              <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 45, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term)))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumalate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumalate(combiner, base, n-1, term))", 
            "NameError: name 'accumalate' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumalate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 46, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumalate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        if term==mul:\n            return combiner(base,term(n+1))\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if combiner == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        if term==mul:\n            return combiner(base,term(n+1))\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == mul: =>           \r\n        if term == mul:     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 47, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    base=combiner(base,term(1))\n    for i in range(2,n+1):\n        base=combiner(base,term(i))\n    return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range(1, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    base=combiner(base,term(1))\n    for i in range(2,n+1):\n        base=combiner(base,term(i))\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    for i in range(1, n+1):        =>           \r\n    base = combiner(base, term(1)) <=           \r\n    for i in range(2, n+1):        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "base": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 48, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 49, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 0\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    if n==0:\n        return base\n    return combiner(base,times(1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 0 =>           \r\n            return 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, times(1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 50, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    return combiner(base, times(1))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        \n        total = base\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return helper_product(base, n, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n                                                         =>           \r\n        total = base                                     =>           \r\n    return helper_product(base, n, term)                 =>           \r\n        total = 0                                        <=           \r\n    return combiner(helper_product(base, n, term), base) <=           \r\n                                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 51, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        total = 0\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return combiner(helper_product(base, n, term), base)\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "6", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     6", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i <= n:\n        result = combiner(result, term(i))\n        i += 1\n    return result\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    result, i = base, 1                                                             =>           \r\n    while i <= n:                                                                   =>           \r\n        result = combiner(result, term(i))                                          =>           \r\n        i += 1                                                                      =>           \r\n    return result                                                                   =>           \r\n    if n == 0:                                                                      <=           \r\n        return 1                                                                    <=           \r\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 52, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 1\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term)))\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    return\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    elif n == 0:\n        return combiner(0, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    return\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    elif n == 0:                 =>           \r\n        return combiner(0, base) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return ", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 53, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return "
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n+1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n+1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return base                      =>           \r\n        return combiner(base, term(n+1)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 54, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=2\n    total=combiner(base,term(1))\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(0))\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=2\n    if n==0:\n        return base\n    total=combiner(base,term(1))\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    if n==0:\r\n        return base\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "total": {}
        }, 
        "Id": 55, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    value=term(1)\n    if n==0:\n        return base\n    while n>0:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        5, 
                        4, 
                        3, 
                        2
                    ], 
                    [
                        1, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        3, 
                        2
                    ], 
                    [
                        1, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        5, 
                        4, 
                        3, 
                        2
                    ], 
                    [
                        1, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        3, 
                        2
                    ], 
                    [
                        1, 
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "value": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        6, 
                        10, 
                        13, 
                        15
                    ], 
                    [
                        1, 
                        6, 
                        10, 
                        13, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        6, 
                        10, 
                        13, 
                        15
                    ], 
                    [
                        1, 
                        6, 
                        10, 
                        13, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        10, 
                        14
                    ], 
                    [
                        1, 
                        10, 
                        14, 
                        15
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 56, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n+1 > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while n+1 > i: =>           \r\n    while n > i:   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 57, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 58, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k<=n:\n        k=k+1\n        total=combiner(total,term(k))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "21\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "32\n", 
            "print accumulate(mul, 2, 3, square)": "1152\n", 
            "print accumulate(add, 11, 3, square)": "41\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k < n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "21", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     21", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k+1<=n:\n        k=k+1\n        total=combiner(total,term(k))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k < n:  =>           \r\n    while k <= n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k+1<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        32
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        72, 
                        1152
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16, 
                        25, 
                        41
                    ]
                ]
            }
        }, 
        "Id": 59, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=n\n    if k>=1:\n        return combiner(term(k),accumulate(combiner,base,k-1,term))\n    else:\n        return combiner(base,term(k))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k > 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=n\n    if n==0:\n        return base\n    if k>=1:\n        return combiner(term(k),accumulate(combiner,base,k-1,term))\n    else:\n        return combiner(base,term(k))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if k > 1:  =>           \r\n    if k >= 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if n==0:\r\n        return base\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 60, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1 or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if base==1 or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n==0:         =>           \r\n    if n==1 or n==0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 61, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(add,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "63\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "63", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     63", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(add, base, n-1, term))      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 62, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(add, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1, term) + term(n)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 63, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1, term) + term(n)\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    counter=0\n    while counter<=n:\n        num=term(counter)\n        base=combiner(base,num)\n        counter=counter+1\n    return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    counter=1\n    while counter<=n:\n        num=term(counter)\n        base=combiner(base,num)\n        counter=counter+1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "num": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        4, 
                        9
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        9
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        4, 
                        9
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        9
                    ]
                ]
            }, 
            "base": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 64, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 0\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            result = combiner(result, term(n))\n            n -= 1\n        return result\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 65, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            n -= 1\n            result = combiner(result, term(n))\n        return result\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(accumulate(combiner,term(n),n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(accumulate(combiner,term(n),n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(accumulate(combiner,term(n),n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(accumulate(combiner,term(n),n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(accumulate(combiner,term(n),n-1,term))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term),base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(accumulate(combiner,term(n),n-1,term),base) =>           \r\n        return combiner(accumulate(combiner,term(n),n-1,term))      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 66, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,n)\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 67, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 68, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    while i<=n:\n        base=combiner(base,term(n))\n        i+=1\n    return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base \n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    while i<=n:\n        base=combiner(base,term(i))\n        i+=1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(i)) =>           \r\n        base = combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }
        }, 
        "Id": 69, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(n))\r\n        i += 1\r\n    return base"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(n,accumulate(combiner,base, term(n),term ))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n==0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term ))\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term )) =>           \r\n        return combiner(n,accumulate(combiner,base, term(n),term ))  <=           \r\n                                                                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 70, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base, term(n),term ))\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(base, term(n))\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if n==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n==0:                           =>           \r\n    elif n==1:                         =>           \r\n        return combiner(base, term(n)) =>           \r\n    if n==1:                           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 71, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 72, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==0:                  =>           \r\n        return base           =>           \r\n    if n==1:                  <=           \r\n        return base + term(1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 73, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n    return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 74, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n        return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    return combiner(base + term(n))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total = 0\n    else:\n        total = 1\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return combiner(base, total)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if combiner == add:                  =>           \r\n        total = 0                        =>           \r\n        total = 1                        =>           \r\n    for i in range(1, n+1):              =>           \r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(base, total)         =>           \r\n    else:                                =>           \r\n    return combiner(base + term(n))      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 75, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return combiner(base + term(n))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p=base\n    for _ in range(1,n+1):\n        p=combiner(term(_),p)\n    return p\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    p=base                    =>           \r\n    for _ in range(1,n+1):    =>           \r\n        p=combiner(term(_),p) =>           \r\n    return p                  =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 76, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    n_counter=1\n    accum_num=combiner(base,term(n_counter))\n    while n_counter<n:\n        n_counter+=1\n        accum_num=combiner(accum_num,term(n_counter))\n    return accum_num\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        n_counter = 0\n    else:\n        n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    n_counter=1\n    if n==0:\n        return base\n    accum_num=combiner(base,term(n_counter))\n    while n_counter<n:\n        n_counter+=1\n        accum_num=combiner(accum_num,term(n_counter))\n    return accum_num\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n == 0:        =>           \r\n        n_counter = 0 =>           \r\n        n_counter = 1 =>           \r\n    else:             =>           \r\n    n_counter = 1     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    if n==0:\r\n        return base\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "accum_num": {}
        }, 
        "Id": 77, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    z=n\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "20\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "20\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    z=base  =>           \r\n    z=n     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    z = base\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "z": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        5, 
                        6, 
                        8, 
                        11, 
                        15, 
                        20
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        5, 
                        6, 
                        8, 
                        11, 
                        15, 
                        20
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        3, 
                        12, 
                        108
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        3, 
                        4, 
                        8, 
                        17
                    ]
                ]
            }
        }, 
        "Id": 78, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    z = n\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(n,term):\n        if n==0:\n            return 0\n        elif n<=1:\n            return 1\n        else:\n            return term(n)+helper(n-1,term)\n    return combiner(base,helper(n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "28\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return combiner(term(n), helper(n-1, term))\n    return combiner(base, helper(n, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "28", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     28", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(n,term):\n        if n==0:\n            return 0\n        elif n<=1:\n            return 1\n        else:\n            return combiner(term(n),helper(n-1,term))\n    return combiner(base,helper(n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n            return combiner(term(n), helper(n-1, term)) =>           \r\n            return term(n)+helper(n-1, term)            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), helper(n-1, term))\r\n    return combiner(base, helper(n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 79, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return term(n)+helper(n-1, term)\r\n    return combiner(base, helper(n, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return term(n)+ accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if combiner==mul:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        base = combiner(base, term(n))\n    return accumulate(combiner, base, n-1, term)\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n    if n==0:                                                      =>           \r\n        return base                                               =>           \r\n        base = combiner(base, term(n))                            =>           \r\n    return accumulate(combiner, base, n-1, term)                  =>           \r\n    if combiner==mul:                                             <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)*accumulate(combiner, base, n-1, term)  <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)+ accumulate(combiner, base, n-1, term) <=           \r\n                                                                  <=           \r\n                                                                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 80, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==mul:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)*accumulate(combiner, base, n-1, term)\n    else:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n\n\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "21", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     21", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=1\n    if n==0:\n        return base\n    else:\n        while counter<=n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal\n        \n        \n        \n        \n        \n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    counter=1                    =>           \r\n        while counter<=n:        =>           \r\n        return accumulateTotal   =>           \r\n    counter=0                    <=           \r\n        while counter<n:         <=           \r\n        return accumulateTotal+5 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 81, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=0\n    if n==0:\n        return base\n    else:\n        while counter<n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal+5\n        \n        \n        \n        \n        \n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 82, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        combiner(term(n), accumulate(combiner, base, n-1, term))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 83, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    total, k = term(n, k), k + 1", 
            "TypeError: identity() takes 1 positional argument but 2 were given", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1 \n    while k <= n: \n        total, k = combiner(term(k), total), k + 1\n    return total \n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    while k <= n:                                  =>           \r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n    while k <= n:                                  <=           \r\n        total, k = term(n, k), k + 1               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 84, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1 \n    while k <= n:\n        total, k = term(n, k), k + 1 \n    return total \n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                    SideIndicator\r\n-----------                                                                                    -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))                        =>           \r\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term)))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 85, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term))))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "92", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     92", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    for i in range(1, n + 1):           =>           \r\n    for i in range(base, base + n + 1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 86, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(base, base + n + 1):\n        total = combiner(total, term(i))\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=0\n    for i in range(1,n+1):\n        x=combiner(x,term(i))\n    return x\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=base\n    for i in range(1,n+1):\n        x=combiner(x,term(i))\n    return x\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    x = base =>           \r\n    x = 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        16, 
                        3, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        5, 
                        3, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        14, 
                        3, 
                        17, 
                        4, 
                        21, 
                        5, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        6, 
                        4, 
                        10, 
                        5, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        1, 
                        2, 
                        8, 
                        3, 
                        72
                    ], 
                    [
                        0, 
                        1, 
                        0, 
                        2, 
                        0, 
                        3, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 87, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 0\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 1\n    while i < n+1:\n    \tproduct = combiner(product,term(i))\n    \ti +=1\n    return product\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    i = 1                                      =>           \r\n        product = combiner(product,term(i))    =>           \r\n    i = 0                                      <=           \r\n        product = combiner(product,term(base)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 88, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 0\n    while i < n+1:\n    \tproduct = combiner(product,term(base))\n    \ti +=1\n    return product\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 89, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(base, combiner(term(n), combiner(n-1, term)))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def a(combiner,n,term):\n        if n == 1:\n            return term(1)\n        else: \n            return combiner(term(n), a(combiner, n-1, term))\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, a(combiner,n,term))\n\n\n\n    \"*** YOUR CODE HERE ***\"\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    def a(combiner,n,term):                                           =>           \r\n        if n == 1:                                                    =>           \r\n            return term(1)                                            =>           \r\n        else:                                                         =>           \r\n            return combiner(term(n), a(combiner, n-1, term))          =>           \r\n        return combiner(base, a(combiner,n,term))                     =>           \r\n        return combiner(base, combiner(term(n), combiner(n-1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 90, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), combiner(n-1, term)))\n\n\n\n    \"*** YOUR CODE HERE ***\"\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=combiner(total,term(x))\n        x+=1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(x)) =>           \r\n        total=term(total)             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 91, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=term(total)\n        x+=1\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def helper(i):\n    #     if i == n:\n    #         return \n    #     else:\n    #         return \n    # return helper(1)\n    if n == 1 or n == 0:\n        return combiner(base, term(n))  \n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ]
            }
        }, 
        "Id": 92, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    while n>0:\n        total=base\n        total=combiner(total,term(n))\n        n=n-1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    total = base    \n    while n > 0:\n        \n        total = combiner(total ,term(n))\n        n =  n-1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    while n>0:\n        total=base\n        base=combiner(total,term(n))\n        n=n-1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total = base     =>           \r\n        total = base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        base = combiner(total, term(n))\r\n        n = n-1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14
                    ], 
                    [
                        0, 
                        5, 
                        0, 
                        4, 
                        0, 
                        3, 
                        0, 
                        2, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        2, 
                        8, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25
                    ], 
                    [
                        11, 
                        16, 
                        11, 
                        15, 
                        11, 
                        14, 
                        11, 
                        13, 
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24
                    ], 
                    [
                        11, 
                        20, 
                        11, 
                        15, 
                        11, 
                        12
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 93, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(n))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(i)) =>           \r\n        total=combiner(total,term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }
        }, 
        "Id": 94, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(n))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    for x in range(2,n+1):\n        base=combiner(base,term(x))\n    return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(1, n + 1):\n        base = combiner(base, term(x))\n    return base\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    for x in range(1,n+1):\n        base=combiner(base,term(x))\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for x in range(1, n + 1):          =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n    for x in range(2, n + 1):          <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(1, n+1):\r\n        base = combiner(base, term(x))\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        2, 
                        5, 
                        9, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        13, 
                        16, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        15, 
                        24
                    ]
                ]
            }
        }, 
        "Id": 95, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(2, n+1):\r\n        base = combiner(base, term(x))\r\n    return base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 96, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "9\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "9\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "13\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), term(n-1))                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 97, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return comb(term(1),base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    return comb(term(1),base)               =>           \r\n    return combiner(base , comb(term(1),1)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 98, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return combiner(base , comb(term(1),1))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    total, k = 1, k + 1", 
            "UnboundLocalError: local variable 'k' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if combiner == add:\n        total, k = 0, 1\n        while k <= n:\n            total, k = total + term(k), k + 1\n        return total + base\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * term(k), k + 1\n        return total * base\n\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        total, k = 1, 1     =>           \r\n        total, k = 1, k + 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 99, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if combiner == add:\n        total, k = 0, 1\n        while k <= n:\n            total, k = total + term(k), k + 1\n        return total + base\n    else:\n        total, k = 1, k + 1\n        while k <= n:\n            total, k = total * term(k), k + 1\n        return total * base\n\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner([term(n), accumulate(combiner, base, n-1, term)])", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner([term(n), accumulate(combiner, base, n-1, term)])", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner([term(n), accumulate(combiner, base, n-1, term)])", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner([term(n), accumulate(combiner, base, n-1, term)])", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner([term(n), accumulate(combiner, base, n-1, term)])", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner([term(n), accumulate(combiner, base, n-1, term)]) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 100, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner([term(n), accumulate(combiner, base, n-1, term)])\n    else:\n        return base\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return term(n) * combiner(n-1, term)", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a \n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    def helper(a,n):                         =>           \r\n        if n == 0:                           =>           \r\n            return a                         =>           \r\n        else:                                =>           \r\n            a = combiner(a, term(n))         =>           \r\n        return helper(a, n-1)                =>           \r\n    return helper(base, n)                   =>           \r\n    if n == 1:                               <=           \r\n        return term(1) + base                <=           \r\n    else:                                    <=           \r\n        return term(n) * combiner(n-1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 101, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(1) + base\n    else: \n        return term(n) * combiner(n-1, term)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(base, term(accumulate(combiner, base, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if base == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n    if n == 0:                                                             =>           \r\n        return base                                                        =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))    =>           \r\n    else:                                                                  =>           \r\n    if base == 0:                                                          <=           \r\n        return combiner(base, term(accumulate(combiner, base, n-1, term))) <=           \r\n                                                                           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 102, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if base == 0:\n        return combiner(base, term(accumulate(combiner, base, n-1, term)))\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base \n    for x in range (n):\n        total = combiner(total, term(x+1))\n    return total\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    total = 1                                                                       =>           \r\n    for x in range(n):                                                              =>           \r\n        total *= term(x+1)                                                          =>           \r\n    return total                                                                    =>           \r\n    return product(n, identity)                                                     =>           \r\n    total = base                                                                    =>           \r\n    for x in range (n):                                                             =>           \r\n        total = combiner(total, term(x+1))                                          =>           \r\n    return total                                                                    =>           \r\n    return accumulate(add, 0, n, term)                                              =>           \r\n    return accumulate(mul, 1, n, term)                                              =>           \r\n    #return accumulate(combiner if pred(for x in range(n): ) else ,base , n , term) =>           \r\n                                                                                    =>           \r\n                                                                                    =>           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                        <=           \r\n    \"*** YOUR CODE HERE ***\"                                                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 103, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def f(x):\n        if x==1:\n            return base+term(1)\n        else:\n            return combiner(f(x-1),term(x))\n    return f(n)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\"\"\"\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f", 
            "    return combiner(f(x-1),term(x))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in f", 
            "    if x==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def f(x):\n        if x==0:\n            return base\n        else:\n            return combiner(f(x-1),term(x))\n    return f(n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                SideIndicator\r\n-----------                                                                                -------------\r\n    \"\"\"def f(x):                                                                           =>           \r\n    return f(n)\"\"\"                                                                         =>           \r\n    s=base                                                                                 =>           \r\n    return s                                                                               =>           \r\n    return accumulate(lambda combiner:combiner if pred else lambda x,y,:x , base, n, term) =>           \r\n    def f(x):                                                                              <=           \r\n    return f(n)                                                                            <=           \r\n    \"\"\"\"s=base                                                                             <=           \r\n    return s\"\"\"                                                                            <=           \r\n    return _______                                                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==0:\r\n            return base\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 104, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==1:\r\n            return base+term(1)\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    else:\n        total=1\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "36", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     36", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    else:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        total = base =>           \r\n        total = 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        8, 
                        3, 
                        72
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        3, 
                        36
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ]
            }
        }, 
        "Id": 105, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = 1\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\"\"\"  \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    total, k = start, 1", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    if n == 0:                                                                    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))           =>           \r\n        \"\"\"                                                                       =>           \r\n    total, k = base, 1                                                            =>           \r\n    return total\"\"\"                                                               =>           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(a) else b, base, n, term) =>           \r\n    \"\"\"if n == 0:                                                                 <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"        <=           \r\n    total, k = start, 1                                                           <=           \r\n    return total                                                                  <=           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(b) else b, base, n, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 106, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner == add:\n        total = 0\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        total = 1\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        total = 0 =>           \r\n        total = 1 =>           \r\n    total = 1     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 107, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = 1\n    if combiner == add:\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "4", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     4", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    i = 1                                 =>           \r\n    total = base                          =>           \r\n    while i <= n:                         =>           \r\n        total = combiner(total, term(i))  =>           \r\n        i += 1                            =>           \r\n    return total                          =>           \r\n    return ________                       =>           \r\n        return compsel(f, f)              =>           \r\n        return repeated(f, n-1)           =>           \r\n        return term(n)                    <=           \r\n    if n == 0:                            <=           \r\n        return base                       <=           \r\n        return combiner(base, term(n-1))  <=           \r\n    #i = 1                                <=           \r\n    #total = base                         <=           \r\n    #while i <= n:                        <=           \r\n    #    total = combiner(total, term(i)) <=           \r\n    #    i += 1                           <=           \r\n    #return total                         <=           \r\n    return accumulate(combiner, base, )   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 108, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    if n == 0:\n        return base\n    else:\n        return combiner(base, term(n-1))\n    #i = 1\n    #total = base\n    #while i <= n:\n    #    total = combiner(total, term(i))\n    #    i += 1\n    #return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=k\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "7\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "18\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "7", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     7", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n        k +=k  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        8
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        4
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        7
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 109, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += k\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def combine(i):\n        if i==0:\n            return combiner(base,combine(i+1))\n        elif i==n:\n            return term(i)\n        else:\n            return combiner(term(i),combine(i+1))\n    return combine(0)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if n == 0:\n            return base\n        elif i == 0:\n            return combiner(base, combine(i+1))\n        elif i >= n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine", 
            "    return combiner(term(i), combine(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in combine", 
            "    if i == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def combine(i):\n        if i==0:\n            return combiner(base,combine(i+1))\n        elif i==n:\n            return term(i)\n        else:\n            return combiner(term(i),combine(i+1))\n    if n==0:\n        return base\n    return combine(0)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n        elif i == 0:    =>           \r\n        elif i >= n:    =>           \r\n        if i == 0:      <=           \r\n        elif i == n:    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    if n==0:\r\n        return base\r\n    return combine(0)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}
        }, 
        "Id": 110, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    return combine(0)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, terms[n-1])", 
            "IndexError: list index out of range", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     IndexError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    accumulate(combiner, base, n, term)\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    terms = [term(x) for x in range(1, n + 1)]\n    if n == 1:\n        return combiner(base, terms[n-1])\n    elif n == 0:\n        return base\n    else:\n        return combiner(terms[n-1], accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1:           =>           \r\n    elif n == 0:         =>           \r\n        return base      =>           \r\n    if n == 1 or n == 0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 111, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    accumulate(combiner, base, n, term)\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    terms = [term(x) for x in range(1, n + 1)]\n    if n == 1 or n == 0:\n        return combiner(base, terms[n-1])\n    else:\n        return combiner(terms[n-1], accumulate(combiner, base, n-1, term))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate", 
            "    return combiner(total)", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return total           =>           \r\n    return combiner(total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 112, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return combiner(total)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #result = base\n    #for x in range(1, n+1):\n    #    result = combiner(result, term(x))\n    #return result\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 113, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    f = combiner\n    if n == 0:\n        return base\n    else: \n        return f(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    f = combiner                                                 =>           \r\n        return f(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)   <=           \r\n                                                                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 114, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return term(n)+accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k<=n:\n        total = combiner(term(k), total)\n        k = k + 1\n    return total \n    \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n        if n == 0:                <=           \r\n            n = n -1              <=           \r\n    total = combiner(total, base) <=           \r\n    total = 0                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 115, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<=n:\n        if n == 0:\n            n = n -1\n        total = combiner(term(k), total)\n        k = k + 1\n    total = combiner(total, base)\n    return total \n    \n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    combiner= combiner(x,y)", 
            "NameError: name 'x' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return term(base)\n    if combiner == mul:\n        i, result = 1,1 \n    if combiner==add:\n        i, result= 0,0\n    elif combiner != mul and combiner !=add:\n        x,y=1,1\n        res_comb= combiner(x,y)\n        if res_comb==1:\n            i, result = 1,1\n        else: \n            i, result= 0,0\n    while i <= n:\n        result = combiner(result, term(i))\n        i +=1\n    return combiner(base ,result)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if combiner==add:                        =>           \r\n    elif combiner != mul and combiner !=add: =>           \r\n        x,y=1,1                              =>           \r\n        res_comb= combiner(x,y)              =>           \r\n        if res_comb==1:                      =>           \r\n            i, result = 1,1                  =>           \r\n        else:                                =>           \r\n            i, result= 0,0                   =>           \r\n    combiner= combiner(x,y)                  <=           \r\n    print (combiner)                         <=           \r\n    else:                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 116, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return term(base)\n    combiner= combiner(x,y)\n    print (combiner)\n    if combiner == mul:\n        i, result = 1,1 \n    else:\n        i, result= 0,0\n    while i <= n:\n        result = combiner(result, term(i))\n        i +=1\n    return combiner(base ,result)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (k,final_value)=(2,term(1))\n    while k<=n:\n        final_value=combiner(final_value,term(k))\n        k+=1\n    return combiner(base,final_value)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    k, final_value = 2, term(1)\n    while k <= n:\n        final_value = combiner(final_value, term(k))\n        k += 1\n    return combiner(base, final_value)\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (k,final_value)=(2,term(1))\n    if n==0:\n        return base\n    while k<=n:\n        final_value=combiner(final_value,term(k))\n        k+=1\n    return combiner(base,final_value)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    if n==0:\r\n        return base\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 117, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (t,i)=(start,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    t, i = start, 1", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (t,i)=(base,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 118, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = start, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==add and n > 0:\n        return term(n) + accumulate(combiner, base, n-1, term)\n    elif combiner==mul and n > 0:\n        return term(n) * accumulate(combiner,base,n-1,term)\n    else:\n        return base\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if combiner==add and n > 0:   =>           \r\n    elif combiner==mul and n > 0: =>           \r\n    if combiner==add and n > 1:   <=           \r\n    elif combiner==mul and n > 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 119, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==add and n > 1:\n        return term(n) + accumulate(combiner, base, n-1, term)\n    elif combiner==mul and n > 1:\n        return term(n) * accumulate(combiner,base,n-1,term)\n    else:\n        return base\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term,pred=True):\n    if n==0:\n        return base\n    elif pred(n)==False:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    elif pred(n) == False:", 
            "TypeError: 'bool' object is not callable", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term,pred=True):\n    if n==0:\n        return base\n    elif term(n)==False:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\ndef accumulate(combiner, base, n, term):               =>           \r\ndef accumulate(combiner, base, n, term, pred=True):    <=           \r\n    elif pred(n) == False:                             <=           \r\n        return accumulate(combiner, base, n - 1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif term(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 120, 
        "before": "\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif pred(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n < 1):\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if (n < 1):                                                         =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n    if (n == 0):                                                        <=           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 121, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = base\n    summed = 1\n    while summed <= n:\n        a = combiner(a, term(summed))\n        summed += 1\n    return a\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        a = combiner(a, term(summed))    =>           \r\ndef summation_using_accumulate(n, term): =>           \r\n        a + combiner(a, term(summed))    <=           \r\ndef summaton_using_accumulate(n, term):  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 122, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = base\n    summed = 1\n    while summed <= n:\n        a + combiner(a, term(summed))\n        summed += 1\n    return a\ndef summaton_using_accumulate(n, term):\n    \"\"\"Returns the sum of TERM(1) + ... + TERM(N). The implementation\n    uses accumulate.\n\n    >>> summation_using_accumulate(5, square)\n    55\n    >>> summation_using_accumulate(5, triple)\n    45\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',\n    ...       ['Recursion', 'For', 'While'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return accumulate(add, 0, n, term)\n\ndef product_using_accumulate(n, term):\n    \"\"\"An implementation of product using accumulate.\n\n    >>> product_using_accumulate(4, square)\n    576\n    >>> product_using_accumulate(6, triple)\n    524880\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'product_using_accumulate',\n    ...       ['Recursion', 'For', 'While'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return accumulate(mul, 1, n, term)\n\ndef true(x):\n    return True\n\ndef false(x):\n    return False\n\ndef odd(x):\n    return x % 2 == 1\n\ndef filtered_accumulate(combiner, base, pred, n, term):\n    \"\"\"Return the result of combining the terms in a sequence of N terms\n    that satisfy the predicate PRED.  COMBINER is a two-argument function.\n    If v1, v2, ..., vk are the values in TERM(1), TERM(2), ..., TERM(N)\n    that satisfy PRED, then the result is\n         BASE COMBINER v1 COMBINER v2 ... COMBINER vk\n    (treating COMBINER as if it were a binary operator, like +). The\n    implementation uses accumulate.\n\n    >>> filtered_accumulate(add, 0, true, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> filtered_accumulate(add, 11, false, 5, identity) # 11\n    11\n    >>> filtered_accumulate(add, 0, odd, 5, identity)   # 0 + 1 + 3 + 5\n    9\n    >>> filtered_accumulate(mul, 1, odd, 5, square)  # 1 * 1 * 9 * 25\n    225\n    >>> # Do not use while/for loops or recursion\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'filtered_accumulate',\n    ...       ['While', 'For', 'Recursion', 'FunctionDef'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return _______\n\ndef repeated(f, n):\n    \"\"\"Return the function that computes the nth application of f.\n\n    >>> add_three = repeated(increment, 3)\n    >>> add_three(5)\n    8\n    >>> repeated(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1\n    243\n    >>> repeated(square, 2)(5) # square(square(5))\n    625\n    >>> repeated(square, 4)(5) # square(square(square(square(5))))\n    152587890625\n    >>> repeated(square, 0)(5)\n    5\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef compose1(f, g):\n    \"\"\"Return a function h, such that h(x) = f(g(x)).\"\"\"\n    def h(x):\n        return f(g(x))\n    return h\n\ndef g(n):\n    \"\"\"Return the value of G(n), computed recursively.\n\n    >>> g(1)\n    1\n    >>> g(2)\n    2\n    >>> g(3)\n    3\n    >>> g(4)\n    10\n    >>> g(5)\n    22\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef g_iter(n):\n    \"\"\"Return the value of G(n), computed iteratively.\n\n    >>> g_iter(1)\n    1\n    >>> g_iter(2)\n    2\n    >>> g_iter(3)\n    3\n    >>> g_iter(4)\n    10\n    >>> g_iter(5)\n    22\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'g_iter', ['Recursion'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef pingpong(n):\n    \"\"\"Return the nth element of the ping-pong sequence.\n\n    >>> pingpong(7)\n    7\n    >>> pingpong(8)\n    6\n    >>> pingpong(15)\n    1\n    >>> pingpong(21)\n    -1\n    >>> pingpong(22)\n    0\n    >>> pingpong(30)\n    6\n    >>> pingpong(68)\n    2\n    >>> pingpong(69)\n    1\n    >>> pingpong(70)\n    0\n    >>> pingpong(71)\n    1\n    >>> pingpong(72)\n    0\n    >>> pingpong(100)\n    2\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\ndef has_seven(k):\n    \"\"\"Returns True if at least one of the digits of k is a 7, False otherwise.\n\n    >>> has_seven(3)\n    False\n    >>> has_seven(7)\n    True\n    >>> has_seven(2734)\n    True\n    >>> has_seven(2634)\n    False\n    >>> has_seven(734)\n    True\n    >>> has_seven(7777)\n    True\n    \"\"\"\n    if k % 10 == 7:\n        return True\n    elif k < 10:\n        return False\n    else:\n        return has_seven(k // 10)\n\ndef count_change(amount):\n    \"\"\"Return the number of ways to make change for amount.\n\n    >>> count_change(7)\n    6\n    >>> count_change(10)\n    14\n    >>> count_change(20)\n    60\n    >>> count_change(100)\n    9828\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef print_move(origin, destination):\n    \"\"\"Print instructions to move a disk.\"\"\"\n    print(\"Move the top disk from rod\", origin, \"to rod\", destination)\n\ndef move_stack(n, start, end):\n    \"\"\"Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.\n\n    n -- number of disks\n    start -- a pole position, either 1, 2, or 3\n    end -- a pole position, either 1, 2, or 3\n\n    There are exactly three poles, and start and end must be different. Assume\n    that the start pole has at least n disks of increasing size, and the end\n    pole is either empty or has a top disk larger than the top n start disks.\n\n    >>> move_stack(1, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    >>> move_stack(2, 1, 3)\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 3\n    >>> move_stack(3, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 3 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 1\n    Move the top disk from rod 2 to rod 3\n    Move the top disk from rod 1 to rod 3\n    \"\"\"\n    assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, \"Bad start/end\"\n    \"*** YOUR CODE HERE ***\"\n\n###################\n# Extra Questions #\n###################\n\nfrom operator import sub, mul\n\ndef Y(f):\n    \"\"\"The Y (\"paradoxical\") combinator.\"\"\"\n    return f(lambda: Y(f))\n\n\ndef Y_tester():\n    \"\"\"\n    >>> tmp = Y_tester()\n    >>> tmp(1)\n    1\n    >>> tmp(5)\n    120\n    >>> tmp(2)\n    2\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return Y(________)  # Replace \n\ndef zero(f):\n    return lambda x: x\n\ndef successor(n):\n    return lambda f: lambda x: f(n(f)(x))\ndef one(f):\n    \"\"\"Church numeral 1: same as successor(zero)\"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef two(f):\n    \"\"\"Church numeral 2: same as successor(successor(zero))\"\"\"\n    \"*** YOUR CODE HERE ***\"\n\nthree = successor(two)\n\ndef church_to_int(n):\n    \"\"\"Convert the Church numeral n to a Python integer.\n\n    >>> church_to_int(zero)\n    0\n    >>> church_to_int(one)\n    1\n    >>> church_to_int(two)\n    2\n    >>> church_to_int(three)\n    3\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef add_church(m, n):\n    \"\"\"Return the Church numeral for m + n, for Church numerals m and n.\n\n    >>> church_to_int(add_church(two, three))\n    5\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef mul_church(m, n):\n    \"\"\"Return the Church numeral for m * n, for Church numerals m and n.\n\n    >>> four = successor(three)\n    >>> church_to_int(mul_church(two, three))\n    6\n    >>> church_to_int(mul_church(three, four))\n    12\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef pow_church(m, n):\n    \"\"\"Return the Church numeral m ** n, for Church numerals m and n.\n\n    >>> church_to_int(pow_church(two, three))\n    8\n    >>> church_to_int(pow_church(three, two))\n    9\n    \"\"\"\n    \"*** YOUR CODE HERE ***\""
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 123, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(2, n + 1):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for x in range(2, n + 1): =>           \r\n    for x in range(n):        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 124, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(n):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return acc\n    else:\n        next_acc=combiner(term(n),acc)\n        return accumulate(combiner,next_acc,n-1,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        next_base = combiner(term(n), base)\n        return accumulate(combiner, next_base, n - 1, term)\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    next_acc = combiner(term(n), acc)", 
            "NameError: name 'acc' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        next_acc=combiner(term(n),base)\n        return accumulate(combiner,next_acc,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return base                                         =>           \r\n        next_base = combiner(term(n), base)                 =>           \r\n        return accumulate(combiner, next_base, n - 1, term) =>           \r\n        return acc                                          <=           \r\n        next_acc = combiner(term(n), acc)                   <=           \r\n        return accumulate(combiner, next_acc, n - 1, term)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 125, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return acc\r\n    else:\r\n        next_acc = combiner(term(n), acc)\r\n        return accumulate(combiner, next_acc, n-1, term)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n >= 1:\n        total = combiner(total, term(n))\n        n = n - 1\n    return total\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    while n >= 1:                                                           =>           \r\n        n = n - 1                                                           =>           \r\n    total , counter =  10 , 1                                               =>           \r\n    while counter < n:                                                      =>           \r\n        total , counter  = total + n + 2 * (n-1) + 3 * (n-2) , counter + 1  =>           \r\n    return total                                                            =>           \r\n    while n <= 1:                                                           <=           \r\n        n = n + 1                                                           <=           \r\n                                                                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 126, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n <= 1:\n        total = combiner(total, term(n))\n        n = n + 1\n    return total\n\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner((accumulate(combiner, base, n - 1, term)),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ]
            }
        }, 
        "Id": 127, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 128, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n        return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 129, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 130, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        i = 0\n    if combiner == mul:\n        i = 1\n    def helper(n, term):\n        if n == 0:\n            return i\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if combiner == add:        =>           \r\n        i = 0                  =>           \r\n    if combiner == mul:        =>           \r\n        i = 1                  =>           \r\n            return i           =>           \r\n            return term(n + 1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 131, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return term(n + 1)\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    result = combiner(term(n), result)", 
            "UnboundLocalError: local variable 'result' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n>=1: \n        result = combiner(term(n), result)\n        n -= 1 \n    return result \n\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    result = base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 132, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n>=1: \n        result = combiner(term(n), result)\n        n -= 1 \n    return result \n\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    total = combiner(term, total)", 
            "TypeError: unsupported operand type(s) for +: 'function' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term(x), total)\n    return total\n    \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(x), total) =>           \r\n        total = combiner(term, total)    <=           \r\n                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 133, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term, total)\n\n    return total\n    \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    accum=base\n    if base>n:\n        accum=base\n        base=0\n    for i in range(base+1,n+1):\n        accum=combiner(accum,term(i))\n    return accum\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "18", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     18", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    accum=base\n    if base>n:\n        accum=base\n        base=0\n    for i in range(base>=1,n+1):\n        accum=combiner(accum,term(i))\n    return accum\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    for i in range(1, n+1):      =>           \r\n    for i in range(base+1, n+1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base>=1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "accum": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18
                    ]
                ]
            }
        }, 
        "Id": 134, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base+1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        total=combiner(term(k),total)\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(term(k),total)\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 135, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 136, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accu_helper(i):\n        if i==1:\n            return term(1)\n        else:\n            return combiner(term(i),accu_helper(i-1))\n    return combiner(base,accu_helper(n-1))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n#    if n == 0:\n#        return base\n#    def accu_helper(i):\n#        if i == 1:\n#            return term(1)\n#        else:\n#            return combiner(term(i), accu_helper(i - 1))\n#    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accu_helper(i):\n        if i==1:\n            return term(1)\n        else:\n            return combiner(term(i),accu_helper(i-1))\n    return combiner(base,accu_helper(n-0))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n#    if n == 0:                                           =>           \r\n#        return base                                      =>           \r\n#    def accu_helper(i):                                  =>           \r\n#        if i == 1:                                       =>           \r\n#            return term(1)                               =>           \r\n#        else:                                            =>           \r\n#            return combiner(term(i), accu_helper(i - 1)) =>           \r\n#    return combiner(base, accu_helper(n - 1))            =>           \r\n    if n == 0:                                            <=           \r\n        return base                                       <=           \r\n    def accu_helper(i):                                   <=           \r\n        if i == 1:                                        <=           \r\n            return term(1)                                <=           \r\n        else:                                             <=           \r\n            return combiner(term(i), accu_helper(i - 1))  <=           \r\n    return combiner(base, accu_helper(n - 1))             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-0))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 137, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\ndef helper(i, total): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 138, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\ndef helper(i, total):\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def after_base(combiner,n,term,i):\n        if i==n:\n            return term(n)\n        return combiner(term(i),after_base(combiner,n,term,i+1))\n    return combiner(base,after_base(combiner,n,term,1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if n==0:\n            return 0\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base", 
            "    return combiner(term(i), after_base(combiner, n, term, i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in after_base", 
            "    if i==n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def after_base(combiner,n,term,i):\n        if i==n:\n            return term(n)\n        return combiner(term(i),after_base(combiner,n,term,i+1))\n    if n==0:\n        return base\n    return combiner(base,after_base(combiner,n,term,1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n==0:     =>           \r\n            return 0 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, after_base(combiner, n, term, 1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}
        }, 
        "Id": 139, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    return combiner(base, after_base(combiner, n, term, 1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(base,term(k))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(total, term(k))\n        k+= 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        base=combiner(base,term(k))\n        k+=1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(k)) =>           \r\n        total = combiner(base, term(k))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        base = combiner(base, term(k))\r\n        k += 1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 140, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(base, term(k))\r\n        k += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    if pred(term(y))==True:", 
            "NameError: name 'pred' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        x = combiner(x, term(y))\n        y -= 1\n    return x\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n        x = combiner(x, term(y))                                      =>           \r\n    return accumulate(combiner, base, lambda n : pred(n)==True, term) =>           \r\n        if pred(term(y))==True:                                       <=           \r\n            x = combiner(x, term(y))                                  <=           \r\n    return accumulate(combiner, base, n, term)                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 141, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        if pred(term(y))==True:\n            x = combiner(x, term(y))\n        y -= 1\n    return x\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i+1))\n        print total\n        i+=1\n    return combiner(total,term(n))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n3\n6\n10\n15\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n14\n17\n21\n26\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n8\n72\n72\n", 
            "print accumulate(add, 11, 3, square)": "12\n16\n25\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n3\n6\n10\n15\n20\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n14\n17\n21\n26\n31\n", 
            "print accumulate(mul, 2, 3, square)": "2\n8\n72\n648\n", 
            "print accumulate(add, 11, 3, square)": "12\n16\n25\n34\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i+1))\n        #term(i) = total\n        #print (total)\n        i += 1\n    return total \n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "3", 
            "6", 
            "10", 
            "15", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "#     3", 
            "#     6", 
            "#     10", 
            "#     15", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i+1))\n        print total\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        #print (total)               =>           \r\n    return total                     =>           \r\n        print (total)                <=           \r\n    return combiner(total, term(n))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 142, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return combiner(total, term(n))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return cominer(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return cominer( term(n), accumulate(combiner, base, n-1, term))", 
            "NameError: name 'cominer' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return cominer( term(n), accumulate(combiner, base, n-1, term))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 143, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return cominer(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 144, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    def counter_n(r):\n        if r >= n and combiner==add:\n            return 0\n\n        if r >= n and combiner==mul:\n            return 1\n\n        else:\n            return combiner(term(r), counter_n(r+1))\n\n\n    return combiner(combiner(base, counter_n(1)), term(n))\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if r >= n and combiner==add: =>           \r\n        if r >= n and combiner==mul: =>           \r\n            return 1                 =>           \r\n                                     =>           \r\n                                     =>           \r\n                                     =>           \r\n        if r >= n:                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 145, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    def counter_n(r):\n        if r >= n:\n            return 0\n        else:\n            return combiner(term(r), counter_n(r+1))\n\n    return combiner(combiner(base, counter_n(1)), term(n))\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "120", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     120", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,combiner(total,term(n)))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n    total=base                                                             =>           \r\n            return totaler(combiner,base,n-1,term,combiner(total,term(n))) =>           \r\n    total=1                                                                <=           \r\n            return totaler(combiner,base,n-1,term,total*term(n))           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 146, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=1\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,total*term(n))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combine(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        \nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combine(accumulate(combiner, base, n-1, term), term(n))", 
            "NameError: name 'combine' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 147, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combine(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def term_recursion(n):\n        if n==0:\n            return 1\n        else:\n            return combiner(term(n),term_recursion(n-1))\n    return combiner(base,term_recursion(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def term_recursion(n):\n        if n==1:\n            return 1\n        else:\n            return combiner(term(n),term_recursion(n-1))\n    return combiner(base,term_recursion(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n        if n == 0:         <=           \r\n            return 1       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 148, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==0:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 :\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0 :                                                           =>           \r\n        return base                                                       =>           \r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n)) =>           \r\n    if n <=1 :                                                            <=           \r\n        return combiner(base, term(1))                                    <=           \r\n        combiner(accumulate(combiner, base, n - 1, term), term(n))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 149, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <=1 :\n        return combiner(base, term(1))\n    else:\n        combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "15\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 150, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return total \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = term(i)               <=           \r\n    return combiner(base, total)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 151, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = term(i)\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return combiner(base, total) \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    base=combiner(base,term(n))\n    return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    \n    if n == 1:\n        return combiner(base, term(1))\n    \n    base = combiner(base, term(n))\n    \n    return accumulate(combiner, base, n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    base=combiner(base,term(n))\n    return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n                    =>           \r\n                    =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "base": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        10, 
                        8, 
                        5, 
                        1, 
                        -4, 
                        -10, 
                        -17, 
                        -25, 
                        -34, 
                        -44, 
                        -55, 
                        -67, 
                        -80, 
                        -94, 
                        -109, 
                        -125, 
                        -142, 
                        -160, 
                        -179, 
                        -199, 
                        -220, 
                        -242, 
                        -265, 
                        -289, 
                        -314, 
                        -340, 
                        -367, 
                        -395, 
                        -424, 
                        -454, 
                        -485, 
                        -517, 
                        -550, 
                        -584, 
                        -619, 
                        -655, 
                        -692, 
                        -730, 
                        -769, 
                        -809, 
                        -850, 
                        -892, 
                        -935, 
                        -979, 
                        -1024, 
                        -1070, 
                        -1117, 
                        -1165, 
                        -1214, 
                        -1264, 
                        -1315, 
                        -1367, 
                        -1420, 
                        -1474, 
                        -1529, 
                        -1585, 
                        -1642, 
                        -1700, 
                        -1759, 
                        -1819, 
                        -1880, 
                        -1942, 
                        -2005, 
                        -2069, 
                        -2134, 
                        -2200, 
                        -2267, 
                        -2335
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69
                    ]
                ]
            }
        }, 
        "Id": 152, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        combiner(total, term(i))         <=           \r\n                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 153, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        combiner(total, term(i))\n    return total\n\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n):   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 154, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n):\n        total=combiner(total, term(i))\n    return total\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "6", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     6", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while y<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while y<=n: =>           \r\n    while x<=n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 155, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while x<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(func,x,combiner):\n        if n==0:\n            return base\n        elif x==n:\n            return base+func(x)\n        else:\n            return combiner(func(x),helper(term,x+1,combiner))\n    return helper(term,1,combiner)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "44\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return combiner(base, func(x))\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "44", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     44", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(func,x,combiner):\n        if n==0:\n            return base\n        elif x==n:\n            return combiner(base,func(x))\n        else:\n            return combiner(func(x),helper(term,x+1,combiner))\n    return helper(term,1,combiner)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return combiner(base, func(x)) =>           \r\n            return base + func(x)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return combiner(base, func(x))\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 156, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return base+func(x)\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "2", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     2", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    total = 0           <=           \r\n    return base + total <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 157, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return base + total\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i = increment(i)\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, i = base, 1                       =>           \r\n        total = combiner(total, term(i))     =>           \r\n    return total                             =>           \r\n    total, i = 1, 0                          <=           \r\n        total = combiner(term(i), term(i+1)) <=           \r\n        total = combiner(total, term(n))     <=           \r\n    return combiner(base, total)             <=           \r\n    else:                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 158, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = 1, 0\n    while i <= n:\n        total = combiner(term(i), term(i+1))\n        i = increment(i)\n    else:\n        total = combiner(total, term(n))\n    return combiner(base, total)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return 0                       <=           \r\n    if n == 1:                         <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 159, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    result = base\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    result = base =>           \r\n    i = base      <=           \r\n    result = 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 160, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = base\n    result = 0\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==base or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "18", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     18", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if combiner==base or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if n==0:            =>           \r\n    if n==base or n==0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 161, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    while n<=k:", 
            "NameError: name 'k' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    while k<=n:\n        base = combiner(base, term(k))\n        k +=1\n    return base\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                   SideIndicator\r\n-----------                                                                                   -------------\r\n    k=1                                                                                       =>           \r\n    while k<=n:                                                                               =>           \r\n        base = combiner(base, term(k))                                                        =>           \r\n        k +=1                                                                                 =>           \r\n    n=1                                                                                       <=           \r\n    while n<=k:                                                                               <=           \r\n        base = combiner(base, term(n))                                                        <=           \r\n        n +=1                                                                                 <=           \r\n    return accumulate((lambda combiner: combiner if pred(combiner) else None), base, n, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 162, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    n=1\n    while n<=k:\n        base = combiner(base, term(n))\n        n +=1\n    return base\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 163, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=1:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>=1: =>           \r\n    while n>=0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        72, 
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ]
            }
        }, 
        "Id": 164, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    while n >= 0:\n        if n == 0:\n            return end\n        else:\n            end = combiner(end, term(n))\n            n -=1\n    return end\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 0:                        =>           \r\n        if n == 0:                       =>           \r\n            return end                   =>           \r\n        else:                            =>           \r\n            end = combiner(end, term(n)) =>           \r\n            n -=1                        =>           \r\n    if n == 0:                           <=           \r\n        return end                       <=           \r\n    elif n > 0:                          <=           \r\n        end = combiner(end, term(n))     <=           \r\n        n -=1                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 165, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    if n == 0:\n        return end\n    elif n > 0:\n        end = combiner(end, term(n))\n        n -=1\n    return end\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n ==0:\n        return base             \n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n ==0:         =>           \r\n    if n ==0 or n==1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 166, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return 1\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "13\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "24\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "21\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "13", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     13", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==base:\n        return 1\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    elif n == 1: <=           \r\n        return 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==base:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        9, 
                        4, 
                        1, 
                        4, 
                        9, 
                        2
                    ], 
                    [
                        2, 
                        9, 
                        4, 
                        9, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        9, 
                        4, 
                        1, 
                        4, 
                        9, 
                        11
                    ], 
                    [
                        11, 
                        9, 
                        4, 
                        9, 
                        11
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 167, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (k,total)=(1,0)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, base\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    k, total = 1, base =>           \r\n    k, total = 1, 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 168, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, 0\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n    # total = combiner(base, term(n))\n    # def recursive_combiner(combiner, n, term):\n    #    if count == 1:\n    #        return combiner(base, term(n))\n    #    if count == n:\n    #        return total\n    #    return recursive_combiner(combiner, n-1, term)\n\n    #return recursive_combiner(combiner, n, term)\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    # total = combiner(base, term(n))                               =>           \r\n    # def recursive_combiner(combiner, n, term):                    =>           \r\n    #    if count == 1:                                             =>           \r\n    #        return combiner(base, term(n))                         =>           \r\n    #    if count == n:                                             =>           \r\n    #        return total                                           =>           \r\n    #    return recursive_combiner(combiner, n-1, term)             =>           \r\n    #return recursive_combiner(combiner, n, term)                   =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n    total = term(n)                                                 <=           \r\n    if n == base:                                                   <=           \r\n        return total                                                <=           \r\n    return combiner(n-1, total)                                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 169, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(n)\n    if n == base:\n        return total\n    return combiner(n-1, total)\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    total, k = combiner * total * term(k), k + 1", 
            "TypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        total, k = combiner(term(k), total), k + 1   =>           \r\n        total, k = combiner * total * term(k), k + 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 170, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner * total * term(k), k + 1\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return term(i)+accumulate(combiner,base,n-1,term)\n    return helper(n)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i),accumulate(combiner,base,n-1,term))\n    return helper(n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term)) =>           \r\n            return term(i) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\r\n    return helper(n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 171, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return term(i)+accumulate(combiner, base, n-1, term)\r\n    return helper(n)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    total = combiner(term(i))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(term(i))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 172, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(term(i))\n        i += 1\n    return total\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 173, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==0:\n        return combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n        return combiner(base,accumulate(combiner,0,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n==0:\n    \treturn base\n    elif base==0 and n==1:\n    \treturn term(1)\n    elif base==0:\n    \treturn combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n    \treturn combiner(base,accumulate(combiner,0,n,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==base:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,accumulate(combiner,0,n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    elif base==0 and n==1: =>           \r\n        return term(1)     =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==base:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        0, 
                        2
                    ]
                ]
            }
        }, 
        "Id": 174, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==0:\r\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return base+accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "66\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "44\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return base + accumulate(combiner, base, n - 1, term)             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 175, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return base+accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(c,term(i))\n        i=i+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(total, term(i))\n        i=i+1\n    return total \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    total = combiner(c, term(i))", 
            "NameError: name 'c' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i=i+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(c, term(i))     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 176, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(c, term(i))\r\n        i = i+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return reduce([base] + map(range(1, n+1), term), combiner)", 
            "NameError: name 'reduce' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     term1 = term(1)\n    #     accum = combiner(base, term1)\n    #     k = 2\n    #     while k <= n:\n    #         terms = term(k)\n    #         accum = combiner(accum, terms)\n    #         k += 1\n    #     return accum\n    res = base\n    for i in [term(x) for x in range(1, n+1)]:\n        res = combiner(res, i)\n    return res\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    res = base                                                 =>           \r\n    for i in [term(x) for x in range(1, n+1)]:                 =>           \r\n        res = combiner(res, i)                                 =>           \r\n    return res                                                 =>           \r\n    return reduce([base] + map(range(1, n+1), term), combiner) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 177, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     term1 = term(1)\n    #     accum = combiner(base, term1)\n    #     k = 2\n    #     while k <= n:\n    #         terms = term(k)\n    #         accum = combiner(accum, terms)\n    #         k += 1\n    #     return accum\n    return reduce([base] + map(range(1, n+1), term), combiner)\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        if n==0:\n            return base\n        else:\n            total=combiner(base,term(k))\n            k=k+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        if n==0:\n            return base\n        else:\n            total=combiner(total,term(k))\n            k=k+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            total = combiner(total, term(k)) =>           \r\n            total = combiner(base, term(k))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(total, term(k))\r\n            k = k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }
        }, 
        "Id": 178, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(base, term(k))\r\n            k = k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    total=0\n    if n==0:\n        return base\n    else:\n        total=combiner(term(n),total)\n        return accumulate(combiner,total,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "1\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "1\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    total = base\n    if n == 0:\n        return total\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    else:\n        total=combiner(term(n),total)\n        return accumulate(combiner,total,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total = base                          =>           \r\n        return total                      =>           \r\n    total = 0                             <=           \r\n        return base                       <=           \r\n    \"\"\"while i <= n:                      <=           \r\n        total == combiner(total, term(i)) <=           \r\n        i += 1                            <=           \r\n    return total\"\"\"                       <=           \r\n                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5
                    ], 
                    [
                        0, 
                        5, 
                        0, 
                        4, 
                        0, 
                        3, 
                        0, 
                        2, 
                        0, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16
                    ], 
                    [
                        0, 
                        5, 
                        0, 
                        4, 
                        0, 
                        3, 
                        0, 
                        2, 
                        0, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20
                    ], 
                    [
                        0, 
                        9, 
                        0, 
                        4, 
                        0, 
                        1, 
                        0, 
                        1, 
                        4, 
                        9
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5, 
                        0
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2, 
                        0, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16, 
                        11
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11, 
                        9, 
                        4, 
                        1, 
                        4, 
                        9, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 179, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    total = 0\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        i = 1\n        total = base\n        while i <= n:\n            total = combiner(term(i), total)\n            i += 1\n        return total\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if n == 0:                               =>           \r\n        return term(base)                    =>           \r\n        i = 1                                =>           \r\n        total = base                         =>           \r\n        while i <= n:                        =>           \r\n            total = combiner(term(i), total) =>           \r\n            i += 1                           =>           \r\n        return total                         =>           \r\n    else:                                    =>           \r\n                                             =>           \r\n                                             =>           \r\n    i = 1                                    <=           \r\n    total = 1                                <=           \r\n    while i <= n:                            <=           \r\n        total = term(i) + total              <=           \r\n        i += 1                               <=           \r\n    return total                             <=           \r\n    \"*** YOUR CODE HERE ***\"                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 180, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner, base, n+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                 =>           \r\n    if pred == false:                                                                   =>           \r\n        return base                                                                     =>           \r\n        return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term) =>           \r\n    else:                                                                               =>           \r\n        return combiner(term(base), accumulate(combiner, base, n+1, term))              <=           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 181, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(base), accumulate(combiner, base, n+1, term))        \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulater(i):\n        if n==0:\n            return base\n        if i<n:\n            return combiner(term(i),accumulater(i+1))\n        elif i==n:\n            return combiner(term(i),base)\n        return n\n    return accumulater(1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "72", 
            "", 
            "# Error: expected", 
            "#     73", 
            "# but got", 
            "#     72", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulater(i):\n        if n==0:\n            return base\n        if i<n:\n            return combiner(term(i),accumulater(i+1))\n        elif i==n:\n            return combiner(term(i),base)\n        return n\n    return accumulater(1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n    73      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 182, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    (i,total)=(1,base)\n    while i!=n:\n        total=combiner(term(i),total)\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n + 1:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    (i,total)=(1,base)\n    while i!=n+1:\n        total=combiner(term(i),total)\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while i != n + 1: =>           \r\n    while i != n:     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n+1:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 183, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=base\n    counter = 1\n\n    while counter <=n:\n        total = combiner(total,term(counter))\n        counter+=1\n\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    total=base                                =>           \r\n        total = combiner(total,term(counter)) =>           \r\n    return total                              =>           \r\n    total=0                                   <=           \r\n        total = combiner(base,term(counter))  <=           \r\n    return combiner(total,base)               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 184, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=0\n    counter = 1\n\n    while counter <=n:\n        total = combiner(base,term(counter))\n        counter+=1\n\n    return combiner(total,base)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = base\n    i = 1\n    while i <= n:\n        tot = combiner(tot, term(i))\n        i+=1\n    return tot\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    tot = base                          =>           \r\n    i = 1                               =>           \r\n    while i <= n:                       =>           \r\n        tot = combiner(tot, term(i))    =>           \r\n        i+=1                            =>           \r\n    tot = term(base);                   <=           \r\n    base += 1                           <=           \r\n    while base <= n:                    <=           \r\n        tot = combiner(tot, term(base)) <=           \r\n        base+=1                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 185, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = term(base);\n    base += 1\n    while base <= n:\n        tot = combiner(tot, term(base))\n        base+=1\n    return tot\n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def combine(combiner,n,term):\n        if n==1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),combine(combiner,n-1,term))\n    return combine(combiner,n,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine", 
            "    return combiner(term(n), combine(combiner, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in combine", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def combine(combiner,n,term):\n        if n<=1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),combine(combiner,n-1,term))\n    return combine(combiner,n,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n<=1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 186, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    helper(n)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper", 
            "    return combiner(term(i), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    helper(n)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper", 
            "    return combiner(term(i), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    helper(n)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper", 
            "    return combiner(term(i), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    helper(n)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper", 
            "    return combiner(term(i), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    helper(n)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper", 
            "    return combiner(term(i), accumulate(combiner, base, n-1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return helper(n) =>           \r\n    helper(n)        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 187, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 188, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base \n    elif n == 1: \n        return combiner(term(1), base)\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                                             SideIndicator\r\n-----------                                                                                                             -------------\r\n    if n == 0:                                                                                                          =>           \r\n        return base                                                                                                     =>           \r\n    elif n == 1:                                                                                                        =>           \r\n        return combiner(term(1), base)                                                                                  =>           \r\n    else:                                                                                                               =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                 =>           \r\n    return accumulate(add, 0, n, term)                                                                                  =>           \r\n    return accumulate(mul, 1, n, term)                                                                                  =>           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)                                     =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return f                                                                                                        =>           \r\n    elif n == 0:                                                                                                        =>           \r\n        return identity                                                                                                 =>           \r\n    else:                                                                                                               =>           \r\n        return compose1(f, repeated(f, n-1))                                                                            =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)                                                                   =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n        n_minus_1, n_minus_2, n_minus_3  = 3, 2, 1                                                                      =>           \r\n        k = 4                                                                                                           =>           \r\n        while k <= n:                                                                                                   =>           \r\n            n_minus_1, n_minus_2, n_minus_3 = n_minus_2, n_minus_1, n_minus_1 + 2*n_minus_2+ 3*n_minus_3                =>           \r\n            k = k + 1                                                                                                   =>           \r\n    return n_minus_1                                                                                                    =>           \r\n    def move(k, i, forward):                                                                                            =>           \r\n        if k == n:                                                                                                      =>           \r\n            return i                                                                                                    =>           \r\n        elif forward:                                                                                                   =>           \r\n            return change(k+1, i+1, forward) #it is looking for the k(th) term in the sequence, i moves between 0 and 7 =>           \r\n        else:                                                                                                           =>           \r\n            return change(k+1, i-1, forward)#if forward is true, i will be reduced                                      =>           \r\n    def change(k, i, forward):                                                                                          =>           \r\n        if k % 7 == 0 or has_seven(k):                                                                                  =>           \r\n            return move(k, i, not forward) #move down                                                                   =>           \r\n        else:                                                                                                           =>           \r\n            return move(k, i, forward) #move forward                                                                    =>           \r\n                                                                                                                        =>           \r\n    if n < 7:                                                                                                           =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return move(7,7, False)                                                                                         =>           \r\n    else:                                                                                                               =>           \r\nfrom math import *                                                                                                      =>           \r\n    def count(n, m):                                                                                                    =>           \r\n        if m == 1:                                                                                                      =>           \r\n            return 1                                                                                                    =>           \r\n        if n < 0:                                                                                                       =>           \r\n            return 0                                                                                                    =>           \r\n        with_m = count(n - m, m)                                                                                        =>           \r\n        without_m = count(n, m//2)                                                                                      =>           \r\n        return with_m + without_m                                                                                       =>           \r\n    return count(amount, 2**highest_power(amount))                                                                      =>           \r\n#this question was done using John Denero's Fall 2015 Lecture on recursion (lec 7), where he showed how yo sol          =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return print_move(start,end)                                                                                    =>           \r\n    if start == 1 or end == 1:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 3                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 1                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 1 or end == 1:                                                                                      =>           \r\n            middle = 2                                                                                                  =>           \r\n    def move():                                                                                                         =>           \r\n        move_stack(n-1, start, middle)                                                                                  =>           \r\n        print_move(start, end)                                                                                          =>           \r\n        move_stack(n-1, middle, end)                                                                                    =>           \r\n    return move()                                                                                                       =>           \r\n                                                                                                                        =>           \r\n                                                                                                                        =>           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 189, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (k,b)=(1,base)\n    while k<=n:\n        (b,k)=(combiner(base,term(k)),k+1)\n    return b\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(b,term(k)), k+1\n    return b\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (k,b)=(1,base)\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        b,k = combiner(b,term(k)), k+1    =>           \r\n        b,k = combiner(base,term(k)), k+1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "b": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 190, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        b, k = combiner(base, term(k)), k+1\r\n    return b"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,f(i))\n        i=i+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, term(i))\n        i = i + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    total = combiner(total, f(i))", 
            "NameError: name 'f' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i=i+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 191, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, f(i))\r\n        i = i+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    a=0\n    while n>1:\n        b=combiner(term(n),term(n-1))\n        a+=b\n        n-=2\n    if n==1:\n        a=combiner(a,combiner(base,term(1)))\n    if n==0:\n        return a\n    return a\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return combiner(a,base)\n    return a\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    a=0\n    if n==0:\n        return base\n    while n>1:\n        b=combiner(term(n),term(n-1))\n        a+=b\n        n-=2\n    if n==1:\n        a=combiner(a,combiner(base,term(1)))\n    if n==0:\n        return a\n    return a\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        return combiner(a,base) =>           \r\n        return a                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 192, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "3", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     3", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    while k <= n:                       =>           \r\n    return total                        =>           \r\n    if k <= n:                          <=           \r\n        return combiner(total, term(k)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 193, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    if k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n        return combiner(total, term(k))\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "18", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     18", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<= n:\n        if combiner == mul and k==1:\n                total = 1\n        total = combiner(total, term(k))\n        k = k + 1\n    return combiner(base, total)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if combiner == mul and k==1: =>           \r\n        if combiner == mul:          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 194, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<= n:\n        if combiner == mul:\n                total = 1\n        total = combiner(total, term(k))\n        k = k + 1\n    return combiner(base, total)\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    for i in range(1,n+1):\n        total=combiner(base,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=0\n    for i in range(1,n+1):\n        base=combiner(base,term(i))\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    total = base                         =>           \r\n        total = combiner(total, term(i)) =>           \r\n    total = 0                            <=           \r\n        total = combiner(base, term(i))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        base = combiner(base, term(i))\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 195, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        total = combiner(base, term(i))\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=1\n    partial_total=base\n    while k<n+1:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=1          =>           \r\n    while k<n+1: =>           \r\n    k=0          <=           \r\n    while k<n:   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 196, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=0\n    partial_total=base\n    while k<n:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while n+1>k:\n        total=combiner(total,term(n))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(k))\n        k += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while n+1>k:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner (total, term(k)) =>           \r\n                                          =>           \r\n        total = combiner (total, term(n)) <=           \r\n                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }
        }, 
        "Id": 197, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(n))\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (t,i)=(start,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    t, i = start, 1", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (t,i)=(base,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 198, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = start, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n                    =>           \r\n    if n == 1:      <=           \r\n                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 199, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "6", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     6", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    '''number = 1\n    for i in [1,n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)'''\n\n    number = base\n    for i in range(1, n+1):\n        number = combiner(number, term(i))\n    return number\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    '''number = 1                          =>           \r\n    for i in [1,n]:                        =>           \r\n    return combiner(base, number)'''       =>           \r\n    number = base                          =>           \r\n    for i in range(1, n+1):                =>           \r\n        number = combiner(number, term(i)) =>           \r\n    return number                          =>           \r\n                                           =>           \r\n                                           =>           \r\n    number = 1                             <=           \r\n    for i in [0, n]:                       <=           \r\n    return combiner(base, number)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 200, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    number = 1\n    for i in [0, n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total+term(k))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    total = combiner(total + term(k))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner(total, term(k))  =>           \r\n        total = combiner(total + term(k)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 201, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total+term(k))\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k=increment(k)\n        print total\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n3\n6\n10\n15\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n14\n17\n21\n26\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n8\n72\n72\n", 
            "print accumulate(add, 11, 3, square)": "12\n16\n25\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n3\n6\n10\n15\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n14\n17\n21\n26\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n8\n72\n72\n", 
            "print accumulate(add, 11, 3, square)": "12\n16\n25\n25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total, k = base, 1\n\n    while k <= n:\n        total = combiner(total,term(k))\n        k = increment(k)\n        \n\n\n    return total\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "3", 
            "6", 
            "10", 
            "15", 
            "15", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "#     3", 
            "#     6", 
            "#     10", 
            "#     15", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k=increment(k)\n        print total\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 202, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def total(m):\n        if m==0:\n            return base\n        else:\n            return combiner(term(m),total(m-1))\n    return total(1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(n)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def total(m):\n        if m==0:\n            return base\n        else:\n            return combiner(term(m),total(m-1))\n    return total(n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total(n) =>           \r\n    return total(1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "m": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        0, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 203, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(1)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))", 
            "TypeError: 'int' object is not callable", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 204, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n)))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        accumulation=accumulate(combiner,base,n-1,term)\n        if n==1:\n            n=term(n)\n        return combiner(n,accumulation)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n >= 1:\n            n = term(n)\n        return combiner(n, accumulation)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        accumulation=accumulate(combiner,base,n-1,term)\n        if 1==1:\n            n=term(n)\n        return combiner(n,accumulation)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n >= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if 1==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "accumulation": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16
                    ], 
                    [
                        11, 
                        12, 
                        14
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8
                    ], 
                    [
                        2, 
                        4
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        4, 
                        3, 
                        9
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        4, 
                        3, 
                        9
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 205, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if n==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,x)=(base,0)\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 1\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,x)=(base,1)\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, x = base, 1 =>           \r\n                       =>           \r\n    total, x = base, 0 <=           \r\n                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 1\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 206, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 0\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def counter(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1))\n    if n == 0:\n        return base\n    else:         \n        return combiner(base, counter(1))   \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter", 
            "    return combiner(term(i), counter(i+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in counter", 
            "    if i == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def counter(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),counter(i+1))\n    if n==0:\n        return base\n    return combiner(base,counter(1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n            return combiner(term(i), counter(i+1))  =>           \r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n    else:                                           =>           \r\n        return combiner(base, counter(1))           =>           \r\n            return combiner(term(i), counter(i+1))  <=           \r\n    return combiner(base, counter(1))               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, counter(1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}
        }, 
        "Id": 207, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 208, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    amount = base\n    if n == 0:\n        return combiner(base, 0)\n    while counter <= n:\n        if term(n):\n            amount = combiner(amount, term(counter))\n            counter = counter + 1\n    return amount\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    counter = 1         =>           \r\n    while counter <= n: =>           \r\n    counter = 0         <=           \r\n    while counter < n:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 209, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    amount = base\n    if n == 0:\n        return combiner(base, 0)\n    while counter < n:\n        if term(n):\n            amount = combiner(amount, term(counter))\n            counter = counter + 1\n    return amount\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n    return sum_function(n)\n            \n        \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return sum_function(n) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 210, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n            \n        \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,i)=(0,1)\n        while i<=n:\n            total=combiner(term(i),total)\n            i+=1\n    return combiner(base,total)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0: \n        return base\n    else: \n        total, i = base, 1\n        while i < n: \n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,i)=(base,1)\n        while i<=n:\n            total=combiner(term(i),total)\n            i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n                                    =>           \r\n        total, i = base, 1          =>           \r\n        while i < n:                =>           \r\n    return combiner(term(n), total) =>           \r\n                                    <=           \r\n        total, i = 0, 1             <=           \r\n        while i <= n:               <=           \r\n    return combiner(base, total)    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = base, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 211, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = 0, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return combiner(base, total)\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        if combiner==add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return base\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        if combiner==add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n            return base =>           \r\n        return base     =>           \r\n            return 0    <=           \r\n        return 0        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 212, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return combiner (accumulate(combiner, base, n-1, term), term(n)) \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n      return combiner (accumulate(combiner, base, n-1, term), term(n))  =>           \r\n      return accumulate(combiner, base, n-1, term)                      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 213, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def together(i):\n        if i<n:\n            return combiner(term(i),together(i+1))\n        else:\n            return term(n)\n    return together(1)+base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "38\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return combiner(together(1) , base)\n\n\n    \n   \n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def together(i):\n        if i<n:\n            return combiner(term(i),together(i+1))\n        else:\n            return term(n)\n    return combiner(together(1),base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return combiner(together(1) , base) =>           \r\n    return together(1) + base           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return combiner(together(1), base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 214, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return together(1)+base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(1),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    \n \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 215, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(1), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==mul:\n        answer=1\n    else:\n        answer=0\n    while i<n+1:\n        answer=combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    answer = base\n    while i < (n+1):\n        answer = combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==mul:\n        answer=base\n    else:\n        answer=base\n    while i<n+1:\n        answer=combiner(answer,term(i))\n        i+=1\n    return answer\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    answer = base       =>           \r\n    if combiner == mul: <=           \r\n        answer = 1      <=           \r\n        answer = 0      <=           \r\n    else:               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = base\r\n    else:\r\n        answer = base\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "answer": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ]
            }
        }, 
        "Id": 216, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = 1\r\n    else:\r\n        answer = 0\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n    total=base\n    x=1\n    if n==0:\n        return identity(base)\n    while x<=n:\n        total=combiner(total,term(x))\n        x+=1\n    return total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    total = base\n    x = 1 #start at 1 to deal with the edge case when you square 0\n    if(n == 0):\n        return identity(base)\n    while x <= n: #<= because first one is adding base\n        total = combiner(total, term(x)) \n        x += 1\n    return total\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n    total=base\n    x=1\n    if n==0:\n        return identity(base)\n    while x<=n:\n        total=combiner(total,term(x))\n        x+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 0:           =>           \r\n    if n == 0 or n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 217, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return counter\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return base\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    return counter", 
            "NameError: name 'counter' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    return base    =>           \r\n    return counter <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 218, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return counter"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    for num in range(1,n+1):\n        total=combiner(total,term(num))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "72", 
            "", 
            "# Error: expected", 
            "#     ", 
            "# but got", 
            "#     72", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for num in range(1,n+1):\n        total=combiner(total,term(num))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 219, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,n,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "15\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n        return combiner(term(n), accumulate(combiner, n, n-1,term))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 220, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, n, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        elif n ==1:\n            return term(1)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n ==1:        =>           \r\n            return term(1) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 221, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(0),term(1))\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n<0:\n        return term(0)\n    else:\n        return combiner(base, accumulate(combiner,term(n),term(n-1),term))\"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "1", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(0),term(1))\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return base                       =>           \r\n        return combiner(term(0), term(1)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 222, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,f(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    total = combiner(total, f(i))", 
            "NameError: name 'f' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 223, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, f(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    combine = base\n    while i < n:\n        i += 1\n        combine = combiner(combine, term(i))\n    return combine\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    combine = base                           =>           \r\n        combine = combiner(combine, term(i)) =>           \r\n        combine = combiner(base, term(i))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 224, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    while i < n:\n        i += 1\n        combine = combiner(base, term(i))\n    return combine\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 225, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if n == 0:\n            return base\n        if i >= n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if n == 0:                     =>           \r\n            return base                =>           \r\n        if i >= n:                     =>           \r\n    return help(1, term)               =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n        if i == n:                     <=           \r\n    return help(0, term)               <=           \r\n    return _______                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 226, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if i == n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(0, term)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    counter=1\n    result=start\n    while n>0:\n        result=combiner(result,term(counter))\n        n-=1\n        counter+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = base \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    result = start", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    counter=1\n    result=base\n    while n>0:\n        result=combiner(result,term(counter))\n        n-=1\n        counter+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result = base   =>           \r\n    result = start  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = base\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 227, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = start\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n),accumulate(n-1))", 
            "TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return combiner(term(n),accumulate(n-1))                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 228, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 229, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 230, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n-1):\n        total=combiner(total,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "6\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "17\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "6", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     6", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n-1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 231, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n-1):\r\n        total = combiner(total, term(i))\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, i = combiner(total, term(i)), i + 1 =>           \r\n        total = combiner(total, term(i))           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 232, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    total, k = combiner(total,term (k))", 
            "TypeError: 'int' object is not iterable", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term (k)), k+1\n    return total\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        total, k = combiner(total,term (k)), k+1 =>           \r\n        total, k = combiner(total,term (k))      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 233, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term (k))\n    return total\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, n-1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n        return                                                          <=           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 234, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return\n    else:\n        return combiner(base, accumulate(combiner, base, n-1, term))\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "221592999", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     221592999", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(n, term(accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 235, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(n, term(accumulate(combiner, base, n-1, term)))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    accumulate_sum=base\n    counter=1\n    while counter<=n:\n        print term(counter)\n        accumulate_sum=combiner(accumulate_sum,term(counter))\n        counter+=1\n    return accumulate_sum\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n2\n3\n4\n5\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "1\n2\n3\n4\n5\n26\n", 
            "print accumulate(mul, 2, 3, square)": "1\n4\n9\n72\n", 
            "print accumulate(add, 11, 3, square)": "1\n4\n9\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n2\n3\n4\n5\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "1\n2\n3\n4\n5\n26\n", 
            "print accumulate(mul, 2, 3, square)": "1\n4\n9\n72\n", 
            "print accumulate(add, 11, 3, square)": "1\n4\n9\n25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n        \"\"\"\n   \n    accumulate_sum = base\n    counter = 1\n    while counter <= n:\n        accumulate_sum = combiner(accumulate_sum, term(counter))\n        counter += 1\n    return accumulate_sum\n\n  \nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "2", 
            "3", 
            "4", 
            "5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "#     2", 
            "#     3", 
            "#     4", 
            "#     5", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    accumulate_sum=base\n    counter=1\n    while counter<=n:\n        print term(counter)\n        accumulate_sum=combiner(accumulate_sum,term(counter))\n        counter+=1\n    return accumulate_sum\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        print (term(counter)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 236, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 237, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    elif n==1:\n        return combiner(term(base),term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    elif n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return combiner(base, term(1))       =>           \r\n        return combiner(term(base), term(1)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 238, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(term(base), term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n>0:\n        if pred(n):\n            return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if pred(n):", 
            "NameError: name 'pred' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n>0:\n        if term(n):\n            return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n    return _______                                                          =>           \r\n        if pred(n):                                                         <=           \r\n            return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    if not pred(n):                                                         <=           \r\n        return base                                                         <=           \r\n        return accumulate(combiner, base, n, term)                          <=           \r\n    else:                                                                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if term(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 239, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if pred(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def counter(n):\n        if n==1:\n            return base\n        else:\n            return combiner(term(n),counter(n-1))\n    return counter(n)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def counter(n):\n        if n==0:\n            return base\n        else:\n            return combiner(term(n),counter(n-1))\n    return counter(n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        if n == 0:            =>           \r\n    return counter(n)         =>           \r\n        if n == 1:            <=           \r\n    return counter(n)         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 240, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==1:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer", 
            "    return combiner(term(count) , indexer(count + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in indexer", 
            "    if count == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    def indexer(count):\n        if count == n:\n            return term(n)\n        else:\n            return combiner(term(count) , indexer(count + 1))\n    return combiner(base, indexer(1))\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n == 0:                        =>           \r\n        return base                   =>           \r\n    return combiner(base, indexer(1)) =>           \r\n    return base + indexer(1)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 241, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def indexer(count):\n        if count == n:\n            return term(n)\n        else:\n            return combiner(term(count) , indexer(count + 1))\n    return base + indexer(1)\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        if n==True:\n            result=combiner(result,term(k))\n        k+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n >= 1 :\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        if n==n:\n            result=combiner(result,term(k))\n        k+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        if n >= 1 :   =>           \r\n        if n == True: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==n:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 242, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==True:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,a)=(1,1)\n    while a<=n:\n        (total,a)=(combiner(total,term(a)),a+1)\n    return combiner(base,total-1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "70\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = base, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "70", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     70", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,a)=(base,1)\n    while a<=n:\n        (total,a)=(combiner(total,term(a)),a+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total, a = base, 1            =>           \r\n    return total                  =>           \r\n    total, a = 1, 1               <=           \r\n    return combiner(base,total-1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = base, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 243, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = 1, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return combiner(base, total-1)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif i==n:\n        return term(i)\n    elif combiner==mul:\n        return combiner(base,combiner(term(n),accumulate(combiner,1,n-1,term)))\n    else:\n        return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(n == 0):\n        return term(n)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    elif(i == n):", 
            "NameError: name 'i' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==n:\n        return term(base)\n    elif combiner==mul:\n        return combiner(base,combiner(term(n),accumulate(combiner,1,n-1,term)))\n    else:\n        return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif(n == 0):      =>           \r\n        return term(n) =>           \r\n    elif(i == n):      <=           \r\n        return term(i) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (base==n):\r\n        return term(base)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        0, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        0, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        1, 
                        2
                    ], 
                    [
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 244, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (i==n):\r\n        return term(i)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    count=1\n    final=base\n    while count<n+1:\n        final=combiner(base,term(count))\n        count+=1\n    return final\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    while count< n+1:\n        base=combiner(base,term(count))\n        count+=1\n    return base \n\n    \n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    count=1\n    final=base\n    while count<n+1:\n        base=final=combiner(base,term(count))\n        count+=1\n    return final\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        base=combiner(base,term(count))  =>           \r\n    return base                          =>           \r\n        final=combiner(base,term(count)) <=           \r\n    return final                         <=           \r\n    final=base                           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        base = final = combiner(base, term(count))\r\n        count += 1\r\n    return final", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "final": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }
        }, 
        "Id": 245, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        final = combiner(base, term(count))\r\n        count += 1\r\n    return final"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=n\n    if combiner==mul:\n        finalResult=1\n    elif combiner==add:\n        finalResult=0\n    while i!=0:\n        finalProduct=combiner(finalResult,term(i))\n        i-=1\n    return combiner(finalResult,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalResult = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=n\n    if combiner==mul:\n        finalResult=1\n    elif combiner==add:\n        finalResult=0\n    while i!=0:\n        finalResult=finalProduct=combiner(finalResult,term(i))\n        i-=1\n    return combiner(finalResult,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        finalResult = combiner(finalResult,term(i))  =>           \r\n        finalProduct = combiner(finalResult,term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalResult = finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "finalResult": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        9, 
                        36
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        9, 
                        13, 
                        14
                    ], 
                    [
                        0
                    ]
                ]
            }, 
            "finalProduct": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        9, 
                        36
                    ], 
                    [
                        9, 
                        4, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        9, 
                        13, 
                        14
                    ], 
                    [
                        9, 
                        4, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 246, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def count_comber(x,b):\n        if x==n+1:\n            return combiner(base,b)\n        else:\n            return combiner(term(x),count_comber(x+1,b))\n    return count_comber(1,0)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x):\n        if x == n+1:\n            return base\n        else:\n            return combiner(term(x), count_comber(x+1))\n    return count_comber(1)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def count_comber(x,b):\n        if x==n+1:\n            return b\n        else:\n            return combiner(term(x),count_comber(x+1,b))\n    return count_comber(1,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                SideIndicator\r\n-----------                                                -------------\r\n    def count_comber(x):                                   =>           \r\n            return base                                    =>           \r\n            return combiner(term(x), count_comber(x+1))    =>           \r\n    return count_comber(1)                                 =>           \r\n    def count_comber(x, b):                                <=           \r\n            return combiner(base, b)                       <=           \r\n            return combiner(term(x), count_comber(x+1, b)) <=           \r\n    return count_comber(1, 0)                              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return b\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "b": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 247, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return combiner(base, b)\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, 0)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x = combiner(x, term(y))\n        y += 1\n    return x\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        x = combiner(x, term(y))  =>           \r\n        x *= combiner(x, term(y)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 248, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x *= combiner(x, term(y))\n        y += 1\n    return x\n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            "", 
            "# Error: expected", 
            "#     225", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    25      =>           \r\n    225     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 249, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return base\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n        total = combiner(term(n), total) =>           \r\n    if n == 1:                           <=           \r\n        return 1                         <=           \r\n        total = combiner(term(n), base)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 250, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 1:\n        return 1\n    else:\n        total = combiner(term(n), base)\n        return accumulate(combiner, total, n-1, term)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def first_sequence(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(0))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def first_sequence(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return combiner(base,first_sequence(1)) =>           \r\n        return combiner(base,first_sequence(0)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 251, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(0))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n -= 1\n    return result\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 252, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n += 1\n    return result\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return n+accumulate(combiner,base,n-1,term)\n        else:\n            return n*accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0: \n        return base\n    else: \n        if combiner == add:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n        else: \n            return term(n)* accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return term(n)+accumulate(combiner,base,n-1,term)\n        else:\n            return term(n)*accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n            return term(n)+ accumulate(combiner, base, n-1, term) =>           \r\n            return term(n)* accumulate(combiner, base, n-1, term) =>           \r\n            return n+ accumulate(combiner, base, n-1, term)       <=           \r\n            return n* accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 253, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return n+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return n*accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        amount = combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        amount = combiner(amount, term(x)) =>           \r\n        combiner(amount, term(x))          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 254, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 87, in accumulate", 
            "    return combiner(base, helper(combiner, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in helper", 
            "    total += term(n)", 
            "UnboundLocalError: local variable 'total' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    if n == 0:\n        return base\n    return accumulate(combiner, combiner(term(n), base), n - 1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    if n == 0:                                                        =>           \r\n        return base                                                   =>           \r\n    return accumulate(combiner, combiner(term(n), base), n - 1, term) =>           \r\n    return k                                                          =>           \r\n    def helper(combiner, n, term):                                    <=           \r\n        current, next = term(1), term(2)                              <=           \r\n        while n > 0:                                                  <=           \r\n            total += term(n)                                          <=           \r\n            n -= 1                                                    <=           \r\n            return total                                              <=           \r\n    return combiner(base, helper(combiner, n, term))                  <=           \r\n    outcomes = []                                                     <=           \r\n        k = 1                                                         <=           \r\n        outcomes.append(k)                                            <=           \r\n    return outcomes[n + 1]                                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 255, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    def helper(combiner, n, term):\n        current, next = term(1), term(2) \n        while n > 0: \n            total += term(n)\n            n -= 1\n            return total\n    return combiner(base, helper(combiner, n, term)) \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return n+accumulate(combiner,base,n-1,term)\n        else:\n            return n*accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return term(n) + accumulate(combiner, base, n-1, term)\n        else:\n            return term(n) * accumulate(combiner, base, n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return term(n)+accumulate(combiner,base,n-1,term)\n        else:\n            return term(n)*accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return term(n) + accumulate(combiner, base, n-1, term) =>           \r\n            return term(n) * accumulate(combiner, base, n-1, term) =>           \r\n            return n + accumulate(combiner, base, n-1, term)       <=           \r\n            return n * accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 256, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return n+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return n*accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    total = start", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    k = 1                                =>           \r\n    total = base                         =>           \r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n    while k <= n:                        =>           \r\n        total = combiner(total, term(k)) =>           \r\n        k += 1                           =>           \r\n    total = start                        <=           \r\n    for i in range(n):                   <=           \r\n        total = combiner(total, f(i+1))  <=           \r\n                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 257, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = start\n    for i in range(n):\n        total = combiner(total, f(i+1))\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n - 1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner,base, n - 1, term)) =>           \r\n        return accumulate(combiner, base, n - 1, term)                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 258, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = term(1), 1\n    while x < n :\n        total = combiner(total, term(x + 1))\n        x += 1\n    if n == 0:\n        total = 0\n    return combiner(base, total)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, x = term(1), 1                    =>           \r\n    while x < n :                            =>           \r\n        total = combiner(total, term(x + 1)) =>           \r\n        x += 1                               =>           \r\n    if n == 0:                               =>           \r\n        total = 0                            =>           \r\n    return combiner(base, total)             =>           \r\n                                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 259, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "66\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "44\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 260, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        new_base=combiner(base,term(n))\n        return combiner(base,accumulate(combiner,new_base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "41\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "96\n", 
            "print accumulate(mul, 2, 3, square)": "2592\n", 
            "print accumulate(add, 11, 3, square)": "56\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "41", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     41", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))  =>           \r\n        new_base = combiner(base, term(n))                               <=           \r\n        return combiner(base, accumulate(combiner, new_base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 261, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return combiner(base, accumulate(combiner, new_base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n!=1:\n        output=accumulate(combiner,base,n-1,term)\n        return combiner(output,term(n))\n    else:\n        return combiner(base,term(1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return base \n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    output = accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    if n != 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n!=1:\n        output=accumulate(combiner,base,n-1,term)\n        return combiner(output,term(n))\n    else:\n        return combiner(base,term(1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n > 1:        =>           \r\n    elif n == 1:     =>           \r\n        return base  =>           \r\n    if n != 1:       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ]
            }
        }, 
        "Id": 262, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        result=0\n    else:\n        counter=2\n        result=term(1)\n        while counter<=n:\n            result=combiner(result,term(counter))\n            counter+=1\n    return result+base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "38\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return combiner(result, base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        result=0\n    else:\n        counter=2\n        result=term(1)\n        while counter<=n:\n            result=combiner(result,term(counter))\n            counter+=1\n    return combiner(result,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    return combiner(result, base) =>           \r\n    return result + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return combiner(result, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 263, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return result+base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(combiner,base,n,term):\n        if n==0:\n            return base\n        elif n==1:\n            return combiner(base,term(n))\n        else:\n            return helper(combiner,base,n-1,term)\n    return helper(combiner,base,n,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(combiner,base,n,term):\n        if n==0:\n            return base\n        elif n==1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),helper(combiner,base,n-1,term))\n    return helper(combiner,base,n,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    if n == 0:                                         =>           \r\n        return base                                    =>           \r\n    elif n == 1:                                       =>           \r\n        return combiner(base, term(n))                 =>           \r\n        base = combiner(base, term(n))                 =>           \r\n        return accumulate(combiner, base, n - 1, term) =>           \r\n    else:                                              =>           \r\n                                                       =>           \r\n    def helper(combiner, base, n, term):               <=           \r\n        if n == 0:                                     <=           \r\n            return base                                <=           \r\n        elif n == 1:                                   <=           \r\n            return combiner(base, term(n))             <=           \r\n        else:                                          <=           \r\n            return helper(combiner, base, n - 1, term) <=           \r\n    return helper(combiner, base, n, term)             <=           \r\n                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), helper(combiner, base, n-1, term))\r\n    return helper(combiner, base, n, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 264, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return helper(combiner, base, n-1, term)\r\n    return helper(combiner, base, n, term)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate", 
            "    accu_res = combiner(accu_res, mapped[0])", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'list'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))\n    # count = 0 \n    # accu_res = base\n    # while count < len(mapped):\n    #     accu_res = combiner(accu_res, mapped[count])\n    #     count += 1\n    # return accu_res\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))\n    count = 0 \n    accu_res = base\n    while count < len(mapped):\n    \t\taccu_res = combiner(accu_res, mapped[count])\n    \t\tcount += 1\n    return accu_res\n    \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))   =>           \r\n    # count = 0                                                       =>           \r\n    # accu_res = base                                                 =>           \r\n    # while count < len(mapped):                                      =>           \r\n    #     accu_res = combiner(accu_res, mapped[count])                =>           \r\n    #     count += 1                                                  =>           \r\n    # return accu_res                                                 =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))    =>           \r\n    count = 0                                                         =>           \r\n    while count < len(mapped):                                        =>           \r\n            accu_res = combiner(accu_res, mapped[count])              =>           \r\n            count += 1                                                =>           \r\n                                                                      =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0) <=           \r\n    i = 0                                                             <=           \r\n    while i < len(mapped):                                            <=           \r\n        accu_res = combiner(accu_res, mapped[0])                      <=           \r\n        i += 1                                                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 265, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0)\n    i = 0 \n    accu_res = base\n    while i < len(mapped):\n        accu_res = combiner(accu_res, mapped[0])\n        i += 1\n    return accu_res\n    \n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "36", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     36", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    \n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    if n == 0 and combiner == mul: <=           \r\n        base = 1                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 266, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0 and combiner == mul:\n        base = 1\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    \n\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif combiner == add:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    elif combiner == mul:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))    <=           \r\n        return combiner(term(n), accumulate(combiner, 1, n-1, term))    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 267, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif combiner == add:\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))\n    elif combiner == mul:\n        return combiner(term(n), accumulate(combiner, 1, n-1, term))\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(combiner,n,i,term):\n        if n==1:\n            return term(1)\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(combiner,n,i+1,term))\n    return combiner(base,helper(combiner,n,1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(combiner, n, i, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        elif i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(combiner, n, i + 1, term))\n    return combiner(base, helper(combiner, n, 1, term))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(i), helper(combiner, n, i + 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in helper", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def helper(combiner,n,i,term):\n        if n==1:\n            return term(1)\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(combiner,n,i+1,term))\n    return combiner(base,helper(combiner,n,1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n        elif i == n:       =>           \r\n        if i == n:         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}
        }, 
        "Id": 268, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn base\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 269, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 270, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))", 
            "TypeError: unsupported operand type(s) for +: 'function' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def le_count(combiner, i):\n        if n == i:\n            return term(n)\n        else:\n            return combiner(term(i), le_count(combiner, i + 1))\n    return combiner(base, le_count(combiner, 1))\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                                         SideIndicator\r\n-----------                                                                                                         -------------\r\n    def le_count(combiner, i):                                                                                      =>           \r\n        if n == i:                                                                                                  =>           \r\n            return term(n)                                                                                          =>           \r\n            return combiner(term(i), le_count(combiner, i + 1))                                                     =>           \r\n    return combiner(base, le_count(combiner, 1))                                                                    =>           \r\n        else:                                                                                                       =>           \r\n        return term(n)                                                                                              <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term))) <=           \r\n    elif n == 1:                                                                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 271, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return term(n)\n    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate_helper(1))\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n        return combiner(base, accumulate_helper(1)) =>           \r\n    else:                                           =>           \r\n    return combiner(base, accumulate_helper(0))     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 272, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    return combiner(base, accumulate_helper(0))\n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(0), base)\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(term(0), base) =>           \r\n    elif n == 1:                       =>           \r\n    if n == 1:                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 273, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return term(1)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==1:\n        return term(1)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(1), base) =>           \r\n        return term(1) + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 274, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 275, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(k,total=base):\n        if n==1:\n            return base+1\n        if k==n:\n            return total\n        if k>=1:\n            total=combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n+1:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(k,total=base):\n        if n==1:\n            return base+1\n        if k>n:\n            return total\n        if k>=1:\n            total=combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if k == n+1: =>           \r\n        if k == n:   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k>n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15, 
                        10, 
                        6, 
                        3, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        6, 
                        3, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        32, 
                        39, 
                        47, 
                        56, 
                        66, 
                        77, 
                        89, 
                        102, 
                        116, 
                        131, 
                        147, 
                        164, 
                        182, 
                        201, 
                        221, 
                        242, 
                        264, 
                        287, 
                        311, 
                        336, 
                        362, 
                        389, 
                        417, 
                        446, 
                        476, 
                        507, 
                        539, 
                        572, 
                        606, 
                        641, 
                        677, 
                        714, 
                        752, 
                        791, 
                        831, 
                        872, 
                        914, 
                        957, 
                        1001, 
                        1046, 
                        1092, 
                        1139, 
                        1187, 
                        1236, 
                        1286, 
                        1337, 
                        1389, 
                        1442, 
                        1496
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        21, 
                        17, 
                        14, 
                        12
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        17, 
                        14, 
                        12
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72, 
                        8, 
                        2
                    ], 
                    [
                        2, 
                        8, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25, 
                        16, 
                        12
                    ], 
                    [
                        11, 
                        12, 
                        16, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 276, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k==n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return combiner(total, base)\n\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        return combiner(total, base) =>           \r\n        return total                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 277, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return total\n\n\n\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    t = combiner(t,term(i))", 
            "UnboundLocalError: local variable 't' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        x = combiner(x,term(i))\n        i += 1\n    return x\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        x = combiner(x,term(i)) =>           \r\n    return x                    =>           \r\n                                =>           \r\n        t = combiner(t,term(i)) <=           \r\n    return t                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 278, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        t = combiner(t,term(i))\n        i += 1\n    return t\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n - 1, term))       <=           \r\n    \"*** YOUR CODE HERE ***\"                                              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 279, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n    return accumulater(combiner, base, n, term, total)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    return accumulater(combiner, base, n, term, total) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 280, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=term(base)\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n-=1\n    return total\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    return total       =>           \r\n    total = term(base) <=           \r\n    return total       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        11, 
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        121, 
                        130, 
                        134, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        4, 
                        36, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 281, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n    assert n>=0                         =>           \r\n    assert n>0                          =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 282, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    k=1\n    while n>=k:\n        total=combiner(total,term(n-1))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    k=1\n    while n>=k+1:\n        total=combiner(total,term(n-1))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>k:  =>           \r\n    while n>=k: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k+1:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        18, 
                        72
                    ], 
                    [
                        18, 
                        72, 
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 283, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 284, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            if term == identity:\n                base *= i\n            elif term == square:\n                base *= square(i)\n        elif combiner == add:\n            if term == identity:\n                base += i\n            elif term == square:\n                base += square(i)\n    return base\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            if term == identity:  =>           \r\n                base *= i         =>           \r\n            elif term == square:  =>           \r\n                base *= square(i) =>           \r\n            if term == identity:  =>           \r\n                base += i         =>           \r\n            elif term == square:  =>           \r\n                base += square(i) =>           \r\n            base *= i             <=           \r\n            base += i             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 285, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            base *= i\n        elif combiner == add:\n            base += i\n    return base\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    answer=base\n    for i in range(1,n+1):\n        answer=combiner(answer,term(n))\n    return answer\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(i))\n    return answer\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    answer=base\n    for n in range(1,n+1):\n        answer=combiner(answer,term(n))\n    return answer\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        answer = combiner(answer,term(i)) =>           \r\n        answer = combiner(answer,term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for n in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "answer": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 286, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for i in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==1:                  <=           \r\n        return term(n) + base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 287, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return accumulate(combiner, base, n-1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(n, term)", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))  =>           \r\n    return accumulate(add, 1, n, term)                                  =>           \r\n        return combiner(n, term)                                        <=           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n    return _______                                                      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 288, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(n, term)\n    else:\n        return accumulate(combiner, base, n-1, term) \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    ret=1\n    for i in range(1,n+1,1):\n        ret=combiner(ret,term(i))\n    return ret\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "15\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):###############\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)) , i+1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    ret=base\n    for i in range(1,n+1,1):\n        ret=combiner(ret,term(i))\n    return ret\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                   SideIndicator\r\n-----------                                                                   -------------\r\ndef accumulate(combiner, base, n, term):###############                       =>           \r\n    total, i = base, 1                                                        =>           \r\n    while i <= n:                                                             =>           \r\n        total, i = combiner(total, term(i)) , i+1                             =>           \r\n    return total                                                              =>           \r\ndef summation_using_accumulate(n, term):##############                        =>           \r\ndef filtered_accumulate(combiner, base, pred, n, term):###################### =>           \r\ndef accumulate(combiner, base, n, term):                                      <=           \r\n    ret = 1                                                                   <=           \r\n    for i in range(1, n + 1, 1):                                              <=           \r\n        ret = combiner(ret, term(i))                                          <=           \r\n    return ret                                                                <=           \r\ndef summation_using_accumulate(n, term):                                      <=           \r\ndef filtered_accumulate(combiner, base, pred, n, term):                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    ret = base\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "ret": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 289, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    ret = 1\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    drake = term(drake,x)", 
            "TypeError: identity() takes 1 positional argument but 2 were given", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    drake = base\n    for x in range(1,n+1):\n        drake = combiner(drake,term(x))\n    return drake\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        drake = combiner(drake,term(x)) =>           \r\n        drake = term(drake,x)           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 290, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    drake = base\n    for x in range(1,n+1):\n        drake = term(drake,x)\n    return drake\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term)) =>           \r\n        return combiner(n, accumulate(combiner, base, (n-1), term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 291, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, (n-1), term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    while n>=1:\n        num=combiner(base,term(n))\n        n-=1\n    return num\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    while n>=1:\n        base=combiner(base,term(n))\n        n-=1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(n)) =>           \r\n    return base                        =>           \r\n        num = combiner(base, term(n))  <=           \r\n    return num                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        base = combiner(base, term(n))\r\n        n -= 1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 292, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        num = combiner(base, term(n))\r\n        n -= 1\r\n    return num"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            total = total + term(c)\n            c = c + 1\n        total = total + base\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n            total = total + term(c) =>           \r\n        total = total + base        =>           \r\n            combiner(total,term(c)) <=           \r\n        combiner(total,base)        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 293, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            combiner(total,term(c))\n            c = c + 1\n        combiner(total,base)\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    total, k = 1", 
            "TypeError: 'int' object is not iterable", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 1       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 294, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=combiner(base,term(n))\n    if n==0:\n        return result\n    else:\n        return combiner(result,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "81\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "58\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    \n    if n==0:\n    \treturn base\n\n    else:\n    \treturn combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "81", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     81", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=combiner(base,term(n))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n                                                                    =>           \r\n        return base                                                 =>           \r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    result = combiner(base,term(n))                                 <=           \r\n        return result                                               <=           \r\n        return combiner(result,accumulate(combiner,base,n-1,term))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 295, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return result\r\n    else:\r\n        return combiner(result, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count),accumulateHelp(count+1))\n    return accumulateHelp(0)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count),accumulateHelp(count+1))\n    return accumulateHelp(1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n==0:                                                           =>           \r\n        return base                                                    =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                              =>           \r\n    def accumulateHelp(count):                                         <=           \r\n        if count==n+1:                                                 <=           \r\n            return base                                                <=           \r\n        return combiner(term(count), accumulateHelp(count+1))          <=           \r\n    return accumulateHelp(0)                                           <=           \r\n                                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "count": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 296, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(0)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if n == 0:\n            return 0\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 1, term), base)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        if n == 0:                                          =>           \r\n            return 0                                        =>           \r\n    return combiner(term_combiner(combiner, 1, term), base) =>           \r\n    return combiner(term_combiner(combiner, 0, term), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 297, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 0, term), base)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n<2:  =>           \r\n    if n==0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 298, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulator(x,total):\n        if x>n:\n            return total\n        else:\n            return accumulator(x+1,combiner(total,term(x)))\n    return accumulator(2,combiner(base,term(1)))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulator(x,total):\n        if x>n:\n            return total\n        else:\n            return accumulator(x+1,combiner(total,term(x)))\n    if n==0:\n        return base\n    return accumulator(2,combiner(base,term(1)))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n    else:                                                                 =>           \r\n                                                                          =>           \r\n    def accumulator(x, total):                                            <=           \r\n        if x > n:                                                         <=           \r\n            return total                                                  <=           \r\n        else:                                                             <=           \r\n            return accumulator(x + 1, combiner(total, term(x)))           <=           \r\n    return accumulator(2, combiner(base, term(1)))                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    if n==0:\r\n        return base\r\n    return accumulator(2, combiner(base, term(1)))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "total": {}
        }, 
        "Id": 299, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    return accumulator(2, combiner(base, term(1)))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    initial=0\n    if base>n:\n        initial=0\n        total=base\n    else:\n        total=term(base)\n    for i in range(initial,n):\n        total=combiner(total,term(i+1))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = base\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "144", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     144", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    initial=0\n    if base>n:\n        initial=0\n        total=base\n    else:\n        total=base\n    for i in range(initial,n):\n        total=combiner(total,term(i+1))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        total = base       =>           \r\n        total = term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = base\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 300, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = term(base)\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if n==0:\n        return base\n    while k<n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if n==0:\n        return base\n    while k<n+1:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n+1:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 301, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    if combiner == add:\n        return base + helper(1)\n    else:\n        return base * helper(1) \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    if combiner == add:          =>           \r\n        return base + helper(1)  =>           \r\n        return base * helper(1)  =>           \r\n    else:                        =>           \r\n    return base * helper(1)      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 302, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    return base * helper(1) \n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total,  term(i))\n        i += 1\n    return total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    i = 1                                    =>           \r\n    while i <= n:                            =>           \r\n        total = combiner(total,  term(i))    =>           \r\n        i += 1                               =>           \r\n    while base <= n:                         <=           \r\n        total = combiner(total,  term(base)) <=           \r\n        base += 1                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 303, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while base <= n:\n        total = combiner(total,  term(base))\n        base += 1\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    elif n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(accumulate(combiner,base,n-1,term),term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n==1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n==0:      =>           \r\n                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ]
            }
        }, 
        "Id": 304, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n)), accumulate(combiner, base, n-1, term)", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(term(n)), accumulate(combiner, base, n-1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 305, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n)), accumulate(combiner, base, n-1, term)\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=start\n    for i in range(1,n+1,1):\n        total=combiner(total,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    total = start", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1,1):\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    total = base  =>           \r\n    total = start <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 306, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = start\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 1:                                                           =>           \r\n        return product(n-1, term) * term(n)                              =>           \r\n    return product(n, identity)                                          =>           \r\n        return base                                                      =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    return accumulate(mul, 1, n, term)                                   =>           \r\n    return accumulate(combiner, base, n, term)                           =>           \r\n    def z(x):                                                            =>           \r\n        return compose1(f,f)(x)                                          =>           \r\n    if n == 0:                                                           =>           \r\n        return z(n)                                                      =>           \r\n    return z(n-1) + z(n)                                                 =>           \r\n    else:                                                                =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n    return _______                                                       <=           \r\n        return combiner(accumulate(combiner, base, n-1, term))           <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 307, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term))\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "3", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     3", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    y=base\n    while i<=n:\n        y = combiner(y, term(i))\n        i+=1\n    return y\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    i=1                             =>           \r\n    y=base                          =>           \r\n    while i<=n:                     =>           \r\n        y = combiner(y, term(i))    =>           \r\n        i+=1                        =>           \r\n    return y                        =>           \r\n    while base>=0 and n>=0:         <=           \r\n        x = combiner(base, term(n)) <=           \r\n        base = term(n-1)            <=           \r\n        n-=2                        <=           \r\n    return x                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 308, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while base>=0 and n>=0:\n        x = combiner(base, term(n))\n        base = term(n-1)\n        n-=2\n    return x\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(combiner,n,term):\n        if n==1:\n            return term(1)\n        return combiner(term(n),helper(combiner,n-1,term))\n    return combiner(base,helper(combiner,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper", 
            "    return combiner(term(n), helper(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in helper", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(combiner,n,term):\n        if n==1:\n            return term(1)\n        return combiner(term(n),helper(combiner,n-1,term))\n    if n==0:\n        return base\n    return combiner(base,helper(combiner,n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, helper(combiner, n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 309, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    return combiner(base, helper(combiner, n, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 310, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combine(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n    \n\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combine(accumulate(combiner, base, n-1, term), term(n))", 
            "NameError: name 'combine' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 311, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combine(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=combiner\n    for i in range(1,n+1):\n        result=combiner(result,term(i))\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "<built-in function add>\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    result=combiner(result, term(i))", 
            "TypeError: unsupported operand type(s) for +: 'builtin_function_or_method' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=base\n    for i in range(1,n+1):\n        result=combiner(result,term(i))\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result=base     =>           \r\n    result=combiner <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 312, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,n)\n        n=n-1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,term(n))\n        n = n-1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,term(n))\n        n=n-1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        total = combiner(total,term(n)) =>           \r\n        total = combiner(total,n)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11, 
                        14, 
                        16, 
                        17
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2, 
                        6, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 313, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, n)\r\n        n = n-1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=base\n    if n>0:\n        for x in range(1,n+1):\n            result+=combiner(result,term(x))\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "57\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "409\n", 
            "print accumulate(mul, 2, 3, square)": "200\n", 
            "print accumulate(add, 11, 3, square)": "109\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result = combiner(result, term(x))\n    return result\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "57", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     57", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=base\n    if n>0:\n        for x in range(1,n+1):\n            result=combiner(result,term(x))\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            result = combiner(result, term(x))  =>           \r\n            result += combiner(result, term(x)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result = combiner(result, term(x))\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        11, 
                        26, 
                        57
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        20, 
                        200
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        23, 
                        48, 
                        99, 
                        202, 
                        409
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        23, 
                        50, 
                        109
                    ]
                ]
            }
        }, 
        "Id": 314, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result += combiner(result, term(x))\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def take_term(i,function):\n        if i==0:\n            return 0\n        elif i==n:\n            return function(i)\n        else:\n            return combiner(function(i),take_term(i+1,function))\n    return combiner(base,take_term(1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    if(n == 0):\n        return base\n    else:\n        return combiner(base, take_term(1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term", 
            "    return combiner(function(i), take_term(i + 1, function))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in take_term", 
            "    if(i == 0):", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def take_term(i,function):\n        if n==0:\n            return 0\n        elif i==n:\n            return function(i)\n        else:\n            return combiner(function(i),take_term(i+1,function))\n    return combiner(base,take_term(1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        if(i == n):                               =>           \r\n    if(n == 0):                                   =>           \r\n        return base                               =>           \r\n        return combiner(base, take_term(1, term)) =>           \r\n    else:                                         =>           \r\n        if(i == 0):                               <=           \r\n            return 0                              <=           \r\n        elif(i == n):                             <=           \r\n    return combiner(base, take_term(1, term))     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (n==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70
                    ]
                ]
            }, 
            "x": {}
        }, 
        "Id": 315, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (i==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    if n == 0:\n        return base\n    else:\n        while n >= 1:\n            total = combiner(total, term(n))\n            n -= 1\n\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return base                          =>           \r\n        while n >= 1:                        =>           \r\n            total = combiner(total, term(n)) =>           \r\n    if n == 0:                               =>           \r\n            n -= 1                           =>           \r\n    else:                                    =>           \r\n    while n >= 0:                            <=           \r\n        total = combiner(total, term(n))     <=           \r\n        n -= 1                               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        72, 
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ]
            }
        }, 
        "Id": 316, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    result=base\n    while i<=n:\n        if i==1:\n            result=combiner(result,term(i))\n            i+=1\n        else:\n            result=combiner(term(result),term(i))\n            i+=1\n    return result\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "2304\n", 
            "print accumulate(add, 11, 3, square)": "21913\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    result = base\n    while i <= n:\n        if i == 1:\n            result = combiner(result, term(i))\n            i += 1\n        else:\n            result = combiner(result, combiner(term(i), term(i + 1)))\n            i += 2\n    return result\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "21913", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     21913", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    result=base\n    while i<=n:\n        if i>=1:\n            result=combiner(result,term(i))\n            i+=1\n        else:\n            result=combiner(term(result),term(i))\n            i+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n            result = combiner(result, combiner(term(i), term(i + 1))) =>           \r\n            i += 2                                                    =>           \r\n            result = combiner(term(result), term(i))                  <=           \r\n            i += 1                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i>=1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        6, 
                        4, 
                        10, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        16, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        12, 
                        2, 
                        14, 
                        3, 
                        17, 
                        4, 
                        21, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        12, 
                        2, 
                        148, 
                        3
                    ]
                ]
            }, 
            "result": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        148, 
                        21913
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        16, 
                        2304
                    ]
                ]
            }
        }, 
        "Id": 317, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i==1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n        return total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "None\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n            total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return total         =>           \r\n            return total <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 318, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n        return total\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def terms(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),terms(n-1))\n    return combiner(base,terms(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return 0\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms", 
            "    return combiner(term(n), terms(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in terms", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def terms(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),terms(n-1))\n    return combiner(base,terms(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        elif n == 0: =>           \r\n            return 0 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 319, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == base:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    for i in range (1, n + 1):\n        k = combiner(k, term(i))\n    return k\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    k = base                                                        =>           \r\n    for i in range (1, n + 1):                                      =>           \r\n        k = combiner(k, term(i))                                    =>           \r\n    return k                                                        =>           \r\n    if n == base:                                                   <=           \r\n        return term(base)                                           <=           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 320, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == base:\n        return term(base)\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (acc,i)=(base,0)\n    while i<=n:\n        (acc,i)=(combiner(acc,term(i)),i+1)\n    return acc\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 1\n    while i <= n:\n        acc, i = combiner(acc, term(i)), i + 1\n    return acc\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (acc,i)=(base,1)\n    while i<=n:\n        (acc,i)=(combiner(acc,term(i)),i+1)\n    return acc\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    acc, i = base, 1                           =>           \r\n        acc, i = combiner(acc, term(i)), i + 1 =>           \r\n    acc, i = base, 0                           <=           \r\n        acc, i = combiner(acc,term(i)), i + 1  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 1\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "acc": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }, 
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 321, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 0\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum(term(n), accumulate(combiner,base,(n-1),term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum(term(n), accumulate(combiner,base,(n-1),term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum(term(n), accumulate(combiner,base,(n-1),term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum(term(n), accumulate(combiner,base,(n-1),term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum(term(n), accumulate(combiner,base,(n-1),term))", 
            "TypeError: 'int' object is not iterable", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,(n-1),term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner,base,(n-1),term)) =>           \r\n        sum(term(n), accumulate(combiner,base,(n-1),term))             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 322, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        sum(term(n), accumulate(combiner,base,(n-1),term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term,k=1):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term,term(n)))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"any\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner( accumulate(combiner, base, n-1, term, term(n)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner( accumulate(combiner, base, n-1, term, term(n)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner( accumulate(combiner, base, n-1, term, term(n)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner( accumulate(combiner, base, n-1, term, term(n)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner( accumulate(combiner, base, n-1, term, term(n)))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term,k=1):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term,term(n)),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combiner( accumulate(combiner, base, n-1, term, term(n))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 323, 
        "before": "\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, (combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                                 SideIndicator\r\n-----------                                                                                                 -------------\r\n        return combiner(base, (combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term)))) =>           \r\n    return accumulate(combiner, base, n, lambda x: term(x) if pred(n) else 0 if combiner == add else 1)     =>           \r\n        return combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))                   <=           \r\n    return accumulate(combiner, base, n, lambda x: term if pred(n) else 0 if combiner == add else 1)        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 324, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(n):\n        total=combiner(total,term(increment(i)))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(n):\n        total=combiner(total,term(increment(i)))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 325, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    if n == 1:                                                       =>           \r\n        return combiner(base, term(n))                               =>           \r\n    elif n == 0:                                                     =>           \r\n        return base                                                  =>           \r\n        return combiner(term(n), accumulate(combiner,base,n-1,term)) =>           \r\n    def helper(x):                                                   =>           \r\n        return compose1(f,f)                                         =>           \r\n    return helper(x)                                                 =>           \r\n    else:                                                            =>           \r\n    if n == 0:                                                       <=           \r\n        return term(base)                                            <=           \r\n    return combiner(term(n), accumulate(combiner,base,n-1,term))     <=           \r\n                                                                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 326, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0):\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if (n == 0):           =>           \r\n    if (n == 0 or n == 1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or base==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 327, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or n==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 328, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, base\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(0)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 329, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=0\n    Total=base\n    while x<=n:\n        Total=combiner(Total,term(x))\n        x+=1\n    return Total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x < n:\n        x += 1\n        Total = combiner(Total, term(x))\n    return Total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=1\n    Total=base\n    while x<=n:\n        Total=combiner(Total,term(x))\n        x+=1\n    return Total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "Total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 330, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 0\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulate_helper(combiner,i,n_result):\n        if i==n:\n            return combiner(n_result,term(i))\n        else:\n            return accumulate_helper(combiner,i+1,combiner(n_result,term(i)))\n    return accumulate_helper(combiner,1,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if n == 0:\n            return base\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper", 
            "    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_helper", 
            "    if i == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accumulate_helper(combiner,i,n_result):\n        if i==n:\n            return combiner(n_result,term(i))\n        else:\n            return accumulate_helper(combiner,i+1,combiner(n_result,term(i)))\n    return accumulate_helper(combiner,1,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}, 
            "n_result": {}
        }, 
        "Id": 331, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    if n==0:\n        return base\n    while i<=n:\n        total=combiner(total,i)\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n        \n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    if n==0:\n        return base\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 332, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, i)\r\n        i += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    first_number=base\n    i=0\n    while i<=n:\n        i=i+1\n        first_number=combiner(term(i),first_number)\n    return first_number\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "21\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "32\n", 
            "print accumulate(mul, 2, 3, square)": "1152\n", 
            "print accumulate(add, 11, 3, square)": "41\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    first_number = base\n    i = 0\n    while  i < n:\n        i = i+ 1\n        first_number = combiner(term(i),first_number)\n    return first_number\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "21", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     21", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    first_number=base\n    i=0\n    while i+1<=n:\n        i=i+1\n        first_number=combiner(term(i),first_number)\n    return first_number\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while  i < n:  =>           \r\n    while  i <= n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i+1<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "first_number": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        32
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        72, 
                        1152
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16, 
                        25, 
                        41
                    ]
                ]
            }
        }, 
        "Id": 333, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=base\n    x=1\n    while i<=n:\n        result=combiner(result,term(i))\n        i+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    i = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    while i<=n:", 
            "UnboundLocalError: local variable 'i' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=base\n    i=1\n    while i<=n:\n        result=combiner(result,term(i))\n        i+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    x = 1   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    i = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 334, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    x = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    \n    \n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))    =>           \r\n                                                                       =>           \r\n    '''if n==0:                                                        <=           \r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))''' <=           \r\n        return base                                                    <=           \r\n    total, next_term = base, 1                                         <=           \r\n    while n>0:                                                         <=           \r\n        total = total + term(next_term)                                <=           \r\n        next_term +=1                                                  <=           \r\n        n-=1                                                           <=           \r\n    return total                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 335, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    '''if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))'''\n\n    if n==0:\n        return base\n    total, next_term = base, 1\n    while n>0:\n        total = total + term(next_term)\n        next_term +=1\n        n-=1\n    return total \n    \n    \n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n        return base                                                                         =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))                         =>           \r\n    def cmb(x, y):                                                                          =>           \r\n        if pred(y):                                                                         =>           \r\n            return combiner(x,y)                                                            =>           \r\n        else:                                                                               =>           \r\n            return x                                                                        =>           \r\n    return accumulate(cmb, base, n, term)                                                   =>           \r\n                                                                                            =>           \r\n        return term(n)                                                                      <=           \r\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))                     <=           \r\n    return accumulate(lambda x,y: combiner(x,y) if pred(y) == True else x, base, n, term)   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 336, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "RecursionError: maximum recursion depth exceeded", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94
                    ]
                ]
            }
        }, 
        "Id": 337, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(i,total):\n        if i>n:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total)\n    return helper(1,term(base))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(i,total):\n        if i>n:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total)\n    return helper(1,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return helper(1, base)       =>           \r\n    return helper(1, term(base)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25, 
                        16, 
                        12
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135, 
                        126, 
                        122
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72, 
                        8, 
                        2
                    ], 
                    [
                        4, 
                        16, 
                        144, 
                        16, 
                        4
                    ]
                ]
            }
        }, 
        "Id": 338, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, term(base))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(0,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    for i in range(1, n+1):                    =>           \r\n    return accumulate(add, base, n, term)      =>           \r\n    return accumulate(mul,1, n, term)          =>           \r\n    for i in range(0, n+1):                    <=           \r\n        #return accumulate(add, base, n, term) <=           \r\n        #return accumulate(mul,1, n, term)     <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 339, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(0, n+1):\r\n        total = combiner(total, term(i))\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n < 1:       =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 340, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(base, helper())\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return combiner(base, helper())       =>           \r\n    return combiner(term(base), helper()) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 341, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(term(base), helper())\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner (accumulate(combiner, base, n-1, term),term(n))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return combiner (accumulate(combiner, base, n-1, term),term(n)) =>           \r\n    if base < n:                                                        <=           \r\n        return term(base) + accumulate(combiner, base+1, n, term)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 342, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base < n:\n        return term(base) + accumulate(combiner, base+1, n, term)\n    else:\n        return base\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 343, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 344, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n                                                                    =>           \r\n        return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n                                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 345, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return accumulate(combiner, combiner(base, term(n), n-1, term))", 
            "TypeError: op_add expected 2 arguments, got 4", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)  =>           \r\n        return accumulate(combiner, combiner(base, term(n), n-1, term))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 346, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n), n-1, term)) \n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base, combiner(term(n), helper(n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper", 
            "    return combiner(n, helper(n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper", 
            "    return combiner(n, helper(n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper", 
            "    return combiner(n, helper(n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper", 
            "    return combiner(n, helper(n - 1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    def helper(n, term):                                                  <=           \r\n        if n > 0:                                                         <=           \r\n            return combiner(n, helper(n - 1, term))                       <=           \r\n        return combiner(base, combiner(term(n), helper(n - 1, term)))     <=           \r\n                                                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 347, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n > 0:\n            return combiner(n, helper(n - 1, term))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), helper(n - 1, term)))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        base = combiner(term(n),base)       =>           \r\n        base = base + combiner(term(n),n-1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 348, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = base + combiner(term(n),n-1)\n        return accumulate(combiner,base,n-1,term)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 349, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 0:      =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 350, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return acc_help(combiner, base, 1, term, 1)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in acc_help", 
            "    return acc_help(combiner, total, k, term)", 
            "TypeError: acc_help() missing 1 required positional argument: 'y'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term, y)\n    return acc_help(combiner, base, 1, term, 1)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return acc_help(combiner, total, k, term, y) =>           \r\n        return acc_help(combiner, total, k, term)    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 351, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term)\n    return acc_help(combiner, base, 1, term, 1)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0+base\n    elif n==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0+base\n    elif base==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 352, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif n==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (i,total)=(0,base)\n    if n==0:\n        return total\n    while n>0:\n        total=combiner(term(n),total)\n        i+=1\n        n-=1\n    return combiner(base,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "37\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "36\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return total \n        \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "37", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     37", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (i,total)=(0,base)\n    if n==0:\n        return total\n    while n>0:\n        total=combiner(term(n),total)\n        i+=1\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return total                 =>           \r\n    return combiner(base, total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 353, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return combiner(base, total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulation_counter(combiner,counter,n,f):\n        if counter==n:\n            return f(n)\n        else:\n            return combiner(f(counter),accumulation_counter(combiner,counter+1,n,f))\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulation_counter(combiner,0,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 1, n, term))\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulation_counter(combiner,counter,n,f):\n        if counter==n:\n            return f(n)\n        else:\n            return combiner(f(counter),accumulation_counter(combiner,counter+1,n,f))\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulation_counter(combiner,1,n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term)) =>           \r\n        return combiner(base, accumulation_counter(combiner, 0, n, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 354, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 0, n, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==0: =>           \r\n    if n==1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 355, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "4", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     4", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return n                                                    <=           \r\n    return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 356, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return n\n    return combiner(base, term(n-1))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 :\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n-1, term))\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n == 0 :                                                        =>           \r\n        return base                                                    =>           \r\n    else:                                                              =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1, term)) =>           \r\n    number = 0                                                         <=           \r\n    while number < n:                                                  <=           \r\n        total = combiner(base, term(number))                           <=           \r\n        number + 1                                                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 357, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    number = 0 \n    while number < n:\n        total = combiner(base, term(number)) \n        number + 1\n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=1\n    total=base\n    if n==0:\n        return combiner(base,term(0))\n    while x!=n+1:\n        total=combiner(total,term(x))\n        x=x+1\n    return combiner\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "<built-in function add>\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "<built-in function add>\n", 
            "print accumulate(mul, 2, 3, square)": "<built-in function mul>\n", 
            "print accumulate(add, 11, 3, square)": "<built-in function add>\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return total\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "<built-in function add>", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     <built-in function add>", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=1\n    total=base\n    if n==0:\n        return combiner(base,term(0))\n    while x!=n+1:\n        base=combiner(base,term(x))\n        x=x+1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total    =>           \r\n    return combiner <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        base = combiner(base, term(x))\r\n        x = x+1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        8, 
                        72
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 358, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return combiner"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(n):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),helper(n-1))\n    return combiner(base,helper(n))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n):\n        if n <= 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper(n-1))\n    return combiner(base, helper(n))\n\t\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper", 
            "    return combiner(term(n), helper(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in helper", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(n):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),helper(n-1))\n    return combiner(base,helper(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 359, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(base, n - 1, term))", 
            "TypeError: accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n - 1, term))           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 360, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,i)=(base,1)\n    while i<=n:\n        total+=term(i)\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,i)=(base,1)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total += term(i)                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        3, 
                        7, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 361, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total += term(i)\r\n        i += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner,base,n-2,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==0:\n        return combiner(base, term(0))\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner,base,n-2,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n ==0:                          =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -2, 
                        -4, 
                        -6, 
                        -8, 
                        -10, 
                        -12, 
                        -14, 
                        -16, 
                        -18, 
                        -20, 
                        -22, 
                        -24, 
                        -26, 
                        -28, 
                        -30, 
                        -32, 
                        -34, 
                        -36, 
                        -38, 
                        -40, 
                        -42, 
                        -44, 
                        -46, 
                        -48, 
                        -50, 
                        -52, 
                        -54, 
                        -56, 
                        -58, 
                        -60, 
                        -62, 
                        -64, 
                        -66, 
                        -68, 
                        -70, 
                        -72, 
                        -74, 
                        -76, 
                        -78, 
                        -80, 
                        -82, 
                        -84, 
                        -86, 
                        -88, 
                        -90, 
                        -92, 
                        -94, 
                        -96, 
                        -98, 
                        -100, 
                        -102, 
                        -104, 
                        -106, 
                        -108
                    ]
                ]
            }
        }, 
        "Id": 362, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        result=combine(result,term(k))\n        k+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combiner(result,term(k))\n        k += 1\n    return result\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    result = combine(result,term(k))", 
            "NameError: name 'combine' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        result=combiner(result,term(k))\n        k+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        result = combiner(result,term(k)) =>           \r\n        result = combine(result,term(k))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 363, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combine(result, term(k))\r\n        k += 1\r\n    return result"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term) + term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term) + term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term) + term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term) + term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(accumulate(combiner, base, n-1, term) + term(n))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n        return combiner(accumulate(combiner, base, n-1, term) + term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 364, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term) + term(n))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i +=1\n    return combiner(total, base)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    i = 1                                   =>           \r\n    while i <= n:                           =>           \r\n        total = combiner(total, term(i))    =>           \r\n        i +=1                               =>           \r\n    return combiner(total, base)            =>           \r\n    while base <= n:                        <=           \r\n        total = combiner(total, term(base)) <=           \r\n        base +=1                            <=           \r\n    return total                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 365, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    while base <= n:\n        total = combiner(total, term(base))\n        base +=1\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if term(n)==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate", 
            "    if term(n) == base:", 
            "RecursionError: maximum recursion depth exceeded", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if term(n)==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n    if term(n) == base:                                                 <=           \r\n    else:                                                               <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51
                    ]
                ]
            }
        }, 
        "Id": 366, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(base), accumulate(combiner,base+1, n,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if base == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner,base, n-1,term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 0:                                                           =>           \r\n        return base                                                      =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1,term))    =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    if base == n:                                                        <=           \r\n        return term(base)                                                <=           \r\n        return combiner(term(base), accumulate(combiner,base+1, n,term)) <=           \r\n    return _______                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 367, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if base == n:\n        return term(base)\n    else: \n        return combiner(term(base), accumulate(combiner,base+1, n,term))\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate", 
            "    return partial_product(1,base)", 
            "NameError: name 'partial_product' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_accum(1,base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    return partial_accum(1,base)   =>           \r\n    return partial_product(1,base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 368, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_product(1,base)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    count=1\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    if n==0:\n        return total\n    return total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n == 0:\n        return base\n    base = combiner(term(n), base)\n\n    return accumulate(combiner,base,n-1,term)\"\"\"\n    count = 1\n\n    while n > 0:\n        base = combiner(term(n), base)\n        n -= 1\n    if n == 0:\n        return base\n    \n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=0\n    count=1\n    while n>0:\n        base=combiner(term(n),base)\n        n-=1\n    if n==0:\n        return base\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        return base                     =>           \r\n                                        =>           \r\n        total = combiner(term(n), base) <=           \r\n        return total                    <=           \r\n    return total                        <=           \r\n    total = 0                           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return base\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        18, 
                        8, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        16, 
                        15, 
                        14, 
                        13, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        20, 
                        15, 
                        12
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 369, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        total = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return total\r\n    return total\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "4", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     4", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 370, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(base, term(n-1))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    while n>0:\n        base=combiner(term(n),base)\n        n-=1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    total=base                        =>           \r\n        total=combiner(term(n),total) =>           \r\n        total=combiner(term(n),base)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 371, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        total = combiner(term(n), base)\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    total = base\n    while a <= n:\n        total = combiner(total, term(a))\n        a += 1\n    return total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    a = 1                                =>           \r\n    total = base                         =>           \r\n    while a <= n:                        =>           \r\n        total = combiner(total, term(a)) =>           \r\n        a += 1                           =>           \r\n    return total                         =>           \r\n    def summation(term, n):              <=           \r\n        a, total = n, 0                  <=           \r\n        while a > 0:                     <=           \r\n            total += term(a)             <=           \r\n            a -= 1                       <=           \r\n        return total                     <=           \r\n    return combiner(base, term(n))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 372, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(term, n):\n        a, total = n, 0\n        while a > 0:\n            total += term(a)\n            a -= 1\n        return total\n    return combiner(base, term(n))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while n<=k:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while n<=k: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97, 
                        98
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        32, 
                        39, 
                        47, 
                        56, 
                        66, 
                        77, 
                        89, 
                        102, 
                        116, 
                        131, 
                        147, 
                        164, 
                        182, 
                        201, 
                        221, 
                        242, 
                        264, 
                        287, 
                        311, 
                        336, 
                        362, 
                        389, 
                        417, 
                        446, 
                        476, 
                        507, 
                        539, 
                        572, 
                        606, 
                        641, 
                        677, 
                        714, 
                        752, 
                        791, 
                        831, 
                        872, 
                        914, 
                        957, 
                        1001, 
                        1046, 
                        1092, 
                        1139, 
                        1187, 
                        1236, 
                        1286, 
                        1337, 
                        1389, 
                        1442, 
                        1496, 
                        1551, 
                        1607, 
                        1664, 
                        1722, 
                        1781, 
                        1841, 
                        1902, 
                        1964, 
                        2027, 
                        2091, 
                        2156, 
                        2222, 
                        2289, 
                        2357, 
                        2426, 
                        2496, 
                        2567, 
                        2639, 
                        2712, 
                        2786, 
                        2861, 
                        2937, 
                        3014, 
                        3092, 
                        3171, 
                        3251, 
                        3332, 
                        3414, 
                        3497, 
                        3581, 
                        3666, 
                        3752, 
                        3839, 
                        3927, 
                        4016, 
                        4106, 
                        4197, 
                        4289, 
                        4382, 
                        4476, 
                        4571, 
                        4667, 
                        4764
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 373, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while n<=k:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 374, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))\n    return accumulate_fuzzies(combiner, base, n, term)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                            SideIndicator\r\n-----------                                                                            -------------\r\n    def accumulate_fuzzies(combiner, base, n, term):                                   =>           \r\n        if n == 0:                                                                     =>           \r\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))    =>           \r\n    return accumulate_fuzzies(combiner, base, n, term)                                 =>           \r\n    def accumulate_fuzzies(combiner, base, n, term, k):                                <=           \r\n        if k == n:                                                                     <=           \r\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1)) <=           \r\n    return accumulate_fuzzies(combiner, base, n, term, n)                              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 375, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term, k):\n        if k == n:\n            return base\n        else:\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1))\n    return accumulate_fuzzies(combiner, base, n, term, n)\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        accumulate(combiner, base, n-1, term)                           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 376, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        accumulate(combiner, base, n-1, term)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    if combiner==add:\n        total=0\n    elif combiner==mul:\n        total=1\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return base+total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "38\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(base, total)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    if combiner==add:\n        total=0\n    elif combiner==mul:\n        total=1\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return combiner(base,total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return combiner(base, total) =>           \r\n    return base + total          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(base, total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 377, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return base+total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total, k = base, 1                             =>           \r\n    while k <= n:                                  =>           \r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n    return total                                   =>           \r\n    result, k = base, 1                            <=           \r\n    while k<=n:                                    <=           \r\n        k+=1                                       <=           \r\n        result = combiner(term(k), result)         <=           \r\n    return result                                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 378, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, k = base, 1\n    while k<=n:\n        k+=1\n        result = combiner(term(k), result)\n    return result\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=1\n    counter=1\n    base=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "15\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    base=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n    base = 1     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 379, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        k=term(counter)\n        total=combiner(base,k)\n        counter=counter+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (total, k)\n        counter = counter + 1\n    return total \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        k=term(counter)\n        total=combiner(total,k)\n        counter=counter+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = combiner (total, k) =>           \r\n        total = combiner (base, k)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(total, k)\r\n        counter = counter+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }
        }, 
        "Id": 380, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(base, k)\r\n        counter = counter+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(1), accumulate(combiner, base, (n + 1), term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    i = 1                                                                   =>           \r\n    total = base                                                            =>           \r\n    while i <= n:                                                           =>           \r\n        total = combiner(total, term(i))                                    =>           \r\n        i += 1                                                              =>           \r\n    return total                                                            =>           \r\n    if n == 0:                                                              <=           \r\n        return base                                                         <=           \r\n    elif n == 1:                                                            <=           \r\n        return combiner(base, term(n))                                      <=           \r\n    else:                                                                   <=           \r\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 381, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(k,total):\n        if n<=k:\n            return combiner(term(k),total)\n        else:\n            total=combiner(term(k),total)\n        return helper(k+1,total)\n    return helper(1,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n == 0:\n            return total\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(k,total):\n        if n<=k:\n            return combiner(term(n),total)\n        else:\n            total=combiner(term(k),total)\n        return helper(k+1,total)\n    return helper(1,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        if n == 0:       =>           \r\n            return total =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(n), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 382, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(k), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "2", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     2", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = base\n        while i <= n:\n            total = combiner(total, term(i))\n            i = i+1\n        return total\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        total = base                         =>           \r\n            total = combiner(total, term(i)) =>           \r\n        return total                         =>           \r\n        total = term(0)                      <=           \r\n            total = combiner(term(i), total) <=           \r\n        return base + total                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 383, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = term(0)\n        while i <= n:\n            total = combiner(term(i), total)\n            i = i+1\n        return base + total\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        ans=combiner(base,term(1))\n        i=2\n        while i<=n:\n            ans=combiner(ans,term(i))\n            i+=1\n        return ans\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n==0:                          =>           \r\n        return base                   =>           \r\n        ans=combiner(base,term(1))    =>           \r\n        i=2                           =>           \r\n        while i<=n:                   =>           \r\n            ans=combiner(ans,term(i)) =>           \r\n            i+=1                      =>           \r\n        return ans                    =>           \r\n    else:                             =>           \r\n    ans=combiner(base,term(1))        <=           \r\n    i=2                               <=           \r\n    while i<=n:                       <=           \r\n        ans=combiner(ans,term(i))     <=           \r\n        i+=1                          <=           \r\n    return ans                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}, 
            "ans": {}
        }, 
        "Id": 384, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n < 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n, term))   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 385, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return accumulate(combiner(base, term(n + 1)), n, term) + base", 
            "TypeError: accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    elif n == 1:                                                          =>           \r\n        return combiner(base, term(1))                                    =>           \r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term))) =>           \r\n    else:                                                                 =>           \r\n    else:                                                                 <=           \r\n        return accumulate(combiner(base, term(n + 1)), n, term) + base    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 386, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return accumulate(combiner(base, term(n + 1)), n, term) + base\n    \n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        a=combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        a=combiner(a,term(i+1)) =>           \r\n        combiner(a,term(i+1))   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 387, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    term_total=term(i)\n    i=2\n    if n==0:\n        term_total=0\n    while i<=n:\n        term_total=combiner(term_total,term(i))\n        i=i+1\n    return combiner(base,term_total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(1)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    term_total = term(i)", 
            "UnboundLocalError: local variable 'i' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    term_total=term(1)\n    i=2\n    if n==0:\n        term_total=0\n    while i<=n:\n        term_total=combiner(term_total,term(i))\n        i=i+1\n    return combiner(base,term_total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    term_total = term(1) =>           \r\n    term_total = term(i) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(1)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 388, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(i)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "44", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     44", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return combiner(term(n), base)\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), base)                                  =>           \r\n    elif n == 1:                                                        =>           \r\n        return combiner(term(n), base)                                  =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n        return n                                                        <=           \r\n    return combiner((term(n-1)), term(n)) * n-1                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 389, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return n\n    return combiner((term(n-1)), term(n)) * n-1\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    x=1\n    while x<=n:\n        total=combiner(total,term(x))\n        x=x+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total,term(x))\n        x = x + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    total = combiner((total,term(x)))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    x=1\n    while x<=n:\n        total=combiner(total,term(x))\n        x=x+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n                                          =>           \r\n        total = combiner(total,term(x))   =>           \r\n                                          =>           \r\n        total = combiner((total,term(x))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 390, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     return combiner(n, accumulate(combiner))\n    return base if n == 0 else combiner(term(n), accumulate(combiner, base, n -1, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                              SideIndicator\r\n-----------                                                                              -------------\r\n    return base if n == 0 else combiner(term(n), accumulate(combiner, base, n -1, term)) =>           \r\n    return base if n == 0 else combiner(n, accumulate(combiner, base, n -1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 391, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     return combiner(n, accumulate(combiner))\n    return base if n == 0 else combiner(n, accumulate(combiner, base, n -1, term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 392, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \ttotal = combiner(total, term(n))\n    \tn -= 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(n)) =>           \r\n        combiner(total, term(n))         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 393, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, reduce(combiner, map(term, [x for x in range(1,n+1)])))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                           SideIndicator\r\n-----------                                                                           -------------\r\n        return combiner(base, reduce(combiner, map(term, [x for x in range(1,n+1)]))) =>           \r\n        return combiner(base, reduce(combiner, map(term, [x for x in range(n+1)])))   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 394, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, reduce(combiner, map(term, [x for x in range(n+1)])))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == base:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    if n == 0:    =>           \r\n    if n == base: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 395, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    while x != n:", 
            "NameError: name 'x' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range (1,n+1):\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range (1,n+1): =>           \r\n    while x != n:           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 396, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while x != n:\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 397, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return combiner(term(n), base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n > 1:                                                             =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    if n > 2:                                                             <=           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 398, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 2:\n        return combiner(term(n), term(n - 1))\n    else:\n        return combiner(term(n), base)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=base\n    k=1\n    while k<=n:\n        result=combiner(result,term(n))\n        k+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(k))\n        k += 1\n    return result\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=base\n    k=1\n    while k<=n:\n        result=combiner(result,term(k))\n        k+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        result = combiner(result, term(k)) =>           \r\n        result = combiner(result, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }
        }, 
        "Id": 399, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(n))\r\n        k += 1\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(i):\n        print i\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(helper(1),base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n2\n3\n4\n5\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "1\n2\n3\n4\n5\n26\n", 
            "print accumulate(mul, 2, 3, square)": "1\n2\n3\n72\n", 
            "print accumulate(add, 11, 3, square)": "1\n2\n3\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n2\n3\n4\n5\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "1\n2\n3\n4\n5\n26\n", 
            "print accumulate(mul, 2, 3, square)": "1\n2\n3\n72\n", 
            "print accumulate(add, 11, 3, square)": "1\n2\n3\n25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        if i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(i+1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(helper(1), base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "2", 
            "3", 
            "4", 
            "5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "#     2", 
            "#     3", 
            "#     4", 
            "#     5", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(i):\n        print i\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(helper(1),base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        print(i) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 400, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate", 
            "    return helper_accumulate(1, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in helper_accumulate", 
            "    return combiner(term(k), helper_accumulate(k+1), term)", 
            "TypeError: helper_accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1, term))\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return combiner(term(k), helper_accumulate(k+1, term)) =>           \r\n            return combiner(term(k), helper_accumulate(k+1), term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 401, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1), term)\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    base=combiner(base,term(n))\n    if n>0:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 1:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    base=combiner(base,term(n))\n    if n>1:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n> 1: =>           \r\n    if n> 0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>1:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "base": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        2, 
                        18, 
                        72, 
                        0, 
                        72, 
                        18
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 402, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>0:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<=0:\n        return base\n    next_term= accumulate(combiner,term(n), n-1, term)\n    return combiner(base, next_term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    next_term= accumulate(combiner,term(n), n-1, term)                          =>           \r\n    return combiner(base, next_term)                                            =>           \r\n    if n<=0:                                                                    =>           \r\n    if n<1:                                                                     <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        0, 
                        2
                    ]
                ]
            }
        }, 
        "Id": 403, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulate_combiner(x,num):\n        if num==0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x,term(num)),num-1)\n    return accumulate_combiner(term(base),n)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(base, n)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulate_combiner(x,num):\n        if num==0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x,term(num)),num-1)\n    return accumulate_combiner(base,n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return accumulate_combiner(base, n)       =>           \r\n    return accumulate_combiner(term(base), n) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(base, n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        3, 
                        20, 
                        2, 
                        24, 
                        1, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11, 
                        121, 
                        3, 
                        130, 
                        2, 
                        134, 
                        1, 
                        135, 
                        134, 
                        130, 
                        121
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        3, 
                        18, 
                        2, 
                        72, 
                        1, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2, 
                        4, 
                        3, 
                        36, 
                        2, 
                        144, 
                        1, 
                        144, 
                        36, 
                        4
                    ]
                ]
            }
        }, 
        "Id": 404, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(term(base), n)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,1)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return base\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, 1) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 405, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if term(base)==0:\n        return base\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if term(n)==0:\n        return base\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if term(n)==0:    =>           \r\n    if term(base)==0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        11, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        2, 
                        3, 
                        9, 
                        2, 
                        4, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        11, 
                        3, 
                        9, 
                        2, 
                        4, 
                        1, 
                        0
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        11, 
                        0, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ], 
                    [
                        11, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        9, 
                        4, 
                        1, 
                        4, 
                        9, 
                        2
                    ], 
                    [
                        2, 
                        9, 
                        4, 
                        1, 
                        0, 
                        1, 
                        4, 
                        9, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        9, 
                        4, 
                        1, 
                        4, 
                        9, 
                        11
                    ], 
                    [
                        11, 
                        9, 
                        4, 
                        1, 
                        0, 
                        1, 
                        4, 
                        9, 
                        11
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 406, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if term(base)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif True:\n        accumulating=combiner(term(n),base)\n        return accumulate(combiner,accumulating,n-1,term)\n    else:\n        return accumulate(combiner,accumulating,n-1,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n#     >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n#     15\n#     >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n#     26\n#     >>> accumulate(add, 11, 0, identity) # 11\n#     11\n#     >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n#     25\n#     >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n#     72\n#     \"\"\"\n    if n == 0:\n        return base\n    elif True:\n        accumulating = combiner(term(n), base)\n        return accumulate(combiner, accumulating, n-1, term)        \n    else:\n        return accumulate(combiner, accumulating, n-1, term)  \n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-a)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            "-- No doctests found for accumulate --", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif True:\n        accumulating=combiner(term(n),base)\n        return accumulate(combiner,accumulating,n-1,term)\n    else:\n        return accumulate(a,accumulating,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                      SideIndicator\r\n-----------                                                                      -------------\r\n    \"\"\"Return the result of combining the first N terms in a sequence.  The      =>           \r\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a      =>           \r\n    two-argument function.  Treating COMBINER as if it were a binary operator,   =>           \r\n    the return value is                                                          =>           \r\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)              =>           \r\n#     \"\"\"Return the result of combining the first N terms in a sequence.  The    <=           \r\n#     terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a    <=           \r\n#     two-argument function.  Treating COMBINER as if it were a binary operator, <=           \r\n#     the return value is                                                        <=           \r\n#         BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(a, accumulating, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 407, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(combiner, accumulating, n-1, term)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    total = 0                                                       <=           \r\n    while n>0:                                                      <=           \r\n        total = combiner(term(n), term(n-1))                        <=           \r\n        n-=1                                                        <=           \r\n    total = combiner(total, term(base))                             <=           \r\n    return total                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 408, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    while n>0:\n        total = combiner(term(n), term(n-1))\n        n-=1\n    total = combiner(total, term(base))\n    return total\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(base,helper)", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(term(n), helper(n-1, term)) \n    return combiner(base,helper(n,term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return combiner(term(n), helper(n-1, term))  =>           \r\n    return combiner(base,helper(n,term))             =>           \r\n        return combiner(n, helper(n-1,term))         <=           \r\n    return combiner(base,helper)                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 409, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(n, helper(n-1,term))\n    return combiner(base,helper)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        total=combiner(total,counter)\n        counter=counter+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter)) \n        counter = counter + 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter=counter+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        total = combiner(total, term(counter))  =>           \r\n        total = combiner(total, counter)        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter = counter+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 410, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, counter)\r\n        counter = counter+1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                        SideIndicator\r\n-----------                                                                        -------------\r\n    if n == 0:                                                                     =>           \r\n        return base                                                                =>           \r\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))              =>           \r\n    if n == 1:                                                                     <=           \r\n        return 1                                                                   <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 411, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return 1\n\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n\n\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        total=combiner(base,term(i))\n        i=2\n        while i<=n:\n            total=combiner(total,term(i))\n            i+=1\n        return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        i = 1\n        total = combiner(base, term(i))\n        i += 1\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    total = combiner(base, term(i))", 
            "UnboundLocalError: local variable 'i' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        total=combiner(base,term(1))\n        i=2\n        while i<=n:\n            total=combiner(total,term(i))\n            i+=1\n        return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i = 1  =>           \r\n        i += 1 =>           \r\n        i = 2  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(1))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 412, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(i))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    counter=1\n    index=2\n    total=combiner(base,term(1))\n    def helper(combiner,base,n,term,counter,index,total):\n        if n==0:\n            return base\n        if n==1:\n            return total\n        if n>counter or n>index:\n            total=combiner(total,term(index))\n            counter+=1\n            index+=1\n            return total*helper(combiner,base,n,term,counter,index,total)\n        return total\n    return helper(combiner,base,n,term,counter,index,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "40500\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "3378648\n", 
            "print accumulate(mul, 2, 3, square)": "41472\n", 
            "print accumulate(add, 11, 3, square)": "10000\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    index = 2\n    total = combiner(base, term(1))\n    def helper(combiner, base, n, term, counter, index, total):\n        if n == 0: \n            return base\n        if n == 1:\n            return total\n        if n > index:\n            total = combiner(total, term(index))\n            counter += 1\n            index += 1\n            return helper(combiner, base, n, term, counter, index, total)\n        return combiner(total, term(n))\n    return helper(combiner, base, n, term, counter, index, total)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "40500", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     40500", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    counter=1\n    index=2\n    total=combiner(base,term(1))\n    def helper(combiner,base,n,term,counter,index,total):\n        if n==0:\n            return base\n        if n==1:\n            return total\n        if n>counter or n>index:\n            total=combiner(total,term(index))\n            counter+=1\n            index+=1\n            return 1*helper(combiner,base,n,term,counter,index,total)\n        return total\n    return helper(combiner,base,n,term,counter,index,total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        if n > index:                                                           =>           \r\n            return helper(combiner, base, n, term, counter, index, total)       =>           \r\n        return combiner(total, term(n))                                         =>           \r\n        if n > counter or n > index:                                            <=           \r\n            return total*helper(combiner, base, n, term, counter, index, total) <=           \r\n        return total                                                            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return 1*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 413, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return total*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n                k = k + 1\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n                k = k + 1 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 414, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    elif combiner== mul:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    elif combiner== mul:                                                          =>           \r\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term)) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 415, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulate_helper(n,term):\n        counter=n-1\n        listen=[base]\n        if counter<0:\n            result=0\n        else:\n            result=combiner(term(n),term(counter))\n        while counter>0:\n            counter-=1\n            x=term(counter)\n            result=combiner(x,result)\n        return result\n    result=accumulate_helper(n,term)\n    return combiner(base,result)\n    print listen\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>1:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulate_helper(n,term):\n        counter=n-1\n        listen=[base]\n        if counter<0:\n            result=0\n        else:\n            result=combiner(term(n),term(counter))\n        while counter>1:\n            counter-=1\n            x=term(counter)\n            result=combiner(x,result)\n        return result\n    result=accumulate_helper(n,term)\n    return combiner(base,result)\n    print listen\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        while counter>1: =>           \r\n        while counter>0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>1:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "result": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        36
                    ], 
                    [
                        36, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 416, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>0:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 417, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    if n==0:\n        return total\n    while i<=n:\n        total=combiner(total,i)\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    if n==0:\n        return total\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 418, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, i)\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "36", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     36", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner == add and term == identity:\n        if n == 0:\n            return base\n        else:\n            return n + accumulate(add, base, n-1, identity)\n    elif combiner == add and term == square:\n        if n == 0:\n            return base\n        else:\n            return n**2 + accumulate(add, base, n-1, square)\n    elif combiner == mul and term == identity:\n        if n == 0:\n            return 0\n        else:\n            return n * accumulate(mul, base, n-1, identity)\n    elif combiner == mul and term == square:\n        if n == 0:\n            return 2\n        else:\n            return combiner(n**2, accumulate(mul, base, n-1, square))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 2 =>           \r\n            return 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 419, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner == add and term == identity:\n        if n == 0:\n            return base\n        else:\n            return n + accumulate(add, base, n-1, identity)\n    elif combiner == add and term == square:\n        if n == 0:\n            return base\n        else:\n            return n**2 + accumulate(add, base, n-1, square)\n    elif combiner == mul and term == identity:\n        if n == 0:\n            return 0\n        else:\n            return n * accumulate(mul, base, n-1, identity)\n    elif combiner == mul and term == square:\n        if n == 0:\n            return 1\n        else:\n            return combiner(n**2, accumulate(mul, base, n-1, square))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return combiner(times(n, 1 - combiner(1, 0)), base)\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    return combiner(times(n, 1 - combiner(1, 0)), base) =>           \r\n    return times(n, 1 - combiner(1, 0)) + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 420, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return times(n, 1 - combiner(1, 0)) + base\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total+=term(i)\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n                                         =>           \r\n        total += term(i)                 <=           \r\n                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        3, 
                        7, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 421, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total += term(i)\r\n        i += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n), accumulate(n-1))", 
            "TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(n-1))                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 422, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,next)=(base,1)\n        while next<=n:\n            total+=combiner(total,term(next))\n            next+=1\n        return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "57\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "409\n", 
            "print accumulate(mul, 2, 3, square)": "200\n", 
            "print accumulate(add, 11, 3, square)": "109\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total = combiner(total,term(next))\n            next+=1\n        return total\n\n        \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "57", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     57", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,next)=(base,1)\n        while next<=n:\n            total=combiner(total,term(next))\n            next+=1\n        return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            total = combiner(total,term(next))  =>           \r\n            total += combiner(total,term(next)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total = combiner(total, term(next))\r\n            next += 1\r\n        return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        11, 
                        26, 
                        57
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        20, 
                        200
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        23, 
                        48, 
                        99, 
                        202, 
                        409
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        23, 
                        50, 
                        109
                    ]
                ]
            }
        }, 
        "Id": 423, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total += combiner(total, term(next))\r\n            next += 1\r\n        return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        Total = combiner(Total, term(counter))\n        counter += 1\n    return Total\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    return Total  =>           \r\n    return Total  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 424, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        counter += 1\n        Total = combiner(Total, term(counter))\n    return Total \n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "<built-in function add>", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     <built-in function add>", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<=n:\n        start= combiner(start, term(i))\n        i +=1\n    return start\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    while i<=n:                   =>           \r\n    return start                  =>           \r\n    return accumulate(add, start) =>           \r\n    while i<n:                    <=           \r\n    return combiner               <=           \r\n    return _______                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 425, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<n:\n        start= combiner(start, term(i))\n        i +=1\n    return combiner\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate", 
            "    return awkward_accumulate(combiner, base, 1, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in awkward_accumulate", 
            "    return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                      SideIndicator\r\n-----------                                                                                      -------------\r\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))           =>           \r\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 426, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     15_________", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    15                                 =>           \r\n    15_________                        <=           \r\n    elif n == 1:                       <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 427, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        i=1\n        accumulation=base\n        while i<n:\n            accumulation=combiner(accumulation,term(i))\n            i+=1\n        return accumulation\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n+1:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        i=1\n        accumulation=base\n        while i<n+1:\n            accumulation=combiner(accumulation,term(i))\n            i+=1\n        return accumulation\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        while i < n+1: =>           \r\n        while i < n:   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n+1:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "accumulation": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 428, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    total = combiner(total,term)", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term(k))\n        k+=1\n    return total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        total = combiner(total,term(k))    =>           \r\n    return accumulate(mul, 1, n, term)     =>           \r\n                                           =>           \r\n        total = combiner(total,term)       <=           \r\n    return accumulate(product, 1, n, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 429, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term)\n        k+=1\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n        return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "1\n", 
            "print accumulate(add, 11, 0, identity)": "None\n", 
            "print accumulate(add, 11, 5, identity)": "12\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "12\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n    return total\n        \n\n        \n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 430, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n        return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=0\n    combined=base\n    while i<=n:\n        combined=combiner(combined,term(i))\n        i+=1\n    return combined\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    combined=base\n    while i<=n:\n        combined=combiner(combined,term(i))\n        i+=1\n    return combined\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "combined": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 431, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 0\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=0\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69
                    ]
                ]
            }
        }, 
        "Id": 432, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return base                    =>           \r\n    if n == 1:                         =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 0, n, term) =>           \r\n    if n <= 1:                         <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 433, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    count=1\n    answer=base\n    while count<n:\n        answer=combiner(answer,term(count))\n        count+=1\n    return answer\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count <= n:\n        answer = combiner(answer, term(count) )\n        count +=1\n\n    return answer\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    count=1\n    answer=base\n    while count<n+1:\n        answer=combiner(answer,term(count))\n        count+=1\n    return answer\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n                      =>           \r\n    while count < n:  <=           \r\n                      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n+1:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "count": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "answer": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }
        }, 
        "Id": 434, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=n\n    total=base\n    if n==0:\n        return base\n    else:\n        while i>1:\n            total=combiner(total,term(i))\n            i-=1\n        return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "14\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "25\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "24\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i >= 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "14", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     14", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=n\n    total=base\n    if n==0:\n        return base\n    else:\n        while i>=1:\n            total=combiner(total,term(i))\n            i-=1\n        return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        while i >= 1: =>           \r\n        while i > 1:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>=1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        24
                    ]
                ]
            }
        }, 
        "Id": 435, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    s=base\n    for i in range(1,n+1):\n        s+=combiner(s,term(i))\n    return s\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "57\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "409\n", 
            "print accumulate(mul, 2, 3, square)": "200\n", 
            "print accumulate(add, 11, 3, square)": "109\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s = combiner(s, term(i))\n    return s\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "57", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     57", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        s = combiner(s, term(i))  =>           \r\n        s += combiner(s, term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s = combiner(s, term(i))\r\n    return s", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "s": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        11, 
                        26, 
                        57
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        20, 
                        200
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        23, 
                        48, 
                        99, 
                        202, 
                        409
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        23, 
                        50, 
                        109
                    ]
                ]
            }
        }, 
        "Id": 436, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s += combiner(s, term(i))\r\n    return s"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "18", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     18", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    if combiner == mul:\n            total = 1\n    while i <= n:    \n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if combiner == mul:     =>           \r\n    while i <= n:           =>           \r\n    while i <= n:           <=           \r\n        if combiner == mul: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 437, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    while i <= n:\n        if combiner == mul:\n            total = 1\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    total=0\n    if base>n:\n        total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > 0:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if base>n:\n        total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if base > 0: =>           \r\n    if base > n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        11, 
                        12, 
                        16, 
                        25
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 438, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = 0\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return combiner(term(n), combiner(n-1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), combiner(n-1, term))                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 439, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), combiner(n-1, term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n-1),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "11\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "22\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 2:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n-0),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-0), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        2, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 440, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return acc\n    else:\n        next_acc=combiner(term(n),acc)\n        return accumulate(combiner,next_acc,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    next_acc = combiner(term(n), acc)", 
            "NameError: name 'acc' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        next_acc=combiner(term(n),base)\n        return accumulate(combiner,next_acc,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        return base                                      =>           \r\n        base = combiner(term(n), base)                   =>           \r\n        return accumulate(combiner, base, n-1, term)     =>           \r\n        return acc                                       <=           \r\n        next_acc = combiner(term(n), acc)                <=           \r\n        return accumulate(combiner, next_acc, n-1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 441, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return acc\r\n    else:\r\n        next_acc = combiner(term(n), acc)\r\n        return accumulate(combiner, next_acc, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    q=0\n    for i in range(1,n+1):\n        q=combiner(q,term(i))\n    return combiner(base,q)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=term(1)\n    for i in range(2, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    q=base\n    for i in range(1,n+1):\n        q=combiner(q,term(i))\n    return q\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    q=term(1)               =>           \r\n    for i in range(2, n+1): =>           \r\n    q=0                     <=           \r\n    for i in range(1, n+1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = base\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return q", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "q": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 442, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = 0\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return combiner(base, q)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n        \n    \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    else:                                                           =>           \r\n                                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 443, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    \n        \n    \n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "9\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "9\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "13\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 444, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def combiner_helper(n):\n        if n==0:\n            return 0\n        elif n==1:\n            return term(n)\n        else:\n            return combiner(term(n),combiner_helper(n-1))\n    return combiner_helper(n)+base\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "38\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner(combiner_helper(n), base)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def combiner_helper(n):\n        if n==0:\n            return 0\n        elif n==1:\n            return term(n)\n        else:\n            return combiner(term(n),combiner_helper(n-1))\n    return combiner(combiner_helper(n),base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return combiner(combiner_helper(n), base) =>           \r\n    return combiner_helper(n) + base          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner(combiner_helper(n), base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 445, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner_helper(n)+base"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate", 
            "    total+=accumulate (combiner, base, k, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    base>=0", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n   \n    if n ==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n                                                                        =>           \r\n    if n ==0:                                                           =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n    total=0                                                             <=           \r\n    base>=0                                                             <=           \r\n    k=n                                                                 <=           \r\n    combiner=(term(n)+term(n-1))                                        <=           \r\n    while k>=0:                                                         <=           \r\n        total+=accumulate (combiner, base, k, term)                     <=           \r\n        k-=1                                                            <=           \r\n    return total                                                        <=           \r\n    # if n ==0:                                                         <=           \r\n    #     return combiner(base, accumulate(combiner, base, n, term))    <=           \r\n    # else:                                                             <=           \r\n    #     return accumulate(combiner, base, n-1, term)                  <=           \r\n                                                                        <=           \r\n                                                                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 446, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=0 \n    base>=0\n    k=n\n    combiner=(term(n)+term(n-1))\n    while k>=0:\n        total+=accumulate (combiner, base, k, term)\n        k-=1\n    return total \n\n    # if n ==0:\n    #     return combiner(base, accumulate(combiner, base, n, term))\n    # else:\n    #     return accumulate(combiner, base, n-1, term)\n\n        \n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "7237", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     7237", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if combiner == add:\n        final_number = 0\n    elif combiner == mul:\n        final_number = 1\n    while k > 0:\n        final_number, k = combiner(final_number, term(k)), k - 1\n    return combiner(base, final_number)\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if combiner == add:                                                =>           \r\n        final_number = 0                                               =>           \r\n    elif combiner == mul:                                              =>           \r\n        final_number = 1                                               =>           \r\n        final_number, k = combiner(final_number, term(k)), k - 1       =>           \r\n                                                                       =>           \r\n    final_number = 0                                                   <=           \r\n        final_number, k = combiner(term(final_number), term(k)), k - 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 447, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    final_number = 0\n    while k > 0:\n        final_number, k = combiner(term(final_number), term(k)), k - 1\n    return combiner(base, final_number)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n),accumulate(n-1))\n    elif n==1:\n        return combiner(base,term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\"\"\"\n    \n    \n    if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combiner(term(n), accumulate(n-1))", 
            "TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    elif n==1:\n        return combiner(base,term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return combiner(base, term(n))\"\"\"          =>           \r\n    return combiner(base, accumulate_helper(1))    =>           \r\n        return combiner(base, term(n))             <=           \r\n    return combiner(base, accumulate_helper(1))\"\"\" <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    elif n==1:\r\n        return combiner(base, term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 448, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(n-1))\r\n    elif n==1:\r\n        return combiner(base, term(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    while i<= n:", 
            "NameError: name 'i' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while x<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while x<= n: =>           \r\n    while i<= n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 449, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while i<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=0\n    else:\n        total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return base+total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "38\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total,term(i))\n        i += 1\n \n    return total\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=0\n    else:\n        total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return combiner(base,total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    if combiner == add: <=           \r\n        total = 0       <=           \r\n        total = 1       <=           \r\n    return base+total   <=           \r\n    else:               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return combiner(base, total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 450, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return base+total\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    total = combiner(total, term(x))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'range'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return total\n    else:\n        for x in range(1, n+1):\n            total = combiner(total, term(x))\n        return total\n\n    # if n == 0:\n    #     return base\n    # else:\n    #     return term(n)*accumulate(combiner, base, n-1, term)\n\n    # total, product, k = 0,1,1\n    # if n == 0:\n    #     return base\n    # while k <= n:\n    #     if combiner == add:\n    #         total, k = total+term(k), k+1\n    #     else:\n    #         product, k = product*(term(k)), k+1\n    # total = total + base\n    # product = product*base\n    # if combiner == add:\n    #     return total\n    # return product\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        for x in range(1, n+1):              =>           \r\n            total = combiner(total, term(x)) =>           \r\n                                             =>           \r\n        x = range(1, n+1)                    <=           \r\n        total = combiner(total, term(x))     <=           \r\n    #     ADD VS MULTIPLY?                   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 451, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return total\n    else:\n        x = range(1, n+1)\n        total = combiner(total, term(x))\n        return total\n\n    # if n == 0:\n    #     return base\n    # else:\n    #     return term(n)*accumulate(combiner, base, n-1, term)\n    #     ADD VS MULTIPLY?\n    # total, product, k = 0,1,1\n    # if n == 0:\n    #     return base\n    # while k <= n:\n    #     if combiner == add:\n    #         total, k = total+term(k), k+1\n    #     else:\n    #         product, k = product*(term(k)), k+1\n    # total = total + base\n    # product = product*base\n    # if combiner == add:\n    #     return total\n    # return product\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate", 
            "    return base + result1", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    return accumulate(add, 0, n, term)                                    =>           \r\n    return accumulate(mul, 1, n, term)                                    =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n    if combiner == add:                                                   <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            summation_using_accumulate                                    <=           \r\n            k += 1                                                        <=           \r\n        result1 = summation_using_accumulate                              <=           \r\n        return base + result1                                             <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            product_using_accumulate                                      <=           \r\n            k += 1                                                        <=           \r\n        result2 = product_using_accumulate                                <=           \r\n        return base * result2                                             <=           \r\n    total += term(k)                                                      <=           \r\n    total, k = 1, 1                                                       <=           \r\n    def helper(n, term):                                                  <=           \r\n        while k <= n:                                                     <=           \r\n            total, k = total * term(k), k + 1                             <=           \r\n        return total                                                      <=           \r\n    return helper                                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 452, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        k = 1\n        while k <= n:\n            summation_using_accumulate\n            k += 1\n        result1 = summation_using_accumulate\n        return base + result1\n\n    else:\n        k = 1\n        while k <= n:\n            product_using_accumulate\n            k += 1\n        result2 = product_using_accumulate\n        return base * result2\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        result, i = combiner(term(i), result), i + 1\n    return result\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        result, i = combiner(term(i), result), i + 1 =>           \r\n        total, i = combiner(term(i), result), i + 1  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 453, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        total, i = combiner(term(i), result), i + 1\n    return result\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    k = next(k)", 
            "TypeError: 'int' object is not an iterator", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                                                                               SideIndic\r\n                                                                                                                                          ator     \r\n-----------                                                                                                                               ---------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                                   =>       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else combiner(x, accumulate(combiner, base, n-1, term)), base, n, term) =>       \r\n                                                                                                                                          =>       \r\n    k, result = 1, base                                                                                                                   <=       \r\n    while (k <= n):                                                                                                                       <=       \r\n        result = combiner(result, term(k))                                                                                                <=       \r\n        k = next(k)                                                                                                                       <=       \r\n    return result                                                                                                                         <=       \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"                                                                <=       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else base, base, n, term)                                               <=       \r\n    \"\"\"                                                                                                                                   <=       \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 454, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, result = 1, base\n    while (k <= n):\n        result = combiner(result, term(k))\n        k = next(k)\n    return result\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    final=1\n    x=base\n    while x<=n:\n        final=combiner(term(x),final)\n        x=x+1\n    return final\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "1\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "1\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    final = base\n    x = 1\n    while x <= n:\n        final = combiner(term(x), final)\n        x = x + 1\n    return final\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    final=base\n    x=1\n    while x<=n:\n        final=combiner(term(x),final)\n        x=x+1\n    return final\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    final = base                                    =>           \r\n    x = 1                                           =>           \r\n    while x <= n:                                   =>           \r\n        final = combiner(term(x), final)            =>           \r\n    # total, k = base, 1                            <=           \r\n    # while k <=n:                                  <=           \r\n    #     total, k = combiner(term(k),total), k + 1 <=           \r\n    # return total                                  <=           \r\n    # total = 1                                     <=           \r\n    # k = base                                      <=           \r\n    # while k <=n:                                  <=           \r\n    #     total = combiner(term(k),total)           <=           \r\n    #     k = k + 1                                 <=           \r\n    # return total                                  <=           \r\n    final = 1                                       <=           \r\n    x = base                                        <=           \r\n    while x <=n:                                    <=           \r\n        final = combiner(term(x),final)             <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    final = base\r\n    x = 1\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "final": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 455, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    final = 1\r\n    x = base\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=0\n    result=combiner(base,term(k))\n    while k<n:\n        (result,k)=(combiner(result,term(k+1)),k+1)\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base, term(n))\n    while n>1:\n        result, n = combiner(result, term(n-1)), n-1\n    return result\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=0\n    result=base\n    while k<n:\n        (result,k)=(combiner(result,term(k+1)),k+1)\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    result = combiner(base, term(n))                 =>           \r\n    while n>1:                                       =>           \r\n        result, n = combiner(result, term(n-1)), n-1 =>           \r\n    k=0                                              <=           \r\n    result = combiner(base, term(k))                 <=           \r\n    while k<n:                                       <=           \r\n        result, k = combiner(result, term(k+1)), k+1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = base\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "result": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 456, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = combiner(base, term(k))\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    total, k = start, 1", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n    total, k = start, 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 457, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #func, first number, count from one to, term\n    total = base\n    while n >= 0:      \n        total = combiner(term(n), total)\n        n -= 1\n        if combiner == mul and n == 0:\n            return total\n            \n      #  if n == 0:\n            #total = combiner(base, total)\n    return total \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if combiner == mul and n == 0: =>           \r\n            return total               =>           \r\n                                       =>           \r\n    return total                       =>           \r\n    return total                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        72, 
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ]
            }
        }, 
        "Id": 458, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(0)\n    def helper(x,term):\n        if x==1:\n            return term(1)\n        else:\n            return combiner(term(x),helper(x-1,term))\n    return combiner(base,helper(n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(x, term):\n        if n == 0:\n            return term(0)\n        elif x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    def helper(x,term):\n        if x==1:\n            return term(1)\n        else:\n            return combiner(term(x),helper(x-1,term))\n    return combiner(base,helper(n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 0:         =>           \r\n            return term(0) =>           \r\n        elif x == 1:       =>           \r\n                           =>           \r\n    if n == 0:             <=           \r\n        return term(0)     <=           \r\n        if x == 1:         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 459, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(0)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n        start += 1\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        start += 1 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 460, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n    return total\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    while k<=n:\n        total=combiner(total,term(k))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k = k + 1\n    return total \n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        k = k + 1 =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108
                    ]
                ]
            }
        }, 
        "Id": 461, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate", 
            "    return combiner(base, accumulate(combiner, base, k+1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate", 
            "    if k == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    if n == 0:                                                                      =>           \r\n        return base                                                                 =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))           =>           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(x) else y, base, n, term) =>           \r\n    k = 0                                                                           <=           \r\n    if k == n:                                                                      <=           \r\n        return term(n)                                                              <=           \r\n        return combiner(base, accumulate(combiner, base, k+1, term))                <=           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(y) else x, base, n, term) <=           \r\n                                                                                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 462, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    if k == n:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, base, k+1, term)) \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=1\n    for i in range(2,n+1):\n        total=combiner(total,term(i))\n    return combiner(base,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        total = 1\n        for i in range(2, n+1):\n            total = combiner(total, term(i)) \n        return combiner(base, total)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=1\n    if n==0:\n        return base\n    for i in range(2,n+1):\n        total=combiner(total,term(i))\n    return combiner(base,total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 0:                                =>           \r\n        return base                           =>           \r\n        total = 1                             =>           \r\n        for i in range(2, n+1):               =>           \r\n            total = combiner(total, term(i))  =>           \r\n        return combiner(base, total)          =>           \r\n    else:                                     =>           \r\n    total = 1                                 <=           \r\n    for i in range(2, n+1):                   <=           \r\n        total = combiner(total, term(i))      <=           \r\n    return combiner(base, total)              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    if n==0:\r\n        return base\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 463, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 464, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if base != 0:\n        return combiner(base, accumulate(combiner, 0, n, term))\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return combiner(accumulate(combiner, 0, n - 1, term), term(n))\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif n == 1:       =>           \r\n        return term(n) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 465, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if base != 0:\n        return combiner(base, accumulate(combiner, 0, n, term))\n    elif n == 0:\n        return 0\n    else:\n        return combiner(accumulate(combiner, 0, n - 1, term), term(n))\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(base, n-1, term(n)))", 
            "TypeError: accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n > 0:                                                           =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    if n > 1:                                                           <=           \r\n        return combiner(term(n), accumulate(base, n-1, term(n)))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 466, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(base, n-1, term(n)))\n    else:\n        return base\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    return combiner(term(n)) + accumulate(combiner, base, n-1, term)", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 467, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term) \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    acc=base\n    for i in range(n+1):\n        acc=combiner(acc,term(i))\n    return acc\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n):\n        acc = combiner(acc, term(i+1))\n    return acc\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    acc=base\n    for i in range(1,n+1):\n        acc=combiner(acc,term(i))\n    return acc\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for i in range(n):                 =>           \r\n        acc = combiner(acc, term(i+1)) =>           \r\n    for i in range(n+1):               <=           \r\n        acc = combiner(acc, term(i))   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(1, n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "acc": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }, 
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 468, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 469, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    total, k = start, 1", 
            "NameError: name 'start' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n                        =>           \r\n    total, k = start, 1 <=           \r\n                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 470, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combine(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate", 
            "    return combine(accumulate(combiner, base, n-1, term), term(n))", 
            "NameError: name 'combine' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 471, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combine(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    ans=combiner(base,term(1))\n    for i in range(2,n+1):\n        ans=combiner(ans,term(i))\n    return ans\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    ans = combiner(base, term(1))\n    for i in range(2, n+1):\n        ans = combiner(ans, term(i))\n    return ans\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    ans=combiner(base,term(1))\n    for i in range(2,n+1):\n        ans=combiner(ans,term(i))\n    return ans\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 472, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 473, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 474, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper_function(combiner,n,term):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),helper_function(combiner,n-1,term))\n    return combiner(base,helper_function(combiner,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if (n == 1) | (n == 0) :\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function", 
            "    return combiner(term(n), helper_function(combiner, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in helper_function", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper_function(combiner,n,term):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),helper_function(combiner,n-1,term))\n    return combiner(base,helper_function(combiner,n,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        if (n == 1) | (n == 0) : =>           \r\n        if n == 1:               <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 475, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return base + term(combiner(n))", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n    \n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n        return combiner(accumulate(combiner,base,n-1,term),term(n)) =>           \r\n    else:                                                           =>           \r\n    return base + term(combiner(n))                                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 476, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return base + term(combiner(n))\n\n    \n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def term_output(n):\n        return term(n)\n    (total,i)=(base,1)\n    while i<=n:\n        print total\n        total=combiner(total,term_output(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n1\n3\n6\n10\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n12\n14\n17\n21\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n2\n8\n72\n", 
            "print accumulate(add, 11, 3, square)": "11\n12\n16\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n1\n3\n6\n10\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n12\n14\n17\n21\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n2\n8\n72\n", 
            "print accumulate(add, 11, 3, square)": "11\n12\n16\n25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    def term_output(n):\n        return term(n)\n\n\n    total, i = (base), 1\n\n    while i <= n:\n     \n        total = combiner(total, term_output(i))\n        i+= 1\n        \n\n    return total\n\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "1", 
            "3", 
            "6", 
            "10", 
            "15", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "#     1", 
            "#     3", 
            "#     6", 
            "#     10", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def term_output(n):\n        return term(n)\n    (total,i)=(base,1)\n    while i<=n:\n        print total\n        total=combiner(total,term_output(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 477, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner(term(n, base))", 
            "TypeError: identity() takes 1 positional argument but 2 were given", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return combiner(term(n, base)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 478, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n, base))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    list=[]\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        append.list(k)\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    list = []\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        list.append(k)\n        k += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    append.list(k)", 
            "NameError: name 'append' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    list=[]\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        k\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        list.append(k) =>           \r\n        append.list(k) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 479, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        append.list(k)\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        total=combiner(term(n),base)\n        return accumulate(combiner,total,n-1,term)\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total=combiner(term(n),base)               =>           \r\n        return accumulate(combiner,total,n-1,term) =>           \r\n        return accumulate(combiner,base,n-1,term)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 480, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    return reduce(combiner, [base] + list(map(term, [i for i in range(1, n + 1)])))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    return reduce(combiner, [base] + list(map(term, [i for i in range(1, n + 1)]))) =>           \r\n    return reduce(combiner, [base] + list(map(term, [i for i in range(n)])))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 2, 
        "Id": 481, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    return reduce(combiner, [base] + list(map(term, [i for i in range(n)])))\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    total = total * combiner(x, term(i))", 
            "UnboundLocalError: local variable 'total' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        x = combiner(x, term(i))\n    return x\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        x = combiner(x, term(i))             =>           \r\n        total = total * combiner(x, term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 482, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        total = total * combiner(x, term(i))\n    return x\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 483, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "645", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     645", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if combiner==add:\n            sum+=x\n        if combiner==mul:\n            sum*=x\n    return sum\n    \n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        if combiner==add: =>           \r\n        if combiner==mul: =>           \r\n        if add:           <=           \r\n        if mul:           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 484, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if add:\n            sum+=x\n        if mul:\n            sum*=x\n    return sum\n    \n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    return base+accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "66\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "44\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return base + accumulate(combiner, base, n-1, term)             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 485, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return base+accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "13", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     13", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term)) =>           \r\n    if n == 1:                                                          <=           \r\n        return term(n)                                                  <=           \r\n        return combiner(base, accumulate(combiner, n, n-1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 486, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, n, n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    a=0\n    b=base\n    while a<=n:\n        b=combiner(b,term(a))\n        a+=1\n    return b\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    a=1\n    b=base\n    while a<=n:\n        b=combiner(b,term(a))\n        a+=1\n    return b\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    a = 1   =>           \r\n    a = 0   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    a = 1\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "a": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "b": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 487, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    k=1\n    while k<=n:\n        result,k=combiner(result,term(k)), k+1\n    return result\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    k=1                                                 =>           \r\n    while k<=n:                                         =>           \r\n        result,k=combiner(result,term(k)), k+1          =>           \r\n    while base<=n:                                      <=           \r\n        result,base=combiner(result,term(base)), base+1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 488, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    while base<=n:\n        result,base=combiner(result,term(base)), base+1\n    return result\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    start=base\n    count=1\n    while count<=n:\n        start=combiner(start,term(n))\n        count+=1\n    return start\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while n > 0:\n        start = combiner(start, term(n))\n        n-=1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    start=base\n    k=1\n    while k<=n:\n        start=combiner(start,term(k))\n        k+=1\n    return start\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while n > 0:      =>           \r\n        n-=1          =>           \r\n    while count <= n: <=           \r\n        count += 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    k = 1\r\n    while k<=n:\r\n        start = combiner(start, term(k))\r\n        k += 1\r\n    return start", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "start": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 489, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    count = 1\r\n    while count<=n:\r\n        start = combiner(start, term(n))\r\n        count += 1\r\n    return start"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 1:\n            return term(1)\n        if n == 0:\n            return 0\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n            return 0       =>           \r\n            return term(0) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 490, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 0:\n            return term(0)\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k<n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<n+1:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k <= n: =>           \r\n    k = 0         <=           \r\n    while k < n:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<n+1:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 491, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=n\n    total=term(n)\n    while i>0:\n        i-=1\n        total=combiner(total,term(i))\n    return combiner(total,base)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 1:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=n\n    total=term(n)\n    while i>1:\n        i-=1\n        total=combiner(total,term(i))\n    return combiner(total,base)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while i > 1: =>           \r\n    while i > 0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>1:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        9, 
                        36
                    ], 
                    [
                        9, 
                        36, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 492, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>0:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "21913", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     21913", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term))       =>           \r\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 493, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term)))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return combiner(base,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=base                  =>           \r\n    return total                =>           \r\n    total=0                     <=           \r\n    return combiner(base,total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        0, 
                        9, 
                        13, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 494, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return combiner(base, total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    else:\n        return combiner(base,term(n))+accumulate(combiner,base,n-1,term)\n    (index,total)=(1,base)\n    while index<=n:\n        total=combiner(total,term(index))\n        index+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "70\n", 
            "print accumulate(mul, 2, 3, square)": "28\n", 
            "print accumulate(add, 11, 3, square)": "47\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "70", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     70", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (index,total)=(1,base)\n    while index<=n:\n        total=combiner(total,term(index))\n        index+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x:0)    =>           \r\n        return 0                                                                <=           \r\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term) <=           \r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x :0)   <=           \r\n    if n == 0:                                                                  <=           \r\n    else:                                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 495, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    else:\r\n        return combiner(base, term(n))+accumulate(combiner, base, n-1, term)\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 496, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=base\n    for i in range(1,n+1):\n        y=combiner\n        x=y(x,term(n))\n    return x\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(i))\n    return x\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=base\n    for n in range(1,n+1):\n        y=combiner\n        x=y(x,term(n))\n    return x\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        x = y(x, term(i)) =>           \r\n        x = y(x, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for n in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        6, 
                        4, 
                        10, 
                        5, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        5, 
                        15, 
                        5, 
                        20, 
                        5, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        1, 
                        2, 
                        8, 
                        3, 
                        72
                    ], 
                    [
                        2, 
                        3, 
                        18, 
                        3, 
                        162, 
                        3, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        14, 
                        3, 
                        17, 
                        4, 
                        21, 
                        5, 
                        26
                    ], 
                    [
                        11, 
                        5, 
                        16, 
                        5, 
                        21, 
                        5, 
                        26, 
                        5, 
                        31, 
                        5, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        16, 
                        3, 
                        25
                    ], 
                    [
                        11, 
                        3, 
                        20, 
                        3, 
                        29, 
                        3, 
                        38
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 497, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=1\n    y=1\n    if term==add:\n        y=0\n    while x<=n:\n        y=combiner(y,term(x))\n        x+=1\n    return combiner(base,y)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    x = 1\n    y = 1\n    if combiner == add:\n        y = 0\n    while x <= n:\n        y = combiner(y, term(x))\n        x += 1\n    return combiner(base, y)\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=1\n    y=base\n    if term==add:\n        y=0\n    while x<=n:\n        y=combiner(y,term(x))\n        x+=1\n    return y\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n    if term == add:     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = base\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return y", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "y": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 498, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = 1\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return combiner(base, y)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "59", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     59", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n    if n < 1:                                                                           =>           \r\n        return base                                                                     =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))                 =>           \r\n    if n == 1:                                                                          <=           \r\n        return term(n)                                                                  <=           \r\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 499, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base)\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "4", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     4", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n-1), base)                                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 500, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n-1), base)\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return term(1)+base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "108", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     108", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return term(1)+base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n == 1:                <=           \r\n        return term(1) + base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 501, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, term(i))\n    return combiner(total, term(n))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(total, term(n))      =>           \r\n        total = combiner(total, i)       <=           \r\n    return combiner(total, n)            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 502, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, i)\n    return combiner(total, n)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1,term), term(n))\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(accumulate(combiner, base, n-1,term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1,term)                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 503, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (a,b)=(base,1)\n    while b<=n:\n        a=combiner(a,term(i))\n        b=b+1\n    return a\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(b))\n        b = b + 1\n    return a\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    a = combiner(a, term(i))", 
            "NameError: name 'i' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (a,b)=(base,1)\n    while b<=n:\n        a=combiner(a,term(b))\n        b=b+1\n    return a\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        a = combiner(a, term(b)) =>           \r\n        a = combiner(a, term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(b))\r\n        b = b+1\r\n    return a", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "a": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "b": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }
        }, 
        "Id": 504, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(i))\r\n        b = b+1\r\n    return a"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n)+accumulate(combiner, base, n-1, term)           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 505, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return term(n)+accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 506, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    counter=0\n    total=base\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    counter = 1\n    total = base\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total \n\n \n'''    def value(i):\n        if n == 0:\n            return term(n)\n        if i == n:\n            return term(i)\n        else:\n            return combiner( term(i), value(i + 1))\n    \n    value = value(1)\n    return combiner(base, value)'''\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ]
            }
        }, 
        "Id": 507, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    counter = 0\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<n+1:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 508, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    if n==0:\n        return term(base)\n    else:\n        return base+combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "70\n", 
            "print accumulate(mul, 2, 3, square)": "92\n", 
            "print accumulate(add, 11, 3, square)": "47\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(1))\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "70", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     70", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    if n==0:\n        return term(base)\n    else:\n        return 0+combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                    SideIndicator\r\n-----------                                                                    -------------\r\n        return combiner(base, term(1))                                         =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        =>           \r\n        return combiner(base, term(n))                                         <=           \r\n        return base + combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return 0+combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 509, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return base+combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n    if n == 0:                                                     =>           \r\n        return base                                                =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n    def summation(n,term):                                         <=           \r\n        total, k = 0,1                                             <=           \r\n        while k<=n:                                                <=           \r\n            total,k = total + term(k), k+1                         <=           \r\n            return total                                           <=           \r\n    if combiner == add:                                            <=           \r\n        return base + summation(n,term)                            <=           \r\n        return base + product (n,term)                             <=           \r\n    else:                                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 510, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(n,term):\n        total, k = 0,1\n        while k<=n:\n            total,k = total + term(k), k+1\n            return total\n    if combiner == add:\n        return base + summation(n,term)\n    else:\n        return base + product (n,term)\n\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=0\n    p=1\n    sum2=0\n    sum3=1\n    if combiner==add:\n        while k<=n:\n            sum2=sum2+term(k)\n            k+=1\n        return base+sum2\n    if combiner==mul:\n        while p<=n:\n            sum3=sum3*term(k)\n            p+=1\n        return base*sum3\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(p)\n            p += 1\n\n        return base * sum3\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=0\n    k=1\n    sum2=0\n    sum3=1\n    if combiner==add:\n        while k<=n:\n            sum2=sum2+term(k)\n            k+=1\n        return base+sum2\n    if combiner==mul:\n        while k<=n:\n            sum3=sum3*term(k)\n            k+=1\n        return base*sum3\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            sum3 = sum3 * term(p) =>           \r\n            sum3 = sum3 * term(k) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    k = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while k<=n:\r\n            sum3 = sum3*term(k)\r\n            k += 1\r\n        return base*sum3", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "k": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0
                    ]
                ]
            }, 
            "sum3": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        4, 
                        36
                    ], 
                    [
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 511, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    p = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while p<=n:\r\n            sum3 = sum3*term(k)\r\n            p += 1\r\n        return base*sum3"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    total, k = total + combiner(term(k)), k + 1", 
            "TypeError: op_add expected 2 arguments, got 1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1 \n    return total\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        total, k = combiner(total, term(k)), k + 1   =>           \r\n        total, k = total + combiner(term(k)), k + 1  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 512, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = total + combiner(term(k)), k + 1 \n    return total\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))             =>           \r\n    return accumulate(add, 1, n, identity)                                          =>           \r\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term) <=           \r\n    return _______                                                                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 513, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper", 
            "    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate_helper", 
            "    if k==n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    if n==0:\n        return base\n    return combiner(base,accumulate_helper(n,term,1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, accumulate_helper(n, term, 1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "k": {}
        }, 
        "Id": 514, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    return combiner(base, accumulate_helper(n, term, 1))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    total= combiner(total,term(k))", 
            "NameError: name 'k' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=base\n    k=1\n    while k<=n:\n        total= combiner(total,term(k))\n        k+=1\n    return total    \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    total=base     =>           \r\n    k=1            =>           \r\n    while k<=n:    =>           \r\n        k+=1       =>           \r\n    total=1        <=           \r\n    while base<=n: <=           \r\n        base+=1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 515, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=1\n    while base<=n:\n        total= combiner(total,term(k))\n        base+=1\n    return total    \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulator(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulator(combiner, base, n - 1, term))", 
            "NameError: name 'accumulator' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n    return combiner(term(n), accumulator(combiner, base, n - 1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 516, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulator(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 517, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate", 
            "    return combiner(term(n),accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 518, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n        combiner(term(n), accumulate(combiner, base, n - 1, term))         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 519, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    if combiner == add():", 
            "TypeError: op_add expected 2 arguments, got 0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add:\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul:\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        if combiner == add:     =>           \r\n        elif combiner == mul:   =>           \r\n        if combiner == add():   <=           \r\n        elif combiner == mul(): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 520, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add():\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul():\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x <= n: =>           \r\n                  =>           \r\n    while x <= 1: <=           \r\n                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 521, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= 1:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n    \n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    i=1\n    final=combiner(base,term(1))\n    while i<=n:\n        final=combiner(final,term(i))\n        i+=1\n    return final\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    final = combiner(base, term(1))\n    i = 2\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    i=1\n    final=base\n    while i<=n:\n        final=combiner(final,term(i))\n        i+=1\n    return final\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 2   =>           \r\n    i = 1   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = base\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "final": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        12, 
                        13, 
                        15, 
                        18, 
                        22, 
                        27
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        12, 
                        13, 
                        17, 
                        26
                    ]
                ]
            }
        }, 
        "Id": 522, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = combiner(base, term(1))\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=1\n    k=1\n    while k<=n:\n        total=combiner(term(k),total)\n        k=k+1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "1\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "15\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), increment(k)\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(term(k),total)\n        k=k+1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n    total, k = base, 1                                    =>           \r\n        total, k = combiner(term(k), total), increment(k) =>           \r\n    total = 1                                             <=           \r\n    k = 1                                                 <=           \r\n        total = combiner(term(k), total)                  <=           \r\n        k = k + 1                                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        1, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15
                    ]
                ]
            }
        }, 
        "Id": 523, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 524, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    lst=map(term,range(1,n+1))\n    total=base\n    k=0\n    while k<n:\n        k+=1\n        total=combiner(total,k)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, term(k))\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    lst=map(term,range(1,n+1))\n    total=base\n    k=0\n    while k<n:\n        k+=1\n        total=combiner(total,term(k))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                               SideIndicator\r\n-----------                                                                               -------------\r\n        total = combiner(total, term(k))                                                  =>           \r\n    def f(g, h):                                                                          =>           \r\n        return g                                                                          =>           \r\n    return accumulate(lambda y,x: combiner(y,x) if pred(x) else f(y, x), base, n, term)   =>           \r\n        total = combiner(total, k)                                                        <=           \r\n    return accumulate(combiner, base, n, term)                                            <=           \r\n                                                                                          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, term(k))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        4, 
                        12
                    ]
                ]
            }
        }, 
        "Id": 525, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, k)\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    result=base\n    a=1\n    while a<=n:\n        result=combiner(base,term(a))\n        a+=1\n    return result\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while a <= n:\n        result = combiner(term(a), result)\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    result=base\n    a=1\n    while a<=n:\n        base=result=combiner(base,term(a))\n        a+=1\n    return result\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    while a <= n:                          =>           \r\n        result = combiner(term(a), result) =>           \r\n    while(a <= n):                         <=           \r\n        result = combiner(base, term(a))   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        base = result = combiner(base, term(a))\r\n        a += 1\r\n    return result", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "result": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        15, 
                        20
                    ]
                ]
            }
        }, 
        "Id": 526, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        result = combiner(base, term(a))\r\n        a += 1\r\n    return result"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    num=1\n    x=term(1)\n    while num<=n:\n        x=combiner(x,term(num+1))\n        num+=1\n    if combiner==mul:\n        return combiner(x,base)/term(n+1)\n    else:\n        return combiner(x,base)-term(n+1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) // term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "72.0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     72.0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    num=1\n    x=term(1)\n    while num<=n:\n        x=combiner(x,term(num+1))\n        num+=1\n    if combiner==mul:\n        return combiner(x,base)/term(n+1)\n    else:\n        return combiner(x,base)-term(n+1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return combiner(x, base) // term(n+1) =>           \r\n        return combiner(x, base) / term(n+1)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 527, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return term(n)+accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "16\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "16", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 528, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return term(n)+accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    t = combiner(t, term(term_iteration))", 
            "UnboundLocalError: local variable 't' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        base = combiner(base, term(term_iteration))\n        term_iteration += 1\n    return base\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        base = combiner(base, term(term_iteration)) =>           \r\n    return base                                     =>           \r\n        t = combiner(t, term(term_iteration))       <=           \r\n    return t                                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 529, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        t = combiner(t, term(term_iteration))\n        term_iteration += 1\n    return t\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n   \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(term(n), accumulate(base, n-1, term))", 
            "TypeError: accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n-1, term))           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 530, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "None\n", 
            "print accumulate(add, 11, 0, identity)": "None\n", 
            "print accumulate(add, 11, 5, identity)": "None\n", 
            "print accumulate(mul, 2, 3, square)": "None\n", 
            "print accumulate(add, 11, 3, square)": "None\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    \n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return      <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 531, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n - 1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n <= 1:                         =>           \r\n        return term(n)                 =>           \r\n    if n <= 1:                         =>           \r\n        return combiner(term(n), base) =>           \r\n    if n == 1:                         <=           \r\n        return term(1)                 <=           \r\n    if n == 1:                         <=           \r\n        return combiner(term(1), base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 532, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate", 
            "    total = total + combiner(total, term(n))", 
            "UnboundLocalError: local variable 'total' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, term(n))                                    =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n        return combiner(total, base)                                      <=           \r\n        total = total + combiner(total, term(n))                          <=           \r\n        return accumulate(combiner, base, n - 1, term, 0)                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 533, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(total, base)\n    else:\n        total = total + combiner(total, term(n))\n        return accumulate(combiner, base, n - 1, term, 0)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    total,x = BASE, 1", 
            "NameError: name 'BASE' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = base, 1\n    while x<=n:\n        total = combiner(term(x), total)\n        x = x+1\n    return total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 534, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = BASE, 1\n    while x<=n:\n        total = COMBINER(term(x), total)\n        x = x+1\n    return total\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "8\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n + 1:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<n+1:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    while counter < n + 1: =>           \r\n    while counter < n:     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        8
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2
                    ]
                ]
            }, 
            "counter": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 535, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 536, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner( base , term(n))\n    else:\n        return combiner(term(n) , accumulate(combiner, base, n-1, term))    \nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "0", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 537, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     ", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n==0:                                                            =>           \r\n        return base                                                     =>           \r\n    else:                                                               =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\nfrom operator import add, mul                                           <=           \r\ndef accumulate_helper(term,n):                                          <=           \r\n        if n >= 0:                                                      <=           \r\n            return term(n) * n-1                                        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 1, 
        "Id": 538, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\ndef accumulate_helper(term,n):\n        if n >= 0:\n            return term(n) * n-1\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    i=1\n    def counter(i):\n        if i<n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i>n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    i=1\n    def counter(i):\n        if n<i:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n        if i>n: =>           \r\n        if i<n: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if n<i:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "x": {}
        }, 
        "Id": 539, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if i<n:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    x=1\n    while not x>n:\n        total=combiner(total,term(x))\n        x+=1\n    final=combiner(base,total)\n    return final\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    x = 1\n    while not x > n:\n        total = combiner(total, term(x))\n        x += 1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=0\n    x=1\n    while not x>n:\n        base=combiner(base,term(x))\n        x+=1\n    final=combiner(base,total)\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = 0                     <=           \r\n    final = combiner(base, total) <=           \r\n    return final                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        base = combiner(base, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 540, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return final"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def counter(i,total=base):\n        print total\n        if i==n:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            return counter(i+1,total+combiner(total,term(i)))\n    return counter(1)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n1\n3\n6\n10\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n12\n14\n17\n21\n26\n", 
            "print accumulate(mul, 2, 3, square)": "2\n2\n8\n72\n", 
            "print accumulate(add, 11, 3, square)": "11\n12\n16\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n1\n4\n11\n26\n31\n", 
            "print accumulate(add, 11, 0, identity)": "11\n11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n23\n48\n99\n202\n207\n", 
            "print accumulate(mul, 2, 3, square)": "2\n4\n20\n180\n", 
            "print accumulate(add, 11, 3, square)": "11\n23\n50\n59\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i, total = base):\n        if i == n:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total\n        else:\n            return counter(i + 1, combiner(total, term(i)))\n    return counter(1)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "1", 
            "4", 
            "11", 
            "26", 
            "31", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "#     1", 
            "#     4", 
            "#     11", 
            "#     26", 
            "#     31", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def counter(i,total=base):\n        print total\n        if i==n:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            return counter(i+1,total=combiner(total,term(i)))\n    return counter(1)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n            return counter(i + 1, combiner(total, term(i)))         =>           \r\n        print(total)                                                <=           \r\n            return counter(i + 1, total + combiner(total, term(i))) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, \r\n            total = combiner(total, term(i)))\r\n    return counter(1)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        6, 
                        3, 
                        1, 
                        0
                    ], 
                    [
                        0, 
                        1, 
                        4, 
                        11, 
                        26, 
                        11, 
                        4, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        2
                    ], 
                    [
                        2, 
                        4, 
                        20, 
                        4, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        17, 
                        14, 
                        12, 
                        11
                    ], 
                    [
                        11, 
                        23, 
                        48, 
                        99, 
                        202, 
                        99, 
                        48, 
                        23, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        12, 
                        11
                    ], 
                    [
                        11, 
                        23, 
                        50, 
                        23, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 541, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, total+combiner(total, term(i)))\r\n    return counter(1)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 542, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    from operator import add, mul", 
            "RecursionError: maximum recursion depth exceeded", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n    if n == 1:                                                            =>           \r\n        return combiner(base, term(n))                                    =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))       =>           \r\n    if base == 0:                                                         <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   <=           \r\n    return combiner(base, term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 543, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    if base == 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    return combiner(base, term(n), accumulate(combiner, base, n-1, term))\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(n - 1))", 
            "TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(n - 1))                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 544, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 545, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "10\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "21\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "16\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "10", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     10", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<n+1:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<n+1:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        1
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        16
                    ]
                ]
            }
        }, 
        "Id": 546, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return accumualte(combiner, combiner(base, term(n)), n-1, term)", 
            "NameError: name 'accumualte' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumualte(combiner, combiner(base, term(n)), n-1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 547, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumualte(combiner, combiner(base, term(n)), n-1, term)\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    if combiner == mul:\n        v = 1\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if combiner == mul:           =>           \r\n        v = 1                     =>           \r\n    return accumulate(n, term(x)) =>           \r\n    return _______                <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 548, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 549, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "9\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "9\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "13\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 550, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n    return total\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k = increment(k)\n    return total\n\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        k = increment(k) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6, 
                        7, 
                        8, 
                        9, 
                        10, 
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        12, 
                        13, 
                        14, 
                        15, 
                        16, 
                        17, 
                        18, 
                        19, 
                        20, 
                        21, 
                        22, 
                        23, 
                        24, 
                        25, 
                        26, 
                        27, 
                        28, 
                        29, 
                        30, 
                        31, 
                        32, 
                        33, 
                        34, 
                        35, 
                        36, 
                        37, 
                        38, 
                        39, 
                        40, 
                        41, 
                        42, 
                        43, 
                        44, 
                        45, 
                        46, 
                        47, 
                        48, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        58, 
                        59, 
                        60, 
                        61, 
                        62, 
                        63, 
                        64, 
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        87, 
                        88, 
                        89, 
                        90, 
                        91, 
                        92, 
                        93, 
                        94, 
                        95, 
                        96, 
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108
                    ]
                ]
            }
        }, 
        "Id": 551, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n    return total\r\nfrom operator import add, mul"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    b=base\n    c=combiner\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(c(total,term(k)),k+1)\n    return c(b,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = base, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    b=base\n    c=combiner\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(c(total,term(k)),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    return total       =>           \r\n    total, k = 0, 1    <=           \r\n    return c(b, total) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 552, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return c(b, total)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "11", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     11", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n    \ttotal, k = combiner(total,term(k)), k+1\n    return total\n   \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    total, k = base, 1                               =>           \r\n    while k <= n:                                    =>           \r\n        total, k = combiner(total,term(k)), k+1      =>           \r\n    return total                                     =>           \r\n    k = 1                                            <=           \r\n    while k <= n+1:                                  <=           \r\n        total, k = combiner(term(k), term(k+1)), k+2 <=           \r\n    return combiner(total, base)                     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 553, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n+1:\n    \ttotal, k = combiner(term(k), term(k+1)), k+2\n    return combiner(total, base)\n   \n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=0\n    while base<=n:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "0\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "0\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 1:                        =>           \r\n        base = combiner(base, term(n))   =>           \r\n                                         =>           \r\n    total = 0                            <=           \r\n        total = combiner(total, term(n)) <=           \r\n    return total                         <=           \r\n        base = combiner(base, term(i))   <=           \r\n        i += 1                           <=           \r\n    while base <= n:                     <=           \r\n    i = 1                                <=           \r\n    while i <= n:                        <=           \r\n    \"\"\"                                  <=           \r\n    \"\"\"                                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 554, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    while base<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    return combiner( base, accumulate(combiner, 0, n, term) )", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    if n == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) )\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                  SideIndicator\r\n-----------                                                                  -------------\r\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) ) =>           \r\n        return combiner( base, accumulate(combiner, 0, n, term) )            <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 555, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( base, accumulate(combiner, 0, n, term) )\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i= i + 1\n    return base\n\n\n    \"*** YOUR CODE HERE ***\"\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    i = 1                                                      =>           \r\n    while i <= n:                                              =>           \r\n        base = combiner(base, term(i))                         =>           \r\n        i= i + 1                                               =>           \r\n    return base                                                =>           \r\n    if combiner == add:                                        <=           \r\n        if n == 0:                                             <=           \r\n            return base                                        <=           \r\n        if n>0:                                                <=           \r\n            return accumulate(combiner, base, term(n-1), term) <=           \r\n    if combiner == mul:                                        <=           \r\n        return base + factorial(n)                             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 556, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n == 0:\n            return base\n        if n>0:\n            return accumulate(combiner, base, term(n-1), term)\n    if combiner == mul:\n        return base + factorial(n)\n\n\n    \"*** YOUR CODE HERE ***\"\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate", 
            "    else: return combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate", 
            "    if n==base: return base", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if n==0: return base    =>           \r\n    if n==base: return base <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 557, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 558, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        # (base, term(n))\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        # (base, term(n))                                               =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 559, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return start\n    else:\n        start=combiner(term(n),start)\n        return accumulate(combiner,start,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    start = combiner(term(n), start)", 
            "UnboundLocalError: local variable 'start' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,start,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return base                                   =>           \r\n        base = combiner(term(n), base)                =>           \r\n        return accumulate(combiner, base, n-1, term)  =>           \r\n        return start                                  <=           \r\n        start = combiner(term(n), start)              <=           \r\n        return accumulate(combiner, start, n-1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, start, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5, 
                        0
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16, 
                        11
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 560, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return start\r\n    else:\r\n        start = combiner(term(n), start)\r\n        return accumulate(combiner, start, n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def whatever(n):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),whatever(n-1))\n    return combiner(base,whatever(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n <= 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever", 
            "    return combiner(term(n), whatever(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in whatever", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def whatever(n):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),whatever(n-1))\n    return combiner(base,whatever(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 561, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "2 0 2", 
            "3 2 3", 
            "4 5 4", 
            "5 9 5", 
            "6 14 6", 
            "20", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     2 0 2", 
            "#     3 2 3", 
            "#     4 5 4", 
            "#     5 9 5", 
            "#     6 14 6", 
            "#     20", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    while count <= n:\n        \"\"\"\n        if combiner == add:\n            base += term(count)\n            count += 1\n        if combiner == mul:\n            base *= term(count)\n            count += 1\"\"\"\n        base = combiner(base,term(count))\n        count+=1\n\n    return base\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        print(count,base,term(count)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 562, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    while count <= n:\n        \"\"\"\n        if combiner == add:\n            base += term(count)\n            count += 1\n        if combiner == mul:\n            base *= term(count)\n            count += 1\"\"\"\n        count+=1\n        print(count,base,term(count))\n        base = combiner(base,term(count))\n\n    return base\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    # if combiner == add:\n    #     total = base\n    while n > 0:\n        if combiner == add:\n            total += term(n)\n        if combiner == mul:\n            total *= term(n)\n        n -= 1\n    return total\n\n\n\nfrom operator import add, mul\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    total = base                                                       =>           \r\n    # if combiner == add:                                              =>           \r\n    #     total = base                                                 =>           \r\n    while n > 0:                                                       =>           \r\n            total += term(n)                                           =>           \r\n            total *= term(n)                                           =>           \r\n        n -= 1                                                         =>           \r\n    # total = base                                                     <=           \r\n    # start = 0                                                        <=           \r\n    # start1 = 1                                                       <=           \r\n    # mul = [base]                                                     <=           \r\n    # total1 = 1                                                       <=           \r\n    #     return base                                                  <=           \r\n    # elif start <= n:                                                 <=           \r\n    #     if combiner == add:                                          <=           \r\n    #         total += combiner(term(start), term(start + 1))          <=           \r\n    #         start += 2                                               <=           \r\n    # return total                                                     <=           \r\n    # elif start1 <= n:                                                <=           \r\n    #             mul = [base]                                         <=           \r\n    #             mul.append(combiner(term(start1), term(start1 + 1))) <=           \r\n    #             start1 += 2                                          <=           \r\n    #             total1 *= mul[:]                                     <=           \r\n    # return total1                                                    <=           \r\n    total = 1                                                          <=           \r\n    if combiner == add:                                                <=           \r\n        total = 0                                                      <=           \r\n    while base <= n:                                                   <=           \r\n            total += term(base)                                        <=           \r\n            base += 1                                                  <=           \r\n            total *= term(base)                                        <=           \r\n            base += 1                                                  <=           \r\n    # if n == 0:                                                       <=           \r\n                                                                       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 563, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # total = base\n    # start = 0\n    # start1 = 1\n    # mul = [base]\n    # total1 = 1\n    # if n == 0:\n    #     return base\n    # elif start <= n:\n    #     if combiner == add:\n    #         total += combiner(term(start), term(start + 1))\n    #         start += 2\n    # return total\n    # elif start1 <= n:\n    #             mul = [base]\n    #             mul.append(combiner(term(start1), term(start1 + 1)))\n    #             start1 += 2\n    #             total1 *= mul[:]\n    # return total1\n\n    total = 1\n    if combiner == add:\n        total = 0\n    while base <= n:\n        if combiner == add:\n            total += term(base)\n            base += 1\n        if combiner == mul:\n            total *= term(base)\n            base += 1\n    return total\n\n\n\nfrom operator import add, mul\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=1\n    total=term(k)\n    if n==0:\n        return base\n    while k<n:\n        (k,total)=(k+1,combiner(total,term(k+1)))\n    return combiner(base,total)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2", 
            "Traceback (most recent call last):", 
            "    accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2", 
            "                                     ^", 
            "SyntaxError: invalid syntax", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     SyntaxError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=1\n    total=term(k)\n    if n==0:\n        return base\n    while k<n:\n        (k,total)=(k+1,combiner(total,term(k+1)))\n    return combiner(base,total)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2  =>           \r\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 564, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulator(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return accumulator(combiner, base, n - 1, term)", 
            "NameError: name 'accumulator' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n        return accumulate(combiner, base, n - 1, term)  =>           \r\n        return accumulator(combiner, base, n - 1, term) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        12, 
                        9, 
                        5
                    ], 
                    [
                        0, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        2, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        23, 
                        20, 
                        16
                    ], 
                    [
                        11, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        20
                    ], 
                    [
                        11, 
                        20
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 565, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulator(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "13", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     13", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(term(k), total)\n        k = k + 1\n\n    return total\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total = base                                   =>           \r\n        total = combiner(term(k), total)           =>           \r\n    return accumulate(add, 0, n, term)             =>           \r\n    total = 0                                      <=           \r\n        if k == 1:                                 <=           \r\n            total = combiner(base, term(k+1))      <=           \r\n        else:                                      <=           \r\n            total = combiner(term(k+1), term(k+2)) <=           \r\n    return _______                                 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 566, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = 0\n    while k <= n:\n        if k == 1:\n            total = combiner(base, term(k+1))\n        else:\n            total = combiner(term(k+1), term(k+2))\n        k = k + 1\n\n    return total\n\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tif combiner == add:\n    \t\tresult = 0\n    \tif combiner == mul:\n    \t\tresult = 1\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == add: =>           \r\n            result = 0      =>           \r\n        if combiner == mul: =>           \r\n            result = 1      =>           \r\n        result = 0          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 567, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tresult = 0\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation,term(i))\n    return accumulation\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    return accumulation", 
            "UnboundLocalError: local variable 'accumulation' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation,term(i))\n    return accumulation\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        accumulation=combiner(base,term(0))   =>           \r\n        accumulutation=combiner(base,term(0)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 568, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def helper(i,total,combiner,base,n,term):\n        if n<=1:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total,combiner,base,n-1,term)\n    return helper(1,base,combiner,base,n,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n == 0:\n            return total \n        elif n <= 1:\n            return combiner(total, term(i))\n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "12", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     12", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def helper(i,total,combiner,base,n,term):\n        if n<=1:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total,combiner,base,n-1,term)\n    if n==0:\n        return base\n    return helper(1,base,combiner,base,n,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n == 0:   =>           \r\n        elif n <= 1: =>           \r\n        if n <= 1:   <=           \r\n        elif n == 0: <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    if n==0:\r\n        return base\r\n    return helper(1, base, combiner, base, n, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {}, 
            "x": {}, 
            "total": {}
        }, 
        "Id": 569, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    return helper(1, base, combiner, base, n, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n -= 1\n    return x\n\n\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 570, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n += 1\n    return x\n\n\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,n),n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "12\n", 
            "print accumulate(add, 11, 3, square)": "17\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "17", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     17", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,term(n)),n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumulate(combiner, combiner(base, n), n-1, term)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "base": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20, 
                        11
                    ], 
                    [
                        11, 
                        14, 
                        16, 
                        17, 
                        16, 
                        14, 
                        11
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18, 
                        2
                    ], 
                    [
                        2, 
                        6, 
                        12, 
                        6, 
                        2
                    ]
                ]
            }
        }, 
        "Id": 571, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, n), n-1, term)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    n=n-1\n    if n<1:\n        return total\n    else:\n        return accumulate(combiner,total,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "9\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "20\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "21\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n, term)      \n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    n=n-1\n    if n<1:\n        return total\n    else:\n        return combiner(term(n),accumulate(combiner,total,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return accumulate(combiner, total, n, term)         =>           \r\n        return accumulate(combiner, total, n-1, term)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, total, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        3, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        3, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 572, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return accumulate(combiner, total, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    total = combiner(term, total)", 
            "TypeError: unsupported operand type(s) for +: 'function' and 'int'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term(i), total)\n    return total\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(i), total) =>           \r\n        total = combiner(term, total)    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 573, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term, total)\n    return total\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "21", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     21", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    ans = base\n    while (counter <= n):\n\n        ans = combiner(ans, term(counter))\n        counter += 1\n    return ans\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n                =>           \r\n    counter = 0 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 574, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    ans = base\n    while (counter <= n):\n        counter += 1\n        ans = combiner(ans, term(counter))\n    return ans\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    sum, k = combiner(term(k), sum), i+1", 
            "UnboundLocalError: local variable 'k' referenced before assignment", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     UnboundLocalError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, i = combiner(term(i), sum), i+1\n    return sum\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        sum, i = combiner(term(i), sum), i+1 =>           \r\n        sum, k = combiner(term(k), sum), i+1 <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 575, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, k = combiner(term(k), sum), i+1\n    return sum\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    acc_sum=base\n    index=1\n    while index<=n:\n        acc_sum=combiner(acc_sum,term(n))\n        index+=1\n    return acc_sum\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(index))\n        index += 1 \n    return acc_sum \n\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    acc_sum=base\n    k=1\n    while k<=n:\n        acc_sum=combiner(acc_sum,term(k))\n        k+=1\n    return acc_sum\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        acc_sum = combiner(acc_sum, term(index)) =>           \r\n        acc_sum = combiner(acc_sum, term(n))     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    k = 1\r\n    while k<=n:\r\n        acc_sum = combiner(acc_sum, term(k))\r\n        k += 1\r\n    return acc_sum", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "acc_sum": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 576, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    index = 1\r\n    while index<=n:\r\n        acc_sum = combiner(acc_sum, term(n))\r\n        index += 1\r\n    return acc_sum"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "15\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "14\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<= n:\n        total, k = combiner(total, term (k)), k+1\n    return total\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n    total, k = base, 1                            =>           \r\n        total, k = combiner(total, term (k)), k+1 =>           \r\n    total, k = 0, 1                               <=           \r\n        total, k = combiner(term(k), total), k+1  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0, 
                        1, 
                        5, 
                        14
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 577, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    k=term(base)\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=base       =>           \r\n    k=term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = base\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "k": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        121, 
                        122, 
                        126, 
                        135
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        4, 
                        16, 
                        144
                    ]
                ]
            }
        }, 
        "Id": 578, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    k = term(base)\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def sequence(combiner,n,term):\n        if n==0:\n            return 0\n        return combiner(term(n),sequence(combiner,n-1,term))\n    return combiner(base,sequence(combiner,n,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        if n == 1:\n            return term(1)\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def sequence(combiner,n,term):\n        if n==0:\n            return base\n        return combiner(term(n),sequence(combiner,n-1,term))\n    return sequence(combiner,n,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if n == 1:             =>           \r\n        return term(1)     =>           \r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n    if n == 0:             <=           \r\n        return 1           <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return base\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return sequence(combiner, n, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 579, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return 0\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return combiner(base, sequence(combiner, n, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\nfrom operator import add, mul\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 580, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            if combiner(term(a),b)==0:\n                b=combiner(term(a),1)\n                b=combiner(term(a),b)\n                return value(a+1,b)\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n            if combiner(term(a),b)==0: =>           \r\n                b=combiner(term(a),1)  =>           \r\n                b=combiner(term(a),b)  =>           \r\n                return value(a+1,b)    =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 581, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n-1, term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate", 
            "    return accumulate(combiner, base, n, term)", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n == 0:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return accumulate(combiner, base, n-1, term) =>           \r\n        return accumulate(combiner, base, n, term)   <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        5, 
                        9, 
                        12, 
                        14, 
                        15, 
                        14, 
                        12, 
                        9, 
                        5
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25, 
                        30, 
                        35, 
                        40, 
                        45, 
                        50, 
                        55, 
                        60, 
                        65, 
                        70, 
                        75, 
                        80, 
                        85, 
                        90, 
                        95, 
                        100, 
                        105, 
                        110, 
                        115, 
                        120, 
                        125, 
                        130, 
                        135, 
                        140, 
                        145, 
                        150, 
                        155, 
                        160, 
                        165, 
                        170, 
                        175, 
                        180, 
                        185, 
                        190, 
                        195, 
                        200, 
                        205, 
                        210, 
                        215, 
                        220, 
                        225, 
                        230, 
                        235, 
                        240, 
                        245, 
                        250, 
                        255, 
                        260, 
                        265, 
                        270, 
                        275, 
                        280, 
                        285, 
                        290, 
                        295, 
                        300, 
                        305, 
                        310, 
                        315, 
                        320, 
                        325, 
                        330, 
                        335, 
                        340, 
                        345
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        18, 
                        72, 
                        18
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458, 
                        13122, 
                        118098, 
                        1062882, 
                        9565938, 
                        86093442, 
                        774840978, 
                        6973568802, 
                        62762119218, 
                        564859072962, 
                        5083731656658, 
                        45753584909922, 
                        411782264189298, 
                        3706040377703682, 
                        33354363399333138, 
                        300189270593998242, 
                        2701703435345984178, 
                        24315330918113857602, 
                        218837978263024718418, 
                        1969541804367222465762, 
                        17725876239305002191858, 
                        159532886153745019726722, 
                        1435795975383705177540498, 
                        12922163778453346597864482, 
                        116299474006080119380780338, 
                        1046695266054721074427023042, 
                        9420257394492489669843207378, 
                        84782316550432407028588866402, 
                        763040848953891663257299797618, 
                        6867367640585024969315698178562, 
                        61806308765265224723841283607058, 
                        556256778887387022514571552463522, 
                        5006311009986483202631143972171698, 
                        45056799089878348823680295749545282, 
                        405511191808905139413122661745907538, 
                        3649600726280146254718103955713167842, 
                        32846406536521316292462935601418510578, 
                        295617658828691846632166420412766595202, 
                        2660558929458226619689497783714899356818, 
                        23945030365124039577205480053434094211362, 
                        215505273286116356194849320480906847902258, 
                        1939547459575047205753643884328161631120322, 
                        17455927136175424851782794958953454680082898, 
                        157103344225578823666045154630581092120746082, 
                        1413930098030209412994406391675229829086714738, 
                        12725370882271884716949657525077068461780432642, 
                        114528337940446962452546917725693616156023893778, 
                        1030755041464022662072922259531242545404215044002, 
                        9276795373176203958656300335781182908637935396018, 
                        83491158358585835627906703022030646177741418564162, 
                        751420425227272520651160327198275815599672767077458, 
                        6762783827045452685860442944784482340397054903697122, 
                        60865054443409074172743986503060341063573494133274098, 
                        547785489990681667554695878527543069572161447199466882, 
                        4930069409916135007992262906747887626149453024795201938, 
                        44370624689245215071930366160730988635345077223156817442, 
                        399335622203206935647373295446578897718105695008411356978, 
                        3594020599828862420826359659019210079462951255075702212802, 
                        32346185398459761787437236931172890715166561295681319915218, 
                        291115668586137856086935132380556016436499051661131879236962, 
                        2620041017275240704782416191425004147928491464950186913132658, 
                        23580369155477166343041745722825037331356423184551682218193922, 
                        212223322399294497087375711505425335982207808660965139963745298, 
                        1910009901593650473786381403548828023839870277948686259673707682, 
                        17190089114342854264077432631939452214558832501538176337063369138, 
                        154710802029085688376696893687455069931029492513843587033570322242, 
                        1392397218261771195390272043187095629379265432624592283302132900178
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        16, 
                        20, 
                        23, 
                        25, 
                        26, 
                        25, 
                        23, 
                        20, 
                        16
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36, 
                        41, 
                        46, 
                        51, 
                        56, 
                        61, 
                        66, 
                        71, 
                        76, 
                        81, 
                        86, 
                        91, 
                        96, 
                        101, 
                        106, 
                        111, 
                        116, 
                        121, 
                        126, 
                        131, 
                        136, 
                        141, 
                        146, 
                        151, 
                        156, 
                        161, 
                        166, 
                        171, 
                        176, 
                        181, 
                        186, 
                        191, 
                        196, 
                        201, 
                        206, 
                        211, 
                        216, 
                        221, 
                        226, 
                        231, 
                        236, 
                        241, 
                        246, 
                        251, 
                        256, 
                        261, 
                        266, 
                        271, 
                        276, 
                        281, 
                        286, 
                        291, 
                        296, 
                        301, 
                        306, 
                        311, 
                        316, 
                        321, 
                        326, 
                        331, 
                        336, 
                        341, 
                        346, 
                        351, 
                        356
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        20, 
                        24, 
                        25, 
                        24, 
                        20
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38, 
                        47, 
                        56, 
                        65, 
                        74, 
                        83, 
                        92, 
                        101, 
                        110, 
                        119, 
                        128, 
                        137, 
                        146, 
                        155, 
                        164, 
                        173, 
                        182, 
                        191, 
                        200, 
                        209, 
                        218, 
                        227, 
                        236, 
                        245, 
                        254, 
                        263, 
                        272, 
                        281, 
                        290, 
                        299, 
                        308, 
                        317, 
                        326, 
                        335, 
                        344, 
                        353, 
                        362, 
                        371, 
                        380, 
                        389, 
                        398, 
                        407, 
                        416, 
                        425, 
                        434, 
                        443, 
                        452, 
                        461, 
                        470, 
                        479, 
                        488, 
                        497, 
                        506, 
                        515, 
                        524, 
                        533, 
                        542, 
                        551, 
                        560, 
                        569, 
                        578, 
                        587, 
                        596, 
                        605, 
                        614, 
                        623, 
                        632
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 582, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            if n == 1:\n                return term(1)\n            else:\n                return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            if n == 1:                                       =>           \r\n                return term(1)                               =>           \r\n            else:                                            =>           \r\n                return combiner(term(n), rec_n((n-1), term)) =>           \r\n            return combiner(term(n), rec_n((n-1), term))     <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 583, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        print base\n        return base\n    else:\n        print(n,term(n),combiner(n,term(n)))\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n0\n15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n11\n", 
            "print accumulate(add, 11, 5, identity)": "(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n11\n26\n", 
            "print accumulate(mul, 2, 3, square)": "(3, 9, 27)\n(2, 4, 8)\n(1, 1, 1)\n2\n72\n", 
            "print accumulate(add, 11, 3, square)": "(3, 9, 12)\n(2, 4, 6)\n(1, 1, 2)\n11\n25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n11\n", 
            "print accumulate(add, 11, 5, identity)": "(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n11\n", 
            "print accumulate(mul, 2, 3, square)": "(3, 9, 27)\n(2, 4, 8)\n(1, 1, 1)\n2\n", 
            "print accumulate(add, 11, 3, square)": "(3, 9, 12)\n(2, 4, 6)\n(1, 1, 2)\n11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5 5 10", 
            "4 4 8", 
            "3 3 6", 
            "2 2 4", 
            "1 1 2", 
            "0", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate", 
            "    combiner(term(n),accumulate(combiner,base,n-1,term))", 
            "TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        print base\n        return base\n    else:\n        print(n,term(n),combiner(n,term(n)))\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        print(base)                                                 <=           \r\n        print(n,term(n),combiner(n,term(n)))                        <=           \r\n        combiner(term(n),accumulate(combiner,base,n-1,term))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 584, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n:\n        base = combiner(base, term(k))\n        k = k + 1\n    return base\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    k = 1                               =>           \r\n        base = combiner(base, term(k))  =>           \r\n    return base                         =>           \r\n    total, k = base , 1                 <=           \r\n        total = combiner(base, term(k)) <=           \r\n    return combiner( base, total)       <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 585, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base , 1\n    while k <= n:\n        total = combiner(base, term(k))\n        k = k + 1\n    return combiner( base, total)\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    base = combiner(base, (n ** term))", 
            "TypeError: unsupported operand type(s) for ** or pow(): 'int' and 'function'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        base = combiner(base, term(n))     =>           \r\n        base = combiner(base, (n ** term)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 586, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, (n ** term))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n\n"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "38", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     38", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return combiner(base, accumulator(combiner, n, term, 1))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n        return combiner(base, accumulator(combiner, n, term, 1)) =>           \r\n        return base + accumulator(combiner, n, term, 1)          <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 587, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return base + accumulator(combiner, n, term, 1)\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "0", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ]
            }
        }, 
        "Id": 588, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if combiner(0,7)!=0:\n        count_choice=0\n    else:\n        count_choice=1\n    def counter(combiner,base,n,term,total,count):\n        if count<=n:\n            placeholder=int(term(count))\n            total=combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n    return counter(combiner,base,n,term,1,count_choice)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        total_choice = 0\n    else:\n        total_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,total_choice,1)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if combiner(0,7)!=0:\n        count_choice=0\n    else:\n        count_choice=1\n    def counter(combiner,base,n,term,total,count):\n        if count<=n:\n            placeholder=int(term(count))\n            total=combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return total\n    return counter(combiner,base,n,term,base,count_choice)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        total_choice = 0                                 =>           \r\n        total_choice = 1                                 =>           \r\n    return  counter(combiner,base,n,term,total_choice,1) =>           \r\n        count_choice = 0                                 <=           \r\n        count_choice = 1                                 <=           \r\n    return  counter(combiner,base,n,term,1,count_choice) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return total\r\n    return counter(combiner, base, n, term, base, count_choice)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15, 
                        10, 
                        6, 
                        3, 
                        1, 
                        0
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16, 
                        11, 
                        7, 
                        4, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26, 
                        21, 
                        17, 
                        14, 
                        12, 
                        11
                    ], 
                    [
                        1, 
                        2, 
                        4, 
                        7, 
                        11, 
                        16, 
                        11, 
                        7, 
                        4, 
                        2, 
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72, 
                        8, 
                        2
                    ], 
                    [
                        1, 
                        4, 
                        36, 
                        4, 
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25, 
                        16, 
                        12, 
                        11
                    ], 
                    [
                        1, 
                        2, 
                        6, 
                        15, 
                        6, 
                        2, 
                        1
                    ]
                ]
            }
        }, 
        "Id": 589, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return combiner(base, total)\r\n    return counter(combiner, base, n, term, 1, count_choice)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "0\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "11\n", 
            "print accumulate(mul, 2, 3, square)": "2\n", 
            "print accumulate(add, 11, 3, square)": "11\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base= combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        base= combiner(term(n),base) =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {}, 
        "Id": 590, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "25", 
            ">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2", 
            "2", 
            "", 
            "# Error: expected", 
            "#     72", 
            "# but got", 
            "#     2", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, total, i=1):\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, total, i+1)\n\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    return combiner(base, function(combiner, n,term, total))\n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n    def function(operation, n, term, total, i=1):            =>           \r\n        return function(operation, n, term, total, i+1)      =>           \r\n    if combiner == mul:                                      =>           \r\n        total = 1                                            =>           \r\n        total = 0                                            =>           \r\n    return combiner(base, function(combiner, n,term, total)) =>           \r\n    else:                                                    =>           \r\n                                                             =>           \r\n    def function(operation, n, term, i=1, total=0):          <=           \r\n        if operation == mul:                                 <=           \r\n            total=1                                          <=           \r\n        return function(operation, n, term, i+1, total)      <=           \r\n                                                             <=           \r\n    return combiner(base, function(combiner, n,term))        <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 591, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, i=1, total=0):\n        if operation == mul:\n            total=1\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, i+1, total)\n    \n    return combiner(base, function(combiner, n,term))\n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def terms(func,m):\n        if m==n:\n            return func(m)\n        else:\n            return combiner(func(m),terms(func,m+1))\n    return combiner(base,terms(term,1))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    if n <= 0:\n        return base\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms", 
            "    return combiner(func(m), terms(func, m + 1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in terms", 
            "    if m == n:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    def terms(func,m):\n        if m==n:\n            return func(m)\n        else:\n            return combiner(func(m),terms(func,m+1))\n    if n==0:\n        return base\n    return combiner(base,terms(term,1))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n <= 0:      =>           \r\n        return base =>           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, terms(term, 1))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "m": {}
        }, 
        "Id": 592, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    return combiner(base, terms(term, 1))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(accumulate(combiner,base,n-1,term)),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "36864\n", 
            "print accumulate(add, 11, 3, square)": "221652553\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "221652553", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     221652553", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))       =>           \r\n    return accumulate(add, 0, n, term)                                          =>           \r\n    return accumulate(mul, 1, n, term)                                          =>           \r\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n)) <=           \r\n    return _______                                                              <=           \r\n    return _______                                                              <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        6, 
                        4, 
                        10, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        1, 
                        4, 
                        2, 
                        64, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        14, 
                        3, 
                        17, 
                        4, 
                        21, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        11, 
                        1, 
                        122, 
                        2, 
                        14888, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 593, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(accumulate(combiner, base, n-1, term)), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    def accumulate_func(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base,accumulate_func(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_func(n):\n        if(n==1):\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base, accumulate_func(n)) if n > 0 else base\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func", 
            "    return combiner(term(n),accumulate_func(n-1))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_func", 
            "    if(n==1):", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accumulate_func(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base,accumulate_func(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    return combiner(base, accumulate_func(n)) if n > 0 else base =>           \r\n    return combiner(base, accumulate_func(n))                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80
                    ]
                ]
            }
        }, 
        "Id": 594, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    x=base\n    i=1\n    while i<=n:\n        x=combiner(base,term(i))\n        i+=1\n    return x\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "5\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "16\n", 
            "print accumulate(mul, 2, 3, square)": "18\n", 
            "print accumulate(add, 11, 3, square)": "20\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(x, term(i))\n        i += 1\n    return x\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "5", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     5", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    x=base\n    i=1\n    while i<=n:\n        base=combiner(base,term(i))\n        i+=1\n    return base\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        x = combiner(x, term(i))    =>           \r\n        x = combiner(base, term(i)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        0, 
                        2, 
                        0, 
                        3, 
                        0, 
                        4, 
                        0, 
                        5, 
                        0
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        1, 
                        2, 
                        3, 
                        2
                    ], 
                    [
                        2, 
                        1, 
                        2, 
                        8, 
                        3, 
                        18
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        1, 
                        11, 
                        2, 
                        11, 
                        3, 
                        11, 
                        4, 
                        11, 
                        5, 
                        11
                    ], 
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        13, 
                        3, 
                        14, 
                        4, 
                        15, 
                        5, 
                        16
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        1, 
                        11, 
                        2, 
                        11, 
                        3, 
                        11
                    ], 
                    [
                        11, 
                        1, 
                        12, 
                        2, 
                        15, 
                        3, 
                        20
                    ]
                ]
            }, 
            "base": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 595, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        x = combiner(base, term(i))\r\n        i += 1\r\n    return x"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combinder(total,term(count))\n        count+=1\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "", 
            "print accumulate(mul, 2, 3, square)": "", 
            "print accumulate(add, 11, 3, square)": ""
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count += 1\n\n    return total\n\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate", 
            "    total = combinder(total, term(count))", 
            "NameError: name 'combinder' is not defined", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     NameError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combiner(total,term(count))\n        count+=1\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(count))  =>           \r\n        total = combinder(total, term(count)) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count += 1\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "count": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        6
                    ], 
                    [
                        1
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3, 
                        4
                    ], 
                    [
                        1
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11
                    ]
                ]
            }
        }, 
        "Id": 596, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combinder(total, term(count))\r\n        count += 1\r\n    return total"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "16\n", 
            "print accumulate(add, 11, 0, identity)": "12\n", 
            "print accumulate(add, 11, 5, identity)": "27\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "26\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    elif n ==0:\n        return combiner(term(0), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "16", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     16", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 1:                         =>           \r\n    elif n ==0:                        =>           \r\n        return combiner(term(0), base) =>           \r\n    if n == 0:                         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}
        }, 
        "Id": 597, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     15", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n    \n\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    t, i = base, 1                       =>           \r\n        t = combiner(t, term(i))         =>           \r\n    return t                             =>           \r\n    return accumulate(combiner(n, term)) =>           \r\n    t, i = 1, 1                          <=           \r\n        t = term(i)                      <=           \r\n    return t * 3                         <=           \r\n    return _______                       <=           \r\n    \"*** YOUR CODE HERE ***\"             <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 598, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t = term(i)\n        i += 1\n    return t * 3\n    \n\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(term(i-1),term(i))\n    return total\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "9\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "9\n", 
            "print accumulate(mul, 2, 3, square)": "36\n", 
            "print accumulate(add, 11, 3, square)": "13\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i)) \n    return total\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "9", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     9", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(accumulate(combiner,base,i-1,term),term(i))\n    return total\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(i))      =>           \r\n        total = combiner(term(i-1), term(i))  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(accumulate(combiner, base, i-1, term), term(i))\r\n    return total", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "i": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        1, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }, 
            "total": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        6, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        6, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        0, 
                        1, 
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        1, 
                        3, 
                        5, 
                        7, 
                        9
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        0, 
                        4, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        17, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        17, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        11, 
                        12, 
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        1, 
                        3, 
                        5, 
                        7, 
                        9
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        11, 
                        12, 
                        16, 
                        11, 
                        12, 
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        1, 
                        5, 
                        13
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        0, 
                        5, 
                        1, 
                        0, 
                        1, 
                        5, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        5, 
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        5, 
                        4, 
                        0, 
                        4, 
                        1, 
                        0, 
                        1, 
                        4, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        4, 
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        0, 
                        5, 
                        1, 
                        0, 
                        1, 
                        5, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        5, 
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        5, 
                        4, 
                        0, 
                        4, 
                        1, 
                        0, 
                        1, 
                        4, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        4, 
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        0, 
                        3, 
                        1, 
                        0, 
                        1, 
                        3, 
                        2, 
                        0, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 599, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(term(i-1), term(i))\r\n    return total"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "1", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     1", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 1:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return base\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n >= 1:      =>           \r\n        return base =>           \r\n    if n >= 2:      <=           \r\n        return 1    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 600, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 2:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return 1\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    term_number=0\n    result=base\n    if combiner==add:\n        while term_number<n:\n            result+=term(term_number)\n        return result\n    elif combiner==mul:\n        while term_number<n:\n            result*=term(term_number)\n        return result\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=combiner(a,term(n))\n        return helper(a,n-1)\n    return helper(base,n)\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": null, 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": null, 
            "print accumulate(mul, 2, 3, square)": null, 
            "print accumulate(add, 11, 3, square)": null
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "# Error: evaluation exceeded 10 seconds.", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     Timeout", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    term_number=0\n    result=base\n    if add:\n        combiner==add\n    elif combiner==mul:\n        while term_number<n:\n            result*=term(term_number)\n        return result\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=combiner(a,term(n))\n        return helper(a,n-1)\n    return helper(base,n)\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    return accumulate(add, 0, n, term)                                            =>           \r\n    return accumulate(mul, 1, n, term)                                            =>           \r\n    return accumulate(lambda a,x: combiner(a,x) if pred(x) else a, base, n, term) =>           \r\n    term_number = 0                                                               <=           \r\n    result = base                                                                 <=           \r\n    if combiner == add:                                                           <=           \r\n        while term_number < n:                                                    <=           \r\n            result += term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    elif combiner == mul:                                                         <=           \r\n        while term_number < n:                                                    <=           \r\n            result *= term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    return accumulate(add, lambda base: base , n, term  )                         <=           \r\n    return _______                                                                <=           \r\n    return _______                                                                <=           \r\n                                                                                  <=           \r\n                                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                      <=           \r\n                                                                                  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if add:combiner==add\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        0
                    ]
                ]
            }, 
            "result": {
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2
                    ], 
                    [
                        2, 
                        0
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 601, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if combiner==add:\r\n        while term_number<n:\r\n            result += term(term_number)\r\n        return result\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    prev_term=0\n    for x in range(base,n+1):\n        current_term=term(x)\n        prev_term=combiner(current_term,prev_term)\n    return prev_term\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "0\n", 
            "print accumulate(add, 11, 5, identity)": "0\n", 
            "print accumulate(mul, 2, 3, square)": "0\n", 
            "print accumulate(add, 11, 3, square)": "0\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = base\n    for x in range (1, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "0", 
            "", 
            "# Error: expected", 
            "#     26", 
            "# but got", 
            "#     0", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    prev_term=base\n    for x in range(1,n+1):\n        current_term=term(x)\n        prev_term=combiner(current_term,prev_term)\n    return prev_term\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    prev_term = base            =>           \r\n    for x in range (1, n+1):    =>           \r\n    prev_term = 0               <=           \r\n    for x in range (base, n+1): <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = base\r\n    for x in range(1, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "current_term": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        4, 
                        9
                    ], 
                    [
                        4, 
                        9
                    ]
                ]
            }, 
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        2, 
                        3
                    ]
                ]
            }, 
            "prev_term": {
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        11
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        0
                    ]
                ]
            }
        }, 
        "Id": 602, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = 0\r\n    for x in range(base, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "144\n", 
            "print accumulate(add, 11, 3, square)": "135\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "11", 
            ">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2", 
            "135", 
            "", 
            "# Error: expected", 
            "#     25", 
            "# but got", 
            "#     135", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        11
                    ]
                ]
            }
        }, 
        "Id": 603, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    ans=base\n    for i in range(1,n+1):\n        ans=combiner(ans,term(n))\n    return ans\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "25\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "36\n", 
            "print accumulate(mul, 2, 3, square)": "1458\n", 
            "print accumulate(add, 11, 3, square)": "38\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(i));\n    return ans;\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "25", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     25", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    ans=base\n    for n in range(1,n+1):\n        ans=combiner(ans,term(n))\n    return ans\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        ans = combiner(ans, term(i)); =>           \r\n        ans = combiner(ans, term(n)); <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for n in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }, 
            "ans": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        0, 
                        1, 
                        3, 
                        6, 
                        10, 
                        15
                    ], 
                    [
                        0, 
                        5, 
                        10, 
                        15, 
                        20, 
                        25
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        2, 
                        8, 
                        72
                    ], 
                    [
                        2, 
                        18, 
                        162, 
                        1458
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        11, 
                        12, 
                        14, 
                        17, 
                        21, 
                        26
                    ], 
                    [
                        11, 
                        16, 
                        21, 
                        26, 
                        31, 
                        36
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        11, 
                        12, 
                        16, 
                        25
                    ], 
                    [
                        11, 
                        20, 
                        29, 
                        38
                    ]
                ]
            }, 
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3
                    ]
                ]
            }
        }, 
        "Id": 604, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for i in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans"
    }, 
    {
        "studentId": 0, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "Traceback (most recent call last):", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate", 
            "    return combiner(base,accumulate(combiner,n-1,term))", 
            "TypeError: accumulate() missing 1 required positional argument: 'term'", 
            "", 
            "# Error: expected", 
            "#     15", 
            "# but got", 
            "#     TypeError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,term(n)),n-1,term)\n", 
        "UsedFix": null, 
        "GeneratedFix": null, 
        "IsFixed": false, 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return accumulate(combiner,combiner(base,term(n)),n-1,term) =>           \r\n    if n==1:                                                        <=           \r\n        return combiner(base,term(n))                               <=           \r\n        return combiner(base,accumulate(combiner,n-1,term))         <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": null, 
        "ErrorFlag": 0, 
        "Id": 605, 
        "before": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(base,accumulate(combiner,n-1,term))\n"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "108\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    #if n == 1:\n        #return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate", 
            "    return combiner(accumulate(combiner, base, n - 1, term), term(n))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if n == 0:                 =>           \r\n        return base            =>           \r\n    #if n == 1:                =>           \r\n        #return base + term(1) =>           \r\n    if n == 1:                 <=           \r\n        return base + term(1)  <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "n": {
                "print accumulate(add, 0, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81, 
                        -82, 
                        -83, 
                        -84, 
                        -85, 
                        -86, 
                        -87, 
                        -88, 
                        -89, 
                        -90, 
                        -91, 
                        -92, 
                        -93, 
                        -94, 
                        -95, 
                        -96, 
                        -97, 
                        -98, 
                        -99, 
                        -100, 
                        -101, 
                        -102, 
                        -103, 
                        -104, 
                        -105, 
                        -106, 
                        -107, 
                        -108, 
                        -109, 
                        -110, 
                        -111, 
                        -112, 
                        -113, 
                        -114, 
                        -115, 
                        -116, 
                        -117, 
                        -118, 
                        -119, 
                        -120, 
                        -121, 
                        -122, 
                        -123, 
                        -124, 
                        -125, 
                        -126, 
                        -127, 
                        -128, 
                        -129, 
                        -130, 
                        -131, 
                        -132, 
                        -133, 
                        -134, 
                        -135, 
                        -136, 
                        -137, 
                        -138, 
                        -139, 
                        -140, 
                        -141, 
                        -142, 
                        -143, 
                        -144, 
                        -145, 
                        -146, 
                        -147, 
                        -148, 
                        -149, 
                        -150, 
                        -151, 
                        -152, 
                        -153, 
                        -154, 
                        -155, 
                        -156, 
                        -157, 
                        -158, 
                        -159, 
                        -160, 
                        -161, 
                        -162
                    ]
                ], 
                "print accumulate(add, 11, 5, identity)": [
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ], 
                    [
                        5, 
                        4, 
                        3, 
                        2, 
                        1, 
                        2, 
                        3, 
                        4, 
                        5
                    ]
                ], 
                "print accumulate(mul, 2, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ], 
                "print accumulate(add, 11, 3, square)": [
                    [
                        3, 
                        2, 
                        1, 
                        0, 
                        1, 
                        2, 
                        3
                    ], 
                    [
                        3, 
                        2, 
                        1, 
                        2, 
                        3
                    ]
                ]
            }
        }, 
        "Id": 606, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))"
    }, 
    {
        "tidy_before": "def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "studentId": 0, 
        "augmented_tidy_SynthesizedAfter_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": "11\n", 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "IsFixed": true, 
        "augmented_tidy_before_testcase_to_output": {
            "print accumulate(add, 0, 5, identity)": "15\n", 
            "print accumulate(add, 11, 0, identity)": null, 
            "print accumulate(add, 11, 5, identity)": "26\n", 
            "print accumulate(mul, 2, 3, square)": "72\n", 
            "print accumulate(add, 11, 3, square)": "25\n"
        }, 
        "after": "def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n", 
        "augmented_tidy_before": "REMOVED", 
        "UsedFix": "Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))", 
        "GeneratedFix": null, 
        "failed": [
            "=====================================================================", 
            "Assignment: Homework 2", 
            "OK, version v1.5.3", 
            "=====================================================================", 
            "", 
            "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", 
            "Running tests", 
            "", 
            "---------------------------------------------------------------------", 
            "Doctests for accumulate", 
            "", 
            ">>> from hw02 import *", 
            ">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5", 
            "15", 
            ">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5", 
            "26", 
            ">>> accumulate(add, 11, 0, identity) # 11", 
            "Traceback (most recent call last):", 
            "  ...", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate", 
            "    return combiner(term(n), accumulate(combiner, base, n-1, term))", 
            "  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate", 
            "    if n == 1:", 
            "RecursionError: maximum recursion depth exceeded in comparison", 
            "", 
            "# Error: expected", 
            "#     11", 
            "# but got", 
            "#     RecursionError", 
            "", 
            "---------------------------------------------------------------------", 
            "Test summary", 
            "    0 test cases passed before encountering first failed test case", 
            ""
        ], 
        "tidy_SynthesizedAfter": "def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n", 
        "augmented_tidy_SynthesizedAfter": "REMOVED", 
        "Time": 0, 
        "date": null, 
        "diff": "\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n", 
        "SynthesizedAfter": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))", 
        "ErrorFlag": 0, 
        "sequence_comparison_diff": {
            "x": {}, 
            "n": {
                "print accumulate(add, 11, 0, identity)": [
                    [
                        0
                    ], 
                    [
                        0, 
                        -1, 
                        -2, 
                        -3, 
                        -4, 
                        -5, 
                        -6, 
                        -7, 
                        -8, 
                        -9, 
                        -10, 
                        -11, 
                        -12, 
                        -13, 
                        -14, 
                        -15, 
                        -16, 
                        -17, 
                        -18, 
                        -19, 
                        -20, 
                        -21, 
                        -22, 
                        -23, 
                        -24, 
                        -25, 
                        -26, 
                        -27, 
                        -28, 
                        -29, 
                        -30, 
                        -31, 
                        -32, 
                        -33, 
                        -34, 
                        -35, 
                        -36, 
                        -37, 
                        -38, 
                        -39, 
                        -40, 
                        -41, 
                        -42, 
                        -43, 
                        -44, 
                        -45, 
                        -46, 
                        -47, 
                        -48, 
                        -49, 
                        -50, 
                        -51, 
                        -52, 
                        -53, 
                        -54, 
                        -55, 
                        -56, 
                        -57, 
                        -58, 
                        -59, 
                        -60, 
                        -61, 
                        -62, 
                        -63, 
                        -64, 
                        -65, 
                        -66, 
                        -67, 
                        -68, 
                        -69, 
                        -70, 
                        -71, 
                        -72, 
                        -73, 
                        -74, 
                        -75, 
                        -76, 
                        -77, 
                        -78, 
                        -79, 
                        -80, 
                        -81
                    ]
                ]
            }
        }, 
        "Id": 607, 
        "before": "\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))"
    }
]