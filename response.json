[{"Id":1,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n    \"\"\"while n > 0:\n        term(n) * product(term(n-1), term)\"\"\"\n\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n    \"\"\"while n > 0:\n        term(n) * product(term(n-1), term)\"\"\"\n\n    \"*** YOUR CODE HERE ***\"\n\n","Time":819,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":2,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n > 1:\n        total *= term(n)\n        n -= 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 1:\n        total *= term(n)\n        n -= 1\n    return total\n\n","Time":60,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    while n>1:\r\n        total *= term(n)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":3,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n    total = 1                =>           \r\n        total *= term(i)     =>           \r\n    total = 0                <=           \r\n        total *= i * term(i) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    i = 1\n    while i <= n:\n        total *= i * term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    i = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","Time":39,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(i) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(i) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(i) CallExpression(, *){ NameExpression(term) Arg(){ NameExpression(i) } } }), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(i) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":4,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, x = 1, 1 =>           \r\n    total, x = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 0, 1\n    while x <= n:\n        total, x = total * term(x), x +1\n    return total \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n    while x <= n:\n        total, x = total * term(x), x +1\n    return total \n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, x = 1, 1\r\n    while x<=n:\r\n        total, x = total*term(x), x+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":5,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    return helper(1,n) =>           \r\n    return helper(0,n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=a*term(n)\n        return helper(a,n-1)\n    return helper(0,n)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=a*term(n)\n        return helper(a,n-1)\n    return helper(1,n)\n","Time":136,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = a*term(n)\r\n        return helper(a, n-1)\r\n    return helper(1, n)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":6,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    count = 1\n    while count <= n:\n        total = total*term(count)\n        count = count + 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    count = 1\n    while count <= n:\n        total = total*term(count)\n        count = count + 1\n    return total\n\n\n","Time":63,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    count = 1\r\n    while count<=n:\r\n        total = total*term(count)\r\n        count = count+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":7,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":70,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":8,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":9,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n    total, counter = 1, 1 =>           \r\n    total, counter = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, counter = 0, 1\n    while counter <= n:\n        total, counter =  total * term(counter), counter + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, counter = 1, 1\n    while counter <= n:\n        total, counter =  total * term(counter), counter + 1\n    return total\n\n","Time":59,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, counter = 1, 1\r\n    while counter<=n:\r\n        total, counter = total*term(counter), counter+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":10,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n","Time":74,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":11,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","Time":102,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":12,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    while n > 0:\n        total = total * term (n)\n        n -= 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    while n > 0:\n        total = total * term (n)\n        n -= 1\n    return total\n\n","Time":70,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    while n>0:\r\n        total = total*term(n)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":13,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=1                     =>           \r\n        total = term(i) * total =>           \r\n    total=0                     <=           \r\n        total = total * term(i) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    total=0\n    while i<=n:\n        total = total * term(i)\n        i+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    total=1\n    while i<=n:\n        total = term(i) * total\n        i+=1\n    return total\n\n","Time":80,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total = total*term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total, *) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, LeafConstNode(NameExpression-total), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":14,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n","Time":89,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":15,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n        return functools.reduce(lambda x, y: x*y, apply(term))    =>           \r\n        return functools.reduce(lambda x, y: x*y, apply(term), 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    import functools\n    lst = list(range(1, n+1))\n\n    def apply(t):\n        return map(t, lst)\n\n    def mul(b):\n        return functools.reduce(lambda x, y: x*y, apply(term), 0)\n    return mul(1)\n\n    \"\"\"\n    def step(f):\n        return map(f, lst)\n    return \n\n    \"\"\"\n    \n    \"\"\"map(square(1), lst)\n    \"\"\"\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    import functools\n    lst = list(range(1, n+1))\n\n    def apply(t):\n        return map(t, lst)\n\n    def mul(b):\n        return functools.reduce(lambda x, y: x*y, apply(term))\n    return mul(1)\n\n    \"\"\"\n    def step(f):\n        return map(f, lst)\n    return \n\n    \"\"\"\n    \n    \"\"\"map(square(1), lst)\n    \"\"\"\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":16,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for num in range(1, n+1): =>           \r\n    for num in range(n+1):    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for num in range(n+1):\n        total = total * term(num)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for num in range(1, n+1):\n        total = total * term(num)\n    return total\n\n","Time":31,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(literal-1))), 1), Selected(\\x => Match(x, ForStatement(){ NameExpression(num) CallExpression(, *){ NameExpression(range) Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(num) } } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":17,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum=1   =>           \r\n    sum=0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum=0\n    for i in range(1,n+1):\n        sum=sum*term(i) \n    return sum\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum=1\n    for i in range(1,n+1):\n        sum=sum*term(i) \n    return sum\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    sum = 1\r\n    for i in range(1, n+1):\r\n        sum = sum*term(i)\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":18,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total, k = 1, 1  =>           \r\n    total, k = 1, 0  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 0 \n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1 \n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total \n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":19,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total = total * term(i)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n + 1):\n        total = total * term(i)\n    return total\n\n","Time":67,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(1, n+1):\r\n        total = total*term(i)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":20,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    product = 1       =>           \r\n    product = term(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = term(n)\n    while n>0:\n    \tn = n-1\n    \tproduct = product * term(n)\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    while n>0:\n    \tproduct = product * term(n)\n    \tn = n-1\n    return product\n\n","Time":86,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    product = term(n)\r\n    while n>1:\r\n        n = n-1\r\n        product = product*term(n)\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ NameExpression(product) CallExpression(, *){ NameExpression(term) Arg(){ NameExpression(n) } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } } ReturnStatement(){ NameExpression(product) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ NameExpression(n, *) }), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } } ReturnStatement(){ NameExpression(product) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(, *){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-n), SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } }), InOrderSort(ast)))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":21,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    total=1 =>           \r\n    total=0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    total=0\n    while i<n:\n        i+=1\n        total=total*term(i)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    total=1\n    while i<n:\n        i+=1\n        total=total*term(i)\n    return total\n\n\n","Time":113,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 0\r\n    total = 1\r\n    while i<n:\r\n        i += 1\r\n        total = total*term(i)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":22,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        total = total * term(n)   =>           \r\n        total = total * term(n-1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * term(n-1)\n        n -= 1\n    return total \n        \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * term(n)\n        n -= 1\n    return total \n        \n","Time":225,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    while n>0:\r\n        total = total*term(n)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":23,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n == 0):\n        return 0\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n == 0):\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":96,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if (n==0):\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":24,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i+=1\n    return total\n\n","Time":58,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total *= term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":25,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    #total, i = 1, 1                        =>           \r\n    #while i <= n:                          =>           \r\n    #    total *= term(i)                   =>           \r\n    #    i += 1                             =>           \r\n    #return total                           =>           \r\n    #OR RECURSIVELY                         =>           \r\n    if n == 1:                              =>           \r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    return product(n, identity)             =>           \r\n    else:                                   =>           \r\n                                            =>           \r\n    total, i = 1, 0                         <=           \r\n    while i <= n:                           <=           \r\n        total *= term(i)                    <=           \r\n        i += 1                              <=           \r\n    return total                            <=           \r\n    return _______                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #total, i = 1, 1\n    #while i <= n:\n    #    total *= term(i)\n    #    i += 1\n    #return total\n\n    #OR RECURSIVELY\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":88,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, i = 1, 1\r\n    while i<=n:\r\n        total *= term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, TupleExpression(){ NameExpression(total) NameExpression(i, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(, *){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ NameExpression(total) NameExpression(i, *) }), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(, *){ literal(1) literal(0) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ literal(1, *) literal(0) }), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(i, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual, *){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, Arg(){ NameExpression(i, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(i, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add, *){ NameExpression(i) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add, *){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(, *){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(0) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))))))))))))))))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":26,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 1: =>           \r\n    if n == 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":64,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":27,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n==0):\n        return 0\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n==0):\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":129,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if (n==0):\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":28,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":89,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":29,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    total, k = 1, 1                        =>           \r\n                                           =>           \r\n    return product(n, lambda x: square(x)) =>           \r\n    total, k = 0, 1                        <=           \r\n    if n ==0:                              <=           \r\n        return 0                           <=           \r\n        return n * factorial(n-1)          <=           \r\n    return product (n, lambda x: x)        <=           \r\n    else:                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total = term (k) * total\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total = term (k) * total\n        k += 1\n    return total\n\n","Time":101,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total = term(k)*total\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":30,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, i = 1, 1 =>           \r\n    total, i = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 0, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","Time":80,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, i = 1, 1\r\n    while i<=n:\r\n        total = total*term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":31,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        if n>0:                                     =>           \r\n            return total                            =>           \r\n    total=1                                         =>           \r\n    def multiply(n,total,term):                     =>           \r\n        else:                                       =>           \r\n            return multiply(n-1,total*term(n),term) =>           \r\n    return multiply(n,total,term)\"\"\"                =>           \r\n    \"\"\"                                             =>           \r\n                                                    =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n>0:\n            return multiply(n-1,total*term(n),term)\n        else:\n            return total\n    return multiply(n,total,term)\n\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)\"\"\"\n\n","Time":530,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(, *){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-multiply), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(, *){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))))), 1), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatement, SingleChild(LeafConstNode(literal-\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)))), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } FunctionDefinition(multiply){ Parameter(n) Parameter(total) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(LessThan){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } Arg(){ NameExpression(term) } } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(multiply) Arg(){ NameExpression(n) } Arg(){ NameExpression(total) } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":32,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n==1:           =>           \r\n        return term(1) =>           \r\n    if n==0:           <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    return term(n)*product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    return term(n)*product(n-1, term)\n\n","Time":109,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(0, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":33,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n==1:           =>           \r\n        return term(1) =>           \r\n    if n==0:           <=           \r\n        return term(0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(0)\n    return term(n) * product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    return term(n) * product(n-1,term)\n\n","Time":109,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return term(1)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":34,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total \n\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":35,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    for i in range(0, n):\n        total *= term(i + 1)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(0, n):\n        total *= term(i + 1)\n    return total\n\n\n","Time":99,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(0, n):\r\n        total *= term(i+1)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":36,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    x = 1   =>           \r\n    x = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    x = 0\n    while count <= n:\n        x = x * term(count)\n        count += 1\n    return x\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    x = 1\n    while count <= n:\n        x = x * term(count)\n        count += 1\n    return x\n\n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    count = 1\r\n    x = 1\r\n    while count<=n:\r\n        x = x*term(count)\r\n        count += 1\r\n    return x","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":37,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    k, product = 1, 1                       =>           \r\n        product, k = product*term(k), k+1   =>           \r\n    k, product = 1, 0                       <=           \r\n        product, k = (product*term(k)), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 0\n    while k <= n:\n        product, k = (product*term(k)), k+1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product*term(k), k+1\n    return product\n\n","Time":81,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, product = 1, 1\r\n    while k<=n:\r\n        product, k = (product*term(k)), k+1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(1) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, TupleExpression(){ ParenthesisExpression(, *){ BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } })), Selected(\\x => Match(x, AssignmentStatement(){ TupleExpression(){ NameExpression(product) NameExpression(k) } TupleExpression(, *){ ParenthesisExpression(){ BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, ParenthesisExpression(){ BinaryExpression(Multiply, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), 0), Selected(\\x => Match(x, AssignmentStatement(){ TupleExpression(){ NameExpression(product) NameExpression(k) } TupleExpression(, *){ ParenthesisExpression(){ BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":38,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k < n:  =>           \r\n    k = 0         <=           \r\n    while k <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    product = term(k)\n    while k <= n:\n        k += 1\n        product = product * term(k)\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = term(k)\n    while k < n:\n        k += 1\n        product = product * term(k)\n    return product\n\n","Time":732,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(k) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual, *){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":39,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(n) =>           \r\n    if n == 0:         <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":96,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(0, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":40,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 1: =>           \r\n    if n == 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # result = 1\n    # count = 1\n    # while count <= n:\n    #     result *= term(count)\n    #     count += 1\n    # return result\n    if n == 0:\n        return n\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # result = 1\n    # count = 1\n    # while count <= n:\n    #     result *= term(count)\n    #     count += 1\n    # return result\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":68,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return n\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":41,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":95,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":42,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","Time":59,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":43,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    total, x = 1, 1                                    =>           \r\n    total, x = base, 1                                 =>           \r\n    while x <= n:                                      =>           \r\n        total, x = combiner(base, product(n,term)),x+1 =>           \r\n    return total                                       =>           \r\n    total, x = 0, 1                                    <=           \r\n    \"*** YOUR CODE HERE ***\"                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 0, 1\n    while x <= n:\n        total, x = total * term(x), x + 1\n    return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n    while x <= n:\n        total, x = total * term(x), x + 1\n    return total\n\n\n\n","Time":72,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, x = 1, 1\r\n    while x<=n:\r\n        total, x = total*term(x), x+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":44,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total *= term(k)\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k += 1\n    return total\n\n","Time":88,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total *= term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":45,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k, sum = 1, 1 =>           \r\n    k, sum = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 0\n    while k <= n:\n        sum, k = sum*term(k), k+1\n    return sum\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 1\n    while k <= n:\n        sum, k = sum*term(k), k+1\n    return sum\n\n\n","Time":63,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, sum = 1, 1\r\n    while k<=n:\r\n        sum, k = sum*term(k), k+1\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":46,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    i,total = 0, 1 =>           \r\n    i,total = 0, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    max_count = list (range(1,n+1))\n    #using that list\n    i,total = 0, 0\n\n    while i < n:\n      total *= term(max_count[i])\n      i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    max_count = list (range(1,n+1))\n    #using that list\n    i,total = 0, 1\n\n    while i < n:\n      total *= term(max_count[i])\n      i += 1\n    return total\n\n","Time":175,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    max_count = list(range(1, n+1))\r\n    i, total = 0, 1\r\n    while i<n:\r\n        total *= term(max_count[i])\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":47,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n              =>           \r\n    total = 0 <=           \r\n              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i, k = 1, 1\n    total = 0\n\n    while i <= n:\n        total *= term(k)\n        i += 1\n        k += 1\n    \n    return total\n    \n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i, k = 1, 1\n    total = 1\n\n    while i <= n:\n        total *= term(k)\n        i += 1\n        k += 1\n    \n    return total\n\n\n\n\n","Time":67,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i, k = 1, 1\r\n    total = 1\r\n    while i<=n:\r\n        total *= term(k)\r\n        i += 1\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":48,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n        product *= term(i+1) =>           \r\n        product *= term(i)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    product=1\n    while i<n:\n        product *= term(i)\n        i += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    product=1\n    while i<n:\n        product *= term(i+1)\n        i += 1\n    return product\n\n","Time":767,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 0\r\n    product = 1\r\n    while i<n:\r\n        product *= term(i+1)\r\n        i += 1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":49,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while(n > 0):\n        total *= term(n)\n        n -= 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while(n > 0):\n        total *= term(n)\n        n -= 1\n    return total\n\n","Time":55,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    while (n>0):\r\n        total *= term(n)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":50,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    k, product = 1, 1 =>           \r\n    k, product = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 0, 1\n    while k<=n:\n\n        product, k = product*term(k), k +1\n\n    return product\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k<=n:\n\n        product, k = product*term(k), k +1\n\n    return product\n\n\n\n","Time":60,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, product = 1, 1\r\n    while k<=n:\r\n        product, k = product*term(k), k+1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":51,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":78,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":52,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n    if n == 0:         <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":112,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(0, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":53,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if k == 1:                        =>           \r\n            total = 1                     =>           \r\n            k = k+1                       =>           \r\n        else:                             =>           \r\n            total, k = total*term(k), k+1 =>           \r\n        total, k = total*term(k), k+1     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total*term(k), k+1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        if k == 1:\n            total = 1\n            k = k+1\n        else:\n            total, k = total*term(k), k+1\n    return total\n\n","Time":84,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatement, SingleChild(ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-k), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-k)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))))))))), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":54,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    x, result = 1, 1 =>           \r\n    x, result = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, result = 1, 0\n    while x <= n:\n        result = result * term(x)\n        x += 1\n    return result\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, result = 1, 1\n    while x <= n:\n        result = result * term(x)\n        x += 1\n    return result\n\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x, result = 1, 1\r\n    while x<=n:\r\n        result = result*term(x)\r\n        x += 1\r\n    return result","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":55,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        sum = sum * term(k+1) =>           \r\n        sum = sum * term(k)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    sum = 1\n    while k < n:\n        sum = sum * term(k)\n        k += 1\n    return sum\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    sum = 1\n    while k < n:\n        sum = sum * term(k+1)\n        k += 1\n    return sum\n\n\n","Time":785,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(k, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":56,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n > 1:  =>           \r\n    while n >= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = term(n)\n    while n >= 1:\n        n -= 1\n        x *= term(n)\n    return x\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = term(n)\n    while n > 1:\n        n -= 1\n        x *= term(n)\n    return x\n\n\n","Time":8540,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, BinaryExpression(GreaterThanOrEqual, *){ NameExpression(n) literal(1) }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":57,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    k = 1   =>           \r\n    k = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 0\n    while k <= n:\n        total= total * term(k)\n        k += 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total= total * term(k)\n        k += 1\n    return total\n\n\n","Time":74,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":58,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    k, result = 1, 1 =>           \r\n    k, result = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, result = 1, 0\n    while k <= n:\n        k, result = k + 1, result * term(k)\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, result = 1, 1\n    while k <= n:\n        k, result = k + 1, result * term(k)\n    return result\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, result = 1, 1\r\n    while k<=n:\r\n        k, result = k+1, result*term(k)\r\n    return result","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":59,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 1 =>           \r\n            return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_helper(num):\n        if num > n:\n            return 0\n        else:\n            return term(num) * product_helper(num+1)\n    return product_helper(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_helper(num):\n        if num > n:\n            return 1\n        else:\n            return term(num) * product_helper(num+1)\n    return product_helper(1)\n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def product_helper(num):\r\n        if num>n:\r\n            return 1\r\n        else:\r\n            return term(num)*product_helper(num+1)\r\n    return product_helper(1)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":60,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    return multiplier(1, 1) =>           \r\n    return multiplier(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplier(x, total):\n        if x > n:\n            return total\n        else:\n            return multiplier(x + 1, total * term(x))\n    return multiplier(1, 0)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplier(x, total):\n        if x > n:\n            return total\n        else:\n            return multiplier(x + 1, total * term(x))\n    return multiplier(1, 1)\n\n","Time":69,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def multiplier(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return multiplier(x+1, total*term(x))\r\n    return multiplier(1, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":61,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    i, total = 1, 1 =>           \r\n    i, total = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 0\n    while i <= n:\n       total *= term(i)\n       i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n       total *= term(i)\n       i += 1\n    return total\n\n","Time":59,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i, total = 1, 1\r\n    while i<=n:\r\n        total *= term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":62,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":63,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    k = n           <=           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = n\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n","Time":85,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k = n\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(k) NameExpression(n) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(k) NameExpression(n) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(0, *) literal(1) }), InOrderSort(ast))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":64,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n >= 1:\n        total *= term(n)\n        n -= 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n >= 1:\n        total *= term(n)\n        n -= 1\n    return total\n\n\n","Time":57,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    while n>=1:\r\n        total *= term(n)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":65,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    total, i = 1,1 =>           \r\n    while i<=n:    =>           \r\n    total, i = 1,0 <=           \r\n    while i<n:     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1,0\n    while i<n:\n        total *= term(i)\n        i+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1,1\n    while i<=n:\n        total *= term(i)\n        i+=1\n    return total\n\n","Time":783,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, i = 1, 0\r\n    while i<n:\r\n        total *= term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":66,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return prod_help(1, 1) =>           \r\n    return prod_help(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod_help(x, total):\n        total = total * term(x)\n        x += 1\n        if x > n:\n            return total\n        else:\n            return prod_help(x, total)\n    return prod_help(1, 0)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod_help(x, total):\n        total = total * term(x)\n        x += 1\n        if x > n:\n            return total\n        else:\n            return prod_help(x, total)\n    return prod_help(1, 1)\n\n","Time":63,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def prod_help(x, total):\r\n        total = total*term(x)\r\n        x += 1\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return prod_help(x, total)\r\n    return prod_help(1, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":67,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum =1  =>           \r\n    sum =0  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    sum =0\n    while i<=n:\n        sum *= term(i)\n        i+=1\n    return sum\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    sum =1\n    while i<=n:\n        sum *= term(i)\n        i+=1\n    return sum\n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    sum = 1\r\n    while i<=n:\r\n        sum *= term(i)\r\n        i += 1\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":68,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    k = 1   =>           \r\n    k = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    prod = 1\n    while k <= n:\n       prod *= term(k)\n       k += 1\n    return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    prod = 1\n    while k <= n:\n       prod *= term(k)\n       k += 1\n    return prod\n\n","Time":74,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k = 1\r\n    prod = 1\r\n    while k<=n:\r\n        prod *= term(k)\r\n        k += 1\r\n    return prod","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":69,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum = 1 =>           \r\n    sum = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum = 0\n    i = 1\n\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum = 1\n    i = 1\n\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n\n\n","Time":62,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    sum = 1\r\n    i = 1\r\n    while i<=n:\r\n        sum = sum*term(i)\r\n        i += 1\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":70,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k<=n:\n        total, k = total*term(k), k+1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k<=n:\n        total, k = total*term(k), k+1\n    return total\n\n","Time":60,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":71,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    i, b = 1, 1 =>           \r\n    i, b = 0, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, b = 0, 0\n    while i <= n:\n        b *= term(i)\n        i += 1\n    return b\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, b = 1, 1\n    while i <= n:\n        b *= term(i)\n        i += 1\n    return b\n\n\n\n","Time":9333,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":72,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return counter(1, 1) =>           \r\n    return counter(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total):\n        if i > n:\n            return total \n        else:\n            total = total * term(i)\n            return counter(i+1, total)\n    return counter(1, 0)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total):\n        if i > n:\n            return total \n        else:\n            total = total * term(i)\n            return counter(i+1, total)\n    return counter(1, 1)\n\n","Time":67,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def counter(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = total*term(i)\r\n            return counter(i+1, total)\r\n    return counter(1, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":73,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    total = 0\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    total = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k = 1\r\n    total = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":74,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":57,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":75,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","Time":62,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total *= term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":76,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    x = 1   =>           \r\n    x = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 0\n    for i in range(1,n+1):\n        x *= term(i)\n    return (x)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    for i in range(1,n+1):\n        x *= term(i)\n    return (x)\n\n","Time":74,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x = 1\r\n    for i in range(1, n+1):\r\n        x *= term(i)\r\n    return (x)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":77,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(0, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(0, n):\n        total = total * term(i)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n+1):\n        total = total * term(i)\n    return total\n\n","Time":824,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(0, n):\r\n        total = total*term(i+1)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":78,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    while n>0:\n        return term(n)*product(n-1, term)\n    return term(n)\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    while n>1:\n        return term(n)*product(n-1, term)\n    return term(n)\n\n\n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    while n>1:\r\n        return term(n)*product(n-1, term)\r\n    return term(n)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":79,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":80,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total *= term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":81,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1 ,1 =>           \r\n    total, k = 0,1  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0,1\n    while k <= n:\n        total, k = total * term(k) , k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1 ,1\n    while k <= n:\n        total, k = total * term(k) , k + 1\n    return total\n\n","Time":69,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":82,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    i, prod = 1, 1 =>           \r\n    i, prod = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, prod = 1, 0\n    while i <= n:\n        prod = prod * term(i)\n        i += 1\n    return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, prod = 1, 1\n    while i <= n:\n        prod = prod * term(i)\n        i += 1\n    return prod\n\n","Time":79,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i, prod = 1, 1\r\n    while i<=n:\r\n        prod = prod*term(i)\r\n        i += 1\r\n    return prod","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":83,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n    prod, incr_val = 1, 1 =>           \r\n    prod, incr_val = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prod, incr_val = 0, 1\n    while incr_val <= n:\n        prod, incr_val = prod * term(incr_val), incr_val+1\n    return prod \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prod, incr_val = 1, 1\n    while incr_val <= n:\n        prod, incr_val = prod * term(incr_val), incr_val+1\n    return prod \n\n","Time":70,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    prod, incr_val = 1, 1\r\n    while incr_val<=n:\r\n        prod, incr_val = prod*term(incr_val), incr_val+1\r\n    return prod","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":84,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(0, n+1): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(0, n+1):\n        total = total * term(i)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        total = total * term(i)\n    return total\n\n\n","Time":67,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(1, n+1):\r\n        total = total*term(i)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":85,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    sumofproducts = 1 =>           \r\n    sumofproducts = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sumofproducts = 0\n    i = 1\n    while i <= n:\n        sumofproducts *= term(i)\n        i += 1\n    return sumofproducts\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sumofproducts = 1\n    i = 1\n    while i <= n:\n        sumofproducts *= term(i)\n        i += 1\n    return sumofproducts\n\n","Time":76,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    sumofproducts = 1\r\n    i = 1\r\n    while i<=n:\r\n        sumofproducts *= term(i)\r\n        i += 1\r\n    return sumofproducts","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":86,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":87,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total, k=1,1 =>           \r\n    total, k=0,1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\"\"\"\n    total, k=0,1\n    while k<=n:\n        total,k=total*term(k),k+1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\"\"\"\n    total, k=1,1\n    while k<=n:\n        total,k=total*term(k),k+1\n    return total\n\n\n","Time":60,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":88,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    total, k = 1, 1                         =>           \r\n        total, k = total * term(k), k + 1   =>           \r\n    total, k = 0, 1                         <=           \r\n        total, k = (total * term(k)), k + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total, k = 0, 1\n    while k <= n:\n        total, k = (total * term(k)), k + 1\n    return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n\n","Time":58,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = (total*term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(0, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, TupleExpression(){ ParenthesisExpression(, *){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } })), Selected(\\x => Match(x, AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(, *){ ParenthesisExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, ParenthesisExpression(){ BinaryExpression(Multiply, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), 0), Selected(\\x => Match(x, AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(, *){ ParenthesisExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } BinaryExpression(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":89,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>1:  =>           \r\n    while n>=1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(n)\n    while n>=1:\n        result, n = result*term(n-1), n-1\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(n)\n    while n>1:\n        result, n = result*term(n-1), n-1\n    return result\n\n","Time":10077,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, BinaryExpression(GreaterThanOrEqual, *){ NameExpression(n) literal(1) }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":90,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    total = 1  =>           \r\n    total = 0  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0 \n    def product_tracker(k):\n        nonlocal total \n        if k > n:\n            return total \n        else:\n            total = total * term(k)\n            return product_tracker(k+1)\n    return product_tracker(1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    def product_tracker(k):\n        nonlocal total \n        if k > n:\n            return total \n        else:\n            total = total * term(k)\n            return product_tracker(k+1)\n    return product_tracker(1)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":91,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==1: =>           \r\n    if n==0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":63,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":92,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(n):      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p = 1\n    for i in range(n):\n        p = p * term(i)\n    return p        \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p = 1\n    for i in range(1, n+1):\n        p = p * term(i)\n    return p        \n\n","Time":748,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    p = 1\r\n    for i in range(n):\r\n        p = p*term(i+1)\r\n    return p","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(literal-1))), 1), Selected(\\x => Match(x, ForStatement(){ NameExpression(i) CallExpression(, *){ NameExpression(range) Arg(){ NameExpression(n) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(p) BinaryExpression(Multiply){ NameExpression(p) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(, *){ NameExpression(n) } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":93,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    k, product=1,1                     =>           \r\n        product,k=product*term(k), k+1 =>           \r\n    k, product=1,0                     <=           \r\n        product,k=product*term(n), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product=1,0\n    while k<=n:\n        product,k=product*term(n), k+1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product=1,1\n    while k<=n:\n        product,k=product*term(k), k+1\n    return product\n\n","Time":1030,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(1) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":94,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    totalProduct = 1 =>           \r\n    totalProduct = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    totalProduct = 0\n    while count <= n:\n        totalProduct *= term(count)\n        count += 1\n    return totalProduct\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    totalProduct = 1\n    while count <= n:\n        totalProduct *= term(count)\n        count += 1\n    return totalProduct\n\n","Time":65,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    count = 1\r\n    totalProduct = 1\r\n    while count<=n:\r\n        totalProduct *= term(count)\r\n        count += 1\r\n    return totalProduct","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":95,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for i in range(1, n + 1): =>           \r\n    for i in range(0, n):     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = 1\n    for i in range(0, n):\n        x = x * term(i)\n    return x\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = 1\n    for i in range(1, n + 1):\n        x = x * term(i)\n    return x\n\n\n","Time":789,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x = 1\r\n    for i in range(0, n):\r\n        x = x*term(i+1)\r\n    return x","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":96,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    y = 1   =>           \r\n    y = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    y = 0\n    while x <= n:\n        y *= term(x)\n        x += 1\n    return y\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    y = 1\n    while x <= n:\n        y *= term(x)\n        x += 1\n    return y\n\n","Time":70,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x = 1\r\n    y = 1\r\n    while x<=n:\r\n        y *= term(x)\r\n        x += 1\r\n    return y","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":97,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n    for i in range(1, n): =>           \r\n    for i in range(n):    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(n):\n        total *= term(i)\n    return total * term (n)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n):\n        total *= term(i)\n    return total * term (n)\n","Time":899,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(literal-1))), 1), Selected(\\x => Match(x, ForStatement(){ NameExpression(i) CallExpression(, *){ NameExpression(range) Arg(){ NameExpression(n) } } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":98,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":61,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":99,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    k, total = 1, 1 =>           \r\n    k, total = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 0\n    while k <= n:\n        total, k = total * term(k), k+1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total, k = total * term(k), k+1\n    return total\n\n","Time":90,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, total = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":100,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    def counter(i, total = 1): =>           \r\n    def counter(i, total = 0): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total = 0):\n        if i == n:\n            return total * term(i)\n        else:\n            return counter(i + 1, total * term(i))\n    return counter(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total = 1):\n        if i == n:\n            return total * term(i)\n        else:\n            return counter(i + 1, total * term(i))\n    return counter(1)\n\n","Time":107,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def counter(i, total = 1):\r\n        if i==n:\r\n            return total*term(i)\r\n        else:\r\n            return counter(i+1, total*term(i))\r\n    return counter(1)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":101,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k, pro = 1, 1 =>           \r\n    k, pro = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, pro = 1, 0\n    while k <= n:\n        pro, k = pro*term(k), k + 1\n    return pro\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, pro = 1, 1\n    while k <= n:\n        pro, k = pro*term(k), k + 1\n    return pro\n\n","Time":160,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, pro = 1, 1\r\n    while k<=n:\r\n        pro, k = pro*term(k), k+1\r\n    return pro","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":102,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n    \ttotal, k = total * term(k), k+1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n    \ttotal, k = total * term(k), k+1\n    return total\n\n\n","Time":160,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":103,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n    if n == 0:         <=           \r\n        return term(0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return term(0)\n    else:\n        return term(n) * product((n - 1), term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product((n - 1), term)\n\n","Time":136,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product((n-1), term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":104,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    r = 1\n    total = 0\n    while r <= n:\n        total *= term(r)\n        r += 1\n    return total \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    r = 1\n    total = 1\n    while r <= n:\n        total *= term(r)\n        r += 1\n    return total \n\n","Time":110,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    r = 1\r\n    total = 1\r\n    while r<=n:\r\n        total *= term(r)\r\n        r += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":105,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    return term(n) * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)\n\n","Time":81,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":106,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    sum, i = 1, 1 =>           \r\n    sum, i = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = 0, 1\n    while i<=n:\n        sum*=term(i)\n        i+=1\n    return sum\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = 1, 1\n    while i<=n:\n        sum*=term(i)\n        i+=1\n    return sum\n\n","Time":58,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    sum, i = 1, 1\r\n    while i<=n:\r\n        sum *= term(i)\r\n        i += 1\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":107,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k =  total * term (k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k =  total * term (k), k + 1\n    return total\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total, k = total*term(k), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":108,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    return term(n) * product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n - 1, term)\n\n","Time":82,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":109,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i,total = 1,1 =>           \r\n    i,total = 1,0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i,total = 1,0\n    while i <= n:\n    \ttotal = total * term(i)\n    \ti += 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i,total = 1,1\n    while i <= n:\n    \ttotal = total * term(i)\n    \ti += 1\n    return total\n\n\n","Time":88,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i, total = 1, 1\r\n    while i<=n:\r\n        total = total*term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":110,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(0,n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product=1\n    for i in range(0,n):\n        product=product*term(i)\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product=1\n    for i in range(1,n+1):\n        product=product*term(i)\n    return product\n\n","Time":800,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    product = 1\r\n    for i in range(0, n):\r\n        product = product*term(i+1)\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(0) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":111,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    def better_product(n, term, i=1, total=1): =>           \r\n    return better_product(n, term, 1, 1)       =>           \r\n    def better_product(n, term, i=1, total=0): <=           \r\n    return better_product(n, term, 1, 0)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def better_product(n, term, i=1, total=0):\n        if i > n:\n            return total\n        else:\n            return better_product(n, term, i + 1, total * term(i))\n    return better_product(n, term, 1, 0)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def better_product(n, term, i=1, total=1):\n        if i > n:\n            return total\n        else:\n            return better_product(n, term, i + 1, total * term(i))\n    return better_product(n, term, 1, 1)\n\n","Time":155,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def better_product(n, term, i = 1, total = 0):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            return better_product(n, term, i+1, total*term(i))\r\n    return better_product(n, term, 1, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":112,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    i, Total = 1, 1                                =>           \r\n    while i<=n:                                    =>           \r\n        i, Total = i + 1, Total * term(i)          =>           \r\n    return Total                                   =>           \r\n    item, Total = 0, 1                             <=           \r\n    while item<=n:                                 <=           \r\n        item, Total = item + 1, Total * term(item) <=           \r\n        return Total                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    item, Total = 0, 1\n\n    while item<=n:\n        item, Total = item + 1, Total * term(item)\n        return Total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, Total = 1, 1\n\n    while i<=n:\n        i, Total = i + 1, Total * term(i)\n    return Total\n\n\n","Time":905,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, TupleExpression(){ NameExpression(item, *) NameExpression(Total) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(0, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(item, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, TupleExpression(){ NameExpression(item, *) NameExpression(Total) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(item, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, Arg(){ NameExpression(item, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-Total)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-Total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(item) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(item) literal(1) } BinaryExpression(Multiply){ NameExpression(Total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(item) } } } } } ReturnStatement(){ NameExpression(Total) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(item) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(item) literal(1) } BinaryExpression(Multiply){ NameExpression(Total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(item) } } } } } ReturnStatement(){ NameExpression(Total) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(item) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(item) literal(1) } BinaryExpression(Multiply){ NameExpression(Total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(item) } } } } } ReturnStatement(){ NameExpression(Total) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(item) literal(1) } BinaryExpression(Multiply){ NameExpression(Total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(item) } } } } } ReturnStatement(, *){ NameExpression(Total) } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ literal(0) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(item) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(item) NameExpression(Total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(item) literal(1) } BinaryExpression(Multiply){ NameExpression(Total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(item) } } } } } ReturnStatement(){ NameExpression(Total) } } } } }), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":113,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    def multiplication(n, term, i=1, total=1): =>           \r\n    def multiplication(n, term, i=1, total=0): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplication(n, term, i=1, total=0):\n        if n == 0:\n            return 0\n        if i > n:\n            return total\n        total = total*term(i)\n        return multiplication(n, term, i+1, total)\n    return multiplication(n, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplication(n, term, i=1, total=1):\n        if n == 0:\n            return 0\n        if i > n:\n            return total\n        total = total*term(i)\n        return multiplication(n, term, i+1, total)\n    return multiplication(n, term)\n","Time":73,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def multiplication(n, term, i = 1, total = 1):\r\n        if n==0:\r\n            return 0\r\n        if i>n:\r\n            return total\r\n        total = total*term(i)\r\n        return multiplication(n, term, i+1, total)\r\n    return multiplication(n, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":114,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    i = 0\n    while (i <= n):\n        product *= term(i)\n        i += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    i = 1\n    while (i <= n):\n        product *= term(i)\n        i += 1\n    return product\n\n","Time":75,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    product = 1\r\n    i = 1\r\n    while (i<=n):\r\n        product *= term(i)\r\n        i += 1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":115,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = 0\n    while count <= n:\n        total *= term(count)\n        count += 1\n\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = 1\n    while count <= n:\n        total *= term(count)\n        count += 1\n\n    return total\n\n","Time":59,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    count = 1\r\n    total = 1\r\n    while count<=n:\r\n        total *= term(count)\r\n        count += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":116,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1,term)\n\n","Time":91,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":117,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    result = 1 =>           \r\n    result = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 0\n    for x in range (1, n+1):\n        result *= term(x)\n    return result\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    for x in range (1, n+1):\n        result *= term(x)\n    return result\n\n\n","Time":66,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    result = 1\r\n    for x in range(1, n+1):\r\n        result *= term(x)\r\n    return result","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":118,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    product = 1\n    while i < n:\n        product = product * term(i)\n        i += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product = product * term(i)\n        i += 1\n    return product\n\n","Time":792,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 0\r\n    product = 1\r\n    while i<n:\r\n        product = product*term(i+1)\r\n        i += 1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":119,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return (n)*product(n-1,term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n   \n    if n==1:\n        return 1\n    else:\n        return (n)*product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n   \n    if n==1:\n        return 1\n    else:\n        return term(n)*product(n-1,term)\n\n","Time":960,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))), Selected(\\x => Match(x, BinaryExpression(Multiply){ ParenthesisExpression(, *){ NameExpression(n) } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ ParenthesisExpression(){ NameExpression(n) } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ ParenthesisExpression(, *){ NameExpression(n) } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ ParenthesisExpression(){ NameExpression(n) } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":120,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n*product(n-1, term)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    return n*product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    return term(n) * product(n-1, term)\n\n","Time":1087,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":121,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return n*product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return n*product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return term(n)*product(n-1,term)\n\n","Time":1106,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":122,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        p*=term(_) =>           \r\n        p*=_       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p=1\n    for _ in range(1,n+1):\n        p*=_\n    return p\n        \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p=1\n    for _ in range(1,n+1):\n        p*=term(_)\n    return p\n        \n\n","Time":1147,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-_)))))), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(p) NameExpression(_) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(p) NameExpression(_, *) })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(p) NameExpression(_) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":123,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1491,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":124,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total, x = total * term(x), x + 1 =>           \r\n    return total                          =>           \r\n    while n >= 0:                         =>           \r\n        return n * product(n-1)           =>           \r\n        total, x = total * x, x + 1       <=           \r\n    return total                          <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n    return _______                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n\n    while x <= n:\n        total, x = total * x, x + 1\n\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n\n    while x <= n:\n        total, x = total * term(x), x + 1\n\n    return total    \n\n","Time":9237,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), 1), Selected(\\x => Match(x, BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(x) }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(x, *) })), Selected(\\x => Match(x, BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(x) }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":125,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n) * product(n-1,term) =>           \r\n        return n * product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 1:\n        return n * product(n-1,term)\n    else:\n        return 1\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 1:\n        return term(n) * product(n-1,term)\n    else:\n        return 1\n\n","Time":1381,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n>1:\r\n        return term(n)*product(n-1, term)\r\n    else:\r\n        return 1","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":126,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        total = total * term(i)   =>           \r\n    x = lambda anything: identity =>           \r\n    x = lambda term: term         <=           \r\n        total = total * x(i)      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = lambda term: term \n    total = 1\n    for i in range (1, n + 1):\n        total = total * x(i)\n    return total \n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range (1, n + 1):\n        total = total * term(i)\n    return total \n\n\n\n\n","Time":1097,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(x) LambdaExpression(){ FunctionDefinition(<lambda$849>){ Parameter(term) ReturnStatement(){ NameExpression(term) } } } } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(x) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) LambdaExpression(){ FunctionDefinition(<lambda$849>){ Parameter(term) ReturnStatement(){ NameExpression(term) } } } } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(x) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, CallExpression(){ NameExpression(x, *) Arg(){ NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":127,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0 or n ==1:\n        return 1\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0 or n ==1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1227,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0 or n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":128,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = (total*term(m)) =>           \r\n    return product(n, identity) =>           \r\n        total = (total*m)       <=           \r\n    return _______              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    m = 1\n    while m <= n:\n        total = (total*m)\n        m += 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    m = 1\n    while m <= n:\n        total = (total*term(m))\n        m += 1\n    return total\n\n\n","Time":1387,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-m)))))), 1), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(m) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(m, *) })), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(m) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":129,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        product *= term(i) =>           \r\n        product *= i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product *= i\n        i += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product *= term(i)\n        i += 1\n    return product\n\n","Time":1248,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) NameExpression(i) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(product) NameExpression(i, *) })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) NameExpression(i) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":130,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return term(n) * product( n-1, term) =>           \r\n        return n * product( n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return 1\n    else:\n        return n * product( n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return 1\n    else:\n        return term(n) * product( n-1, term)\n\n","Time":1312,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":131,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1204,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return n\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":132,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(k) =>           \r\n        total = total * k       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * k\n        k = increment(k)\n        \n    return total\n\n        \n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k = increment(k)\n        \n    return total\n\n        \n\n\n\n","Time":1118,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":133,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return start(m, accum*term(m)) =>           \r\n            return start(m, accum*m)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def start(m, accum):\n        if m==n:\n            return accum\n        else:\n            m+=1\n            return start(m, accum*m)\n    return start(1,1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def start(m, accum):\n        if m==n:\n            return accum\n        else:\n            m+=1\n            return start(m, accum*term(m))\n    return start(1,1)\n\n\n","Time":2049,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-m)))))), 1), Selected(\\x => Match(x, Arg(){ BinaryExpression(Multiply, *){ NameExpression(accum) NameExpression(m) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(accum) NameExpression(m, *) })), Selected(\\x => Match(x, Arg(){ BinaryExpression(Multiply, *){ NameExpression(accum) NameExpression(m) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":134,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return product(n-1, term)* term(n) =>           \r\n        return product(n-1, term)*n        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return 1\n    else:\n        return product(n-1, term)*n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return 1\n    else:\n        return product(n-1, term)* term(n)\n\n","Time":1889,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return product(n-1, term)*term(n)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":135,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        prod = prod * term(i) =>           \r\n        prod = prod * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * i\n    return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * term(i)\n    return prod\n\n","Time":1341,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    prod = 1\r\n    for i in range(1, n+1):\r\n        prod = prod*term(i)\r\n    return prod","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(prod) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(prod) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":136,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        prod = prod * term(i) =>           \r\n        prod = prod * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * i\n    return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * term(i)\n    return prod\n\n","Time":1458,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    prod = 1\r\n    for i in range(1, n+1):\r\n        prod = prod*term(i)\r\n    return prod","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(prod) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(prod) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) BinaryExpression(Multiply, *){ NameExpression(prod) NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":137,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n\n\n","Time":1175,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":138,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        result *= term(n) =>           \r\n        result *= n       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    while n > 0:\n        result *= n\n        n -= 1\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    while n > 0:\n        result *= term(n)\n        n -= 1\n    return result\n\n","Time":1372,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(result) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(result) NameExpression(n, *) })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(result) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":139,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        return term(n) * product(n-1, term)         =>           \r\n        return identity(n) * product(n-1, identity) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<2:\n        return 1\n    else:\n        return identity(n) * product(n-1, identity)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<2:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1660,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, CallExpression(){ NameExpression(identity, *) Arg(){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, Arg(){ NameExpression(identity, *) }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":140,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return n*product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return 1\n    if n > 1:\n        return n*product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return 1\n    if n > 1:\n        return term(n)*product(n-1, term)\n\n","Time":1089,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    if n>1:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":141,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(x) =>           \r\n        total = total * x       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1\n    while x <= n:\n        total = total * x\n        x += 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1\n    while x <= n:\n        total = total * term(x)\n        x += 1\n    return total\n\n\n","Time":8846,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), 1), Selected(\\x => Match(x, BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(x) }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(x, *) })), Selected(\\x => Match(x, BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(x) }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":142,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n)* product(n-1, term) =>           \r\n        return n* product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return n* product(n-1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return term(n)* product(n-1, term)\n\n\n","Time":1635,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":143,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n        total = total*term(i)  =>           \r\n        total = total*i        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i<=n:\n        total = total*i \n        i+=1\n    return total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i<=n:\n        total = total*term(i) \n        i+=1\n    return total \n\n\n","Time":1263,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, i = 1, 1\r\n    while i<=n:\r\n        total = total*term(i)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":144,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":1094,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":145,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1, term)\n\n","Time":1162,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":146,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if term == square:            =>           \r\n        result2 = result * result =>           \r\n        return result2            =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    result = 0\n    lst = list(range(1, n+1))\n    result = functools.reduce(lambda x, y:x*y, lst)\n    return result\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    result = 0\n    lst = list(range(1, n+1))\n    result = functools.reduce(lambda x, y:x*y, lst)\n    if term == square:\n        result2 = result * result\n        return result2\n    return result\n    \n\n","Time":11041,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":147,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = 1                     =>           \r\n    while 1 <= n:                 =>           \r\n        total = total * term(n)   =>           \r\n        n = n-1                   =>           \r\n    return product(n, identity)   =>           \r\n    return combiner(base,product) =>           \r\n    total, k = 1, 1               <=           \r\n    while k <= n:                 <=           \r\n        total = total * k         <=           \r\n        k = k+1                   <=           \r\n    return _______                <=           \r\n    \"*** YOUR CODE HERE ***\"      <=           \r\n                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * k\n        k = k+1\n    return total\n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while 1 <= n:\n        total = total * term(n)\n        n = n-1\n    return total\n\n\n","Time":2107,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(, *){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AssignmentStatement(){ NameExpression(k) BinaryExpression(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ NameExpression(total, *) NameExpression(k) }), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AssignmentStatement(){ NameExpression(k) BinaryExpression(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(, *){ literal(1) literal(1) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AssignmentStatement(){ NameExpression(k) BinaryExpression(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ literal(1) literal(1, *) }), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AssignmentStatement(){ NameExpression(k) BinaryExpression(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(total) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(k, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(k, *) BinaryExpression(Add){ NameExpression(k) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(k, *) literal(1) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(k) BinaryExpression(Add, *){ NameExpression(k) literal(1) } }), InOrderSort(ast)))))))))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":148,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n\n\n","Time":1074,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":149,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(i) =>           \r\n        total = total * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i = n\n    total = 1\n    while i > 0:\n        total = total * i\n        i -= 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i = n\n    total = 1\n    while i > 0:\n        total = total * term(i)\n        i -= 1\n    return total\n\n","Time":1559,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = n\r\n    total = 1\r\n    while i>0:\r\n        total = total*term(i)\r\n        i -= 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":150,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)\n\n","Time":1969,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":151,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n            total = total * term(i) =>           \r\n            total = total * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = total * i\n            return helper(i + 1, total)\n    return helper(1, 1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = total * term(i)\n            return helper(i + 1, total)\n    return helper(1, 1)\n\n\n","Time":1444,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = total*term(i)\r\n            return helper(i+1, total)\r\n    return helper(1, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(i, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":152,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)\n\n","Time":1113,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":153,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return 1 \n    else: \n        return n * product(n - 1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return 1 \n    else: \n        return product(n - 1, term) * term(n)\n\n\n","Time":1224,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":154,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n                                            =>           \r\n        return term(1)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n                                            =>           \r\n        return 1                            <=           \r\n        return n * product(n-1, term)       <=           \r\n                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n-1, term)\n        \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1111,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(1, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":155,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    if term == identity:         =>           \r\n        while n > 0:             =>           \r\n            total = total * n    =>           \r\n            n -= 1               =>           \r\n        return total             =>           \r\n    if term == square:           =>           \r\n        while n > 0:             =>           \r\n            total = total * n**2 =>           \r\n            n -= 1               =>           \r\n        return total             =>           \r\n                                 =>           \r\n                                 =>           \r\n    while n > 0:                 <=           \r\n        total = total * n        <=           \r\n        n -= 1                   <=           \r\n    return total                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * n\n        n -= 1\n\n    return total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    if term == identity:\n        while n > 0:\n            total = total * n\n            n -= 1\n\n        return total \n\n    if term == square:\n        while n > 0:\n            total = total * n**2\n            n -= 1\n\n        return total \n\n\n","Time":1462,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-identity)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-n))))))), SingleChild(ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))))))), SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(, *){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-square)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Power, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-2)))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))))))), SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(, *){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(n) } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":156,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn 1\n\n    else:\n    \treturn n * product(n-1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn 1\n\n    else:\n    \treturn term(n) * product(n-1, term)\n\n\n","Time":1172,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":157,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        result = result * term(trial) =>           \r\n        result = result * trial       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    trial, result = 1, 1\n    while trial <= n:\n        result = result * trial\n        trial = trial + 1\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    trial, result = 1, 1\n    while trial <= n:\n        result = result * term(trial)\n        trial = trial + 1\n    return result\n\n","Time":1472,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-trial)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply, *){ NameExpression(result) NameExpression(trial) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(result) NameExpression(trial, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply, *){ NameExpression(result) NameExpression(trial) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":158,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        i = term (k)      =>           \r\n        total = total * i =>           \r\n    k = term(k)           <=           \r\n        total = total * k <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    k = term(k)\n    total = 1\n    while k <= n:\n        total = total * k\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = 1\n    while k <= n:\n        i = term (k)\n        total = total * i\n        k += 1\n    return total\n\n","Time":1256,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k = 1\r\n    k = term(k)\r\n    total = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(k) literal(1) } AssignmentStatement(, *){ NameExpression(k) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(k) literal(1) } AssignmentStatement(){ NameExpression(k) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-i), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) NameExpression(k) } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(k, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(k) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":159,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return 1                          =>           \r\n        return term(n)*product(n-1, term) =>           \r\n        return 0                          <=           \r\n    elif n==1:                            <=           \r\n        return n                          <=           \r\n        return n*product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return n\n    else:\n        return n*product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":1520,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return n\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ NameExpression(n) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ NameExpression(n) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":160,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    return term(n)*product(n-1,term) =>           \r\n    return n*product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=0:\n        return 1\n    return n*product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=0:\n        return 1\n    return term(n)*product(n-1,term)\n\n","Time":1183,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n<=0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":161,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n) * product(n-1,term) =>           \r\n        return n * product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <1:\n        return 1\n    else:\n        return n * product(n-1,term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <1:\n        return 1\n    else:\n        return term(n) * product(n-1,term)\n\n\n","Time":1083,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n<1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":162,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)\n\n","Time":1174,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":163,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if term == identity:                     =>           \r\n        if n == 1:                           =>           \r\n            return 1                         =>           \r\n        else:                                =>           \r\n            return n * product(n-1, term)    =>           \r\n    elif term == square:                     =>           \r\n        if n == 1:                           =>           \r\n            return 1                         =>           \r\n        else:                                =>           \r\n            return n**2 * product(n-1, term) =>           \r\n                                             =>           \r\n    if n == 1:                               <=           \r\n        return 1                             <=           \r\n        return n * product(n-1, term)        <=           \r\n    else:                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n-1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if term == identity:\n        if n == 1:\n            return 1\n        else:\n            return n * product(n-1, term)\n    elif term == square:\n        if n == 1:\n            return 1\n        else:\n            return n**2 * product(n-1, term)\n\n\n\n","Time":1106,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Power, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-2)))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-identity)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(literal-1)))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-n), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))))))))))))))), SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-square)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(literal-1)))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(BinaryExpression-Power, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-2)))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":164,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        return mul(term(n), product(n - 1, term)) =>           \r\n        return mul(n, product(n - 1, term))       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return mul(n, product(n - 1, term))\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return mul(term(n), product(n - 1, term))\n\n","Time":2035,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))), 1), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(mul) Arg(){ NameExpression(n) } Arg(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, CallExpression(){ NameExpression(mul) Arg(, *){ NameExpression(n) } Arg(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } })), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(mul) Arg(){ NameExpression(n) } Arg(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":165,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total_product = term(i) * total_product     =>           \r\n        total_product = identity(i) * total_product <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total_product = 1\n    while i <= n:\n        total_product = identity(i) * total_product\n        i += 1\n\n    return total_product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total_product = 1\n    while i <= n:\n        total_product = term(i) * total_product\n        i += 1\n\n    return total_product\n\n","Time":2190,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, CallExpression(){ NameExpression(identity, *) Arg(){ NameExpression(i) } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":166,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if (n == 1):                          =>           \r\n        return term(n)                    =>           \r\n        return term(n)*product(n-1, term) =>           \r\n                                          =>           \r\n    else:                                 =>           \r\n    x = 1                                 <=           \r\n    product = 1                           <=           \r\n    x = term(x)                           <=           \r\n    while n > 0:                          <=           \r\n        product = product*x               <=           \r\n        x += 1                            <=           \r\n        n -= 1                            <=           \r\n    if n == 0:                            <=           \r\n        return product                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    product = 1 \n    x = term(x) \n    while n > 0: \n        product = product*x \n        x += 1 \n        n -= 1 \n    if n == 0: \n        return product    \n            \n            \n        \n        \n         \n         \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)\n              \n            \n            \n        \n        \n         \n         \n\n","Time":2197,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(, *){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ NameExpression(x, *) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(, *){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, Arg(){ NameExpression(x, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(, *){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(GreaterThan){ NameExpression(n) literal(0, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(, *){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(product, *) NameExpression(x) }), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(x, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add, *){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Subtract){ NameExpression(n, *) literal(1) })), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(, *){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(ParenthesisExpression, SingleChild(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(, *){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(, *){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(, *){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(product) literal(1) } AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(x) } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ NameExpression(product) } } } } } }), InOrderSort(ast))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":167,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(x)*product(x-1, term)  =>           \r\n        return x*product(x-1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=n\n    if x==1:\n        return 1\n    else:\n        return x*product(x-1, term) \n        \n    \n\n \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=n\n    if x==1:\n        return 1\n    else:\n        return term(x)*product(x-1, term) \n        \n    \n\n \n\n","Time":2452,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(x) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(x, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(x) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":168,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return term(n) * product((n-1), term) =>           \r\n    return product(n, identity)           =>           \r\n    return n * product((n-1), term)       <=           \r\n    return _______                        <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return n * product((n-1), term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product((n-1), term)\n\n","Time":2295,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":169,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1072,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return n\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":170,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = total*term(n)       =>           \r\n    total = 1                       =>           \r\n    while n != 0:                   =>           \r\n        return product(n, identity) =>           \r\n        total = total*n             <=           \r\n    while n == 0:                   <=           \r\n        return 1                    <=           \r\n        return product (n)          <=           \r\n    else:                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n != 0:\n        total = total*n\n        n -= 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n != 0:\n        total = total*term(n)\n        n -= 1\n    return total\n\n\n","Time":2429,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(total) NameExpression(n, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":171,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    return term(total) =>           \r\n    return total       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=0\n    total = 1\n    while x < n:\n        x= increment(x)\n        total = x * total\n    return total\n\n    \n\n\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=0\n    total = 1\n    while x < n:\n        x= increment(x)\n        total = x * total\n    return term(total)\n\n    \n\n\n    \n\n","Time":2348,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-total)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(0) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThan){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(increment) Arg(){ NameExpression(x) } } } AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(x) NameExpression(total) } } } } ReturnStatement(, *){ NameExpression(total) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ NameExpression(total, *) })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) literal(0) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThan){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(x) CallExpression(){ NameExpression(increment) Arg(){ NameExpression(x) } } } AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(x) NameExpression(total) } } } } ReturnStatement(, *){ NameExpression(total) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":172,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1153,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":173,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":1070,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":174,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1 or 0:\n        return 1\n    else:\n        return n * product(n - 1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1 or 0:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n","Time":1172,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1 or 0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":175,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        v = v * term(x) =>           \r\n        v = v * x       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    v = x\n    while n > 0:\n        v = v * x\n        x = x + 1\n        n = n - 1\n    return v \n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    v = x\n    while n > 0:\n        v = v * term(x)\n        x = x + 1\n        n = n - 1\n    return v \n\n\n\n\n","Time":2432,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(v) BinaryExpression(Multiply, *){ NameExpression(v) NameExpression(x) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(v) NameExpression(x, *) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(v) BinaryExpression(Multiply, *){ NameExpression(v) NameExpression(x) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":176,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1071,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n<2:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":177,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        product *= term(counter) =>           \r\n        product *= counter       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter, product = 1, 1\n    while counter <= n:\n        product *= counter\n        counter += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter, product = 1, 1\n    while counter <= n:\n        product *= term(counter)\n        counter += 1\n    return product\n\n","Time":2341,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-counter)))))), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) NameExpression(counter) } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(product) NameExpression(counter, *) })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) NameExpression(counter) } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":178,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return product(n-1, term) * term(n) =>           \r\n    return product(n-1, term) * n       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return 1\n    return product(n-1, term) * n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return 1\n    return product(n-1, term) * term(n)\n\n","Time":1210,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if (n==1):\r\n        return 1\r\n    return product(n-1, term)*term(n)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } NameExpression(n) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":179,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 0: \n        return 1\n    else:\n        return n * product(n-1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 0: \n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n\n","Time":1191,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n<=0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":180,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n                        =>           \r\n        total *=term(i) =>           \r\n        term(i)         <=           \r\n        total *=i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total =1\n    while i <= n:\n        term(i)\n        total *=i\n        i+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total =1\n    while i <= n:\n\n        total *=term(i)\n        i+=1\n    return total\n\n","Time":2437,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Multiply){ NameExpression(total) NameExpression(i) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Multiply, *){ NameExpression(total) NameExpression(i) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ ExpressionStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Multiply){ NameExpression(total) NameExpression(i) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":181,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return n * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":1136,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":182,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    while count < n:                =>           \r\n        value = value * term(count) =>           \r\n    return value * term(n)          =>           \r\n    while count != n:               <=           \r\n        value *= term(count)        <=           \r\n    return value                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    value = 1\n    while count != n:\n        value *= term(count)\n        count += 1\n    return value\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    value = 1\n    while count < n:\n        value = value * term(count)\n        count += 1\n    return value * term(n)\n\n\n","Time":2329,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-count), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual, *){ NameExpression(count) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-value), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-count)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-value), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-value), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-count)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(count) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(count) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-value), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(count) literal(1) } AssignmentStatement(){ NameExpression(value) literal(1) } WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(count) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } } ReturnStatement(, *){ NameExpression(value) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ NameExpression(value, *) })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(count) literal(1) } AssignmentStatement(){ NameExpression(value) literal(1) } WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(count) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } } ReturnStatement(, *){ NameExpression(value) } }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":183,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            total = total * term(x)     =>           \r\n            total = total * term(x - 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    def helper(x, total):\n        if x == 1:\n            return total\n        else:\n            total = total * term(x - 1)\n            return helper(x - 1, total)\n    return helper(n, total)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    def helper(x, total):\n        if x == 1:\n            return total\n        else:\n            total = total * term(x)\n            return helper(x - 1, total)\n    return helper(n, total)\n\n","Time":2491,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(x) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(x, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":184,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    def multi(x,func):                     =>           \r\n            return func(n)                 =>           \r\n            return multi(x+1,func)*func(x) =>           \r\n    return multi(1,term)                   =>           \r\n    def multi(x):                          <=           \r\n            return term(n)                 <=           \r\n            return term(x+1)*x             <=           \r\n    return multi(1)                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def multi(x):\n        if x==n:\n            return term(n)\n        else:\n            return term(x+1)*x\n    return multi(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def multi(x,func):\n        if x==n:\n            return func(n)\n        else:\n            return multi(x+1,func)*func(x)\n    return multi(1,term)\n\n","Time":2518,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, LeafConstNode(Parameter-func), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } FunctionDefinition(multi, *){ Parameter(x) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } NameExpression(x) } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(multi) Arg(){ literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-func)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-multi)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-func))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } NameExpression(x) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-func), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } NameExpression(x, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } NameExpression(x) } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(multi) Arg(){ literal(1) } } }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":185,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    x, y = n, 1                   =>           \r\n    while x >= 1:                 =>           \r\n        x, y = x - 1, y * term(x) =>           \r\n    return y                      =>           \r\n    while x >= 1:                 =>           \r\n        temp = x                  =>           \r\n        y = y * term(temp)        =>           \r\n                                  =>           \r\n    while x > 1:                  <=           \r\n        y = y * term(x)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = n\n    y = 1\n    while x > 1: \n        x -= 1\n        y = y * term(x)\n    return y \n\n    \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x, y = n, 1\n    while x >= 1:\n        x, y = x - 1, y * term(x)\n    return y\n\n    x = n\n    y = 1\n    while x >= 1: \n        temp = x \n        x -= 1\n        y = y * term(temp)\n    return y \n\n    \n","Time":2543,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-y)))), SingleChild(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AssignmentStatement(){ NameExpression(y) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(x) literal(1) } SuiteStatement(){ AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(y) BinaryExpression(Multiply){ NameExpression(y) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } ReturnStatement(){ NameExpression(y) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-GreaterThanOrEqual, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-y)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-y), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AssignmentStatement(){ NameExpression(y) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(x) literal(1) } SuiteStatement(){ AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(y) BinaryExpression(Multiply){ NameExpression(y) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } ReturnStatement(){ NameExpression(y) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-y))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AssignmentStatement(){ NameExpression(y) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(x) literal(1) } SuiteStatement(){ AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(y) BinaryExpression(Multiply){ NameExpression(y) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } ReturnStatement(){ NameExpression(y) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThanOrEqual, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(x) literal(1) } SuiteStatement(){ AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(y) BinaryExpression(Multiply){ NameExpression(y) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-temp), SingleChild(LeafConstNode(NameExpression-x)))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(x) literal(1) } SuiteStatement(, *){ AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } AssignmentStatement(){ NameExpression(y) BinaryExpression(Multiply){ NameExpression(y) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-temp)), Selected(\\x => Match(x, Arg(){ NameExpression(x, *) }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":186,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while x<n+1: =>           \r\n    while x<n:   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=1\n    total=1\n    while x<n:\n        total=total*term(x)\n        x+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=1\n    total=1\n    while x<n+1:\n        total=total*term(x)\n        x+=1\n    return total\n\n","Time":2658,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x = 1\r\n    total = 1\r\n    while x<n+1:\r\n        total = total*term(x)\r\n        x += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(LessThan){ NameExpression(x) NameExpression(n, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(LessThan){ NameExpression(x) NameExpression(n, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":187,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k < n:\n        total, k = total * term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":824,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<n:\r\n        total, k = total*term(k+1), k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(k) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(k, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":188,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return term(n-1)                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":2665,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":189,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total \n\n\n","Time":742,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<n:\r\n        total = total*term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":190,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    sum = 1\n    while i < n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    sum = 1\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n\n\n","Time":768,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    sum = 1\r\n    while i<n:\r\n        sum = sum*term(i+1)\r\n        i += 1\r\n    return sum","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":191,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    while n + 1 > x: =>           \r\n    while n > x:     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x , total = 1 , 1\n    while n > x:\n        total = total * term(x) \n        x += 1\n    return total \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x , total = 1 , 1\n    while n + 1 > x:\n        total = total * term(x) \n        x += 1\n    return total \n\n","Time":2746,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(n) NameExpression(x) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(GreaterThan){ NameExpression(n, *) NameExpression(x) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(n) NameExpression(x) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":192,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    while k <= n:               =>           \r\n    fact = product(n, identity) =>           \r\n    return fact                 =>           \r\n    while k < n:                <=           \r\n    \"*** YOUR CODE HERE ***\"    <=           \r\n    return _______              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = 1\n    while k < n:\n        num = term(k)\n        product *= num\n        k += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = 1\n    while k <= n:\n        num = term(k)\n        product *= num\n        k += 1\n    return product\n\n","Time":878,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k = 1\r\n    product = 1\r\n    while k<n:\r\n        num = term(k+1)\r\n        product *= num\r\n        k += 1\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(k) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(k, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":193,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n            return term(n) =>           \r\n            return 1       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        if i == n:\n            return 1\n        else:\n            return term(i) * counter(i+1)\n    return counter(1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        if i == n:\n            return term(n)\n        else:\n            return term(i) * counter(i+1)\n    return counter(1)\n\n\n","Time":773,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return 1\r\n        else:\r\n            return term(i+1)*counter(i+1)\r\n    return counter(1)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, ReturnStatement(){ literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(1, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(1) } }), InOrderSort(ast)))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":194,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(1, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n):\n        if term == identity:\n            total *= i\n        elif term == square:\n            total *= square(i)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n+1):\n        if term == identity:\n            total *= i\n        elif term == square:\n            total *= square(i)\n    return total\n\n\n","Time":2987,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(1, n+1):\r\n        if term==identity:\r\n            total *= i\r\n        elif term==square:\r\n            total *= square(i)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":195,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        product = product * term(i + 1) =>           \r\n        product = product * term(i)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product = term(1)\n    for i in range(1, n):\n\t    product = product * term(i)\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product = term(1)\n    for i in range(1, n):\n\t    product = product * term(i + 1)\n    return product\n\n","Time":730,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    product = term(1)\r\n    for i in range(1, n):\r\n        product = product*term(i+1)\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":196,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        if k < n:                          =>           \r\n            return term(k) * helper(k + 1) =>           \r\n        elif k == n:                       =>           \r\n        if k <= n:                         <=           \r\n            return term(k) * term(k + 1)   <=           \r\n        else:                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k):\n        if k <= n:\n            return term(k) * term(k + 1)\n        else: \n            return term(k) \n    return helper(1) \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k):\n        if k < n:\n            return term(k) * helper(k + 1)\n        elif k == n: \n            return term(k) \n    return helper(1) \n\n","Time":24813,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(LessThanOrEqual, *){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-helper)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))))))), 1), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } } } SuiteStatement(, *){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":197,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","Time":8870,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i, total = 1, 1\r\n    while i<n:\r\n        total = total*term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":198,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","Time":766,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<n:\r\n        total = total*term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":199,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    counter = n - 1                   <=           \r\n    while counter > 0:                <=           \r\n        total = total * term(counter) <=           \r\n        counter -= 1                  <=           \r\n    total = 1                         <=           \r\n    return total                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    counter = n - 1\n    while counter > 0:\n        total = total * term(counter)\n        counter -= 1\n    return total\n\n    total = 1\n    for i in range(1, n+1, 1):\n        total = total * term(i)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total = 1\n    for i in range(1, n+1, 1):\n        total = total * term(i)\n    return total\n\n","Time":2959,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(, *){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(, *){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(, *){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(counter) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(counter) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Subtract){ NameExpression(counter) literal(1) } } } ReturnStatement(){ NameExpression(total) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } Arg(){ literal(1) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":200,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    i = 1                           =>           \r\n    result = 1                      =>           \r\n    while i <= n:                   =>           \r\n        result *= term(i)           =>           \r\n        i += 1                      =>           \r\n    return result                   =>           \r\n    if n == 1:                      <=           \r\n        return term(1)              <=           \r\n    elif n == 2:                    <=           \r\n        return term(1) * term(2)    <=           \r\n    else:                           <=           \r\n        return product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n == 2:\n        return term(1) * term(2)\n    else:\n        return product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    result = 1\n    while i <= n:\n        result *= term(i)\n        i += 1\n    return result\n\n","Time":3062,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-result)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, CallExpression(){ NameExpression(term) Arg(, *){ literal(1) } })), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ literal(1, *) }), 1), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-result), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n, *) literal(2) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(2, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, Arg(){ literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-result), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i))))))))), 0), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(, *){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ literal(2) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ literal(2, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, CallExpression(){ NameExpression(term) Arg(, *){ literal(2) } })), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(, *){ NameExpression(term) Arg(){ literal(2) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ literal(2, *) }), 1), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(, *){ NameExpression(term) Arg(){ literal(2) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(, *){ NameExpression(term) Arg(){ literal(2) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ReturnStatement(, *){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } })), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(, *){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(, *){ NameExpression(term) Arg(){ literal(2) } } }), 1), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(, *){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-result), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-result)), Selected(\\x => Match(x, Arg(){ NameExpression(term, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ CallExpression(, *){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ NameExpression(term, *) }), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } }), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(2) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(term) Arg(){ literal(2) } } } } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), InOrderSort(ast)))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":201,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = i\n    while i < n:\n        total = total * term(i)\n        i = increment(i)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = i\n    while i <= n:\n        total = total * term(i)\n        i = increment(i)\n    return total\n\n","Time":767,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = i\r\n    while i<n:\r\n        total = total*term(i+1)\r\n        i = increment(i)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":202,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if i > n:  =>           \r\n        if i == n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i == n:\n            return 1\n        return term(i) * helper(i + 1)\n    return helper()\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            return 1\n        return term(i) * helper(i + 1)\n    return helper()\n\n\n","Time":817,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def helper(i = 1):\r\n        if i==n:\r\n            return 1\r\n        return term(i+1)*helper(i+1)\r\n    return helper()","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":203,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    for i in range(1,n):\n        number=term(i)\n        product=product*number\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    for i in range(1,n+1):\n        number=term(i)\n        product=product*number\n    return product\n\n","Time":879,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    product = 1\r\n    for i in range(1, n):\r\n        number = term(i+1)\r\n        product = product*number\r\n    return product","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":204,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while i < n+1: =>           \r\n    while i != n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i != n:\n        total = total * term(i)\n        i +=1\n    return total\n    \"\"\"def helper(i, total):\n        if i<n:\n            return helper(i+1, total*term(i))\n        else:\n            return total\n    helper(1,0)\"\"\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n+1:\n        total = total * term(i)\n        i +=1\n    return total\n    \"\"\"def helper(i, total):\n        if i<n:\n            return helper(i+1, total*term(i))\n        else:\n            return total\n    helper(1,0)\"\"\"\n\n","Time":780,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i!=n:\r\n        total = total*term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-i), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual, *){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":205,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while k<n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,mul = 1,1\n    while k<n:\n        k, mul = k+1, mul*term(k)\n    return mul\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,mul = 1,1\n    while k<=n:\n        k, mul = k+1, mul*term(k)\n    return mul\n\n\n","Time":862,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, mul = 1, 1\r\n    while k<n:\r\n        k, mul = k+1, mul*term(k+1)\r\n    return mul","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(k) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(k, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":206,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while a <= n: =>           \r\n    while a < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total,a = 1,1\n    while a < n:\n        a, total = a+1 , term(a) * total\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total,a = 1,1\n    while a <= n:\n        a, total = a+1 , term(a) * total\n    return total\n\n","Time":3464,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-a), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(a) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(a) NameExpression(total) } TupleExpression(){ BinaryExpression(Add){ NameExpression(a) literal(1) } BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } NameExpression(total) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":207,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    i = 1                =>           \r\n    while i<=n:          =>           \r\n    for i in range(1,n): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1;\n    for i in range(1,n):\n        total = total*term(i)\n        i+=1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1;\n    i = 1\n    while i<=n:\n        total = total*term(i)\n        i+=1\n    return total\n\n\n","Time":836,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for i in range(1, n):\r\n        total = total*term(i+1)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) literal(1) } } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ NameExpression(n) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) literal(1) } } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ NameExpression(n) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) literal(1) } } ForStatement(, *){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ NameExpression(n) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) literal(1) } } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ NameExpression(n) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":208,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n    while count < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = 1\n    while count < n:\n        product = product * term(count)\n        count += 1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = 1\n    while count <= n:\n        product = product * term(count)\n        count += 1\n    return product\n\n","Time":3630,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-count), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(count) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(count) } } } } AugmentedAssignStatement(Add){ NameExpression(count) literal(1) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":209,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(1, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    j = 1\n    for i in range(1, n):\n    \tj*=term(i)\n    return j\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    j = 1\n    for i in range(1, n+1):\n    \tj*=term(i)\n    return j\n\n","Time":787,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    j = 1\r\n    for i in range(1, n):\r\n        j *= term(i+1)\r\n    return j","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(, *){ NameExpression(n) } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":210,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    while x < n+1:                      =>           \r\n    x = 1                               =>           \r\n        return product(n, increment(x)) =>           \r\n    return _______                      <=           \r\n    \"*** YOUR CODE HERE ***\"            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    total = 1\n    while x < n:\n        total = total*term(x)\n        x += 1\n    return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    total = 1\n    while x < n+1:\n        total = total*term(x)\n        x += 1\n    return total\n\n","Time":2900,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    x = 1\r\n    total = 1\r\n    while x<n+1:\r\n        total = total*term(x)\r\n        x += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(LessThan){ NameExpression(x) NameExpression(n, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(LessThan){ NameExpression(x) NameExpression(n, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":211,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x <= n: =>           \r\n    while x != n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1    \n    while x != n:\n        total = term(x) * total \n        x = x + 1  \n    return total  \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1    \n    while x <= n:\n        total = term(x) * total \n        x = x + 1  \n    return total  \n\n","Time":3730,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } NameExpression(total) } } AssignmentStatement(){ NameExpression(x) BinaryExpression(Add){ NameExpression(x) literal(1) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":212,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n  #  if n == 1:\n   #     return term(1)\n    #else:\n     #   return term(n) * product(n - 1, term)\n    counter = 1\n    total = 1\n    while counter < n:\n        total = total * term(counter) \n        counter += 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n  #  if n == 1:\n   #     return term(1)\n    #else:\n     #   return term(n) * product(n - 1, term)\n    counter = 1\n    total = 1\n    while counter <= n:\n        total = total * term(counter) \n        counter += 1\n    return total\n\n\n","Time":3941,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(counter) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":213,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    while n >= i:                      =>           \r\n    # return ________                  =>           \r\n    while n > 0:                       =>           \r\n        return (product(n -  1, term)) =>           \r\n    while n > i:                       <=           \r\n    return _______                     <=           \r\n                                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    i = 1\n    while n > i:\n        total *= term(i)\n        #n = n - 1\n        i = i + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    i = 1\n    while n >= i:\n        total *= term(i)\n        #n = n - 1\n        i = i + 1\n    return total\n\n","Time":879,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    i = 1\r\n    while n>i:\r\n        total *= term(i+1)\r\n        i = i+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThanOrEqual, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(NameExpression-i))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(n) NameExpression(i) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AssignmentStatement(){ NameExpression(i) BinaryExpression(Add){ NameExpression(i) literal(1) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":214,"diff":"","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k < n:\n        n -= 1\n        total = total * term(n)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k < n:\n        total = total * term(n)\n        n -= 1\n    return total\n\n","Time":4234,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(1) } AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":215,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            total = total * term(n)     =>           \r\n            total = total * term(n - 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def functions(n, term, total):\n        if n == 1:\n            return total\n        else:\n            total = total * term(n - 1)\n            return functions(n - 1, term, total)\n    return functions(n, term, 1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def functions(n, term, total):\n        if n == 1:\n            return total\n        else:\n            total = total * term(n)\n            return functions(n - 1, term, total)\n    return functions(n, term, 1)\n\n","Time":270,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    def functions(n, term, total):\r\n        if n==1:\r\n            return total\r\n        else:\r\n            total = total*term(n)\r\n            return functions(n-1, term, total)\r\n    return functions(n, term, 1)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":216,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    while i != n+1: =>           \r\n    while i != n:   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    thing = 1\n    while i != n:\n        thing *= term(i)\n        i += 1\n    return thing\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    thing = 1\n    while i != n+1:\n        thing *= term(i)\n        i += 1\n    return thing\n\n","Time":916,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    thing = 1\r\n    while i!=n:\r\n        thing *= term(i+1)\r\n        i += 1\r\n    return thing","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual, *){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(thing) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(NotEqual){ NameExpression(i) NameExpression(n, *) })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual, *){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(thing) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":217,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        i, total = i + 1, total * term(i)\n    return total\n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        i, total = i + 1, total * term(i)\n    return total\n\n\n\n\n","Time":1184,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<n:\r\n        i, total = i+1, total*term(i+1)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, BinaryExpression(LessThan, *){ NameExpression(i) NameExpression(n) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(i, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(i) } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":218,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":4192,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":219,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n    total = 1                                               =>           \r\n        total, counter = total * term(counter), counter + 1 =>           \r\n    total = 0                                               <=           \r\n        total, counter = total + term(counter), counter + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    total = 0\n    while counter <= n:\n        total, counter = total + term(counter), counter + 1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    total = 1\n    while counter <= n:\n        total, counter = total * term(counter), counter + 1\n    return total\n\n\n","Time":4046,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-counter)))))))))), Selected(\\x => Match(x, TupleExpression(){ BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } BinaryExpression(Add){ NameExpression(counter) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":220,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    prod = 1                  =>           \r\n        prod = prod * term(i) =>           \r\n    prod = 0                  <=           \r\n        prod += term(i)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    prod = 0\n    while i < n + 1:\n        prod += term(i)\n        i += 1\n    return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    prod = 1\n    while i < n + 1:\n        prod = prod * term(i)\n        i += 1\n    return prod\n\n","Time":3998,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(prod) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-prod), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(prod) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-prod), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-prod), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(i) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(prod) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(prod) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(i) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(prod) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":221,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n    value=1                                           =>           \r\n            return find_value(value*term(n),n-1,term) =>           \r\n    value=0                                           <=           \r\n            return find_value(value+term(n),n-1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value=0\n    def find_value(value, n, term):\n        if n<=0:\n            return value\n        else:\n            return find_value(value+term(n),n-1,term)\n    return find_value(value, n, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value=1\n    def find_value(value, n, term):\n        if n<=0:\n            return value\n        else:\n            return find_value(value*term(n),n-1,term)\n    return find_value(value, n, term)\n\n","Time":4502,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(value) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-value), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))))), Selected(\\x => Match(x, Arg(){ BinaryExpression(Add, *){ NameExpression(value) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":222,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 1:                                =>           \r\n        return term(1)                        =>           \r\n        return term(n) * product(n - 1, term) =>           \r\n    if n == 0:                                <=           \r\n        return 0                              <=           \r\n        return term(n) + product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) + product(n - 1, term)\n    \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n    \n","Time":4502,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(0, *) })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(0) } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":223,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total = 1                             =>           \r\n        total, n = total * term(n), n - 1 =>           \r\n    total = 0                             <=           \r\n        total, n = total + term(n), n - 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n > 0:\n        total, n = total + term(n), n - 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total, n = total * term(n), n - 1\n    return total\n\n","Time":4422,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))))), Selected(\\x => Match(x, TupleExpression(){ BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } BinaryExpression(Subtract){ NameExpression(n) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":224,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    k, product = 1, 1               =>           \r\n        product = product * term(k) =>           \r\n    return product                  =>           \r\n    k, sum = 1, 0                   <=           \r\n        sum += term(k)              <=           \r\n    return sum                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 0\n    while k <= n:\n        sum += term(k)\n        k += 1\n    return sum\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k <= n:\n        product = product * term(k)\n        k += 1\n    return product\n\n","Time":3910,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, TupleExpression(){ NameExpression(k) NameExpression(sum, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(1) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(sum, *) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-product), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(sum) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-product), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-product), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(sum) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(sum) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(sum) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, ReturnStatement(){ NameExpression(sum, *) }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":225,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return term(i) * mult_up(i+1) =>           \r\n        return term(i) + mult_up(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def mult_up(i):\n        if(i==n):\n            return term(n)\n        return term(i) + mult_up(i+1)\n\n    return mult_up(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def mult_up(i):\n        if(i==n):\n            return term(n)\n        return term(i) * mult_up(i+1)\n\n    return mult_up(1)\n\n","Time":3758,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-mult_up), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(mult_up) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":226,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    k, total = 1, 1             =>           \r\n        total = total * term(k) =>           \r\n    k, total = 1, 0             <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 0\n    while k <= n:\n        total = total + term(k)\n        k += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","Time":3936,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, total = 1, 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":227,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n            return term(i)* counter(i+1) =>           \r\n            return term(i)+ counter(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return term(i)+ counter(i+1)\n    return counter(1)        \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return term(i)* counter(i+1)\n    return counter(1)        \n\n\n","Time":25850,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-counter), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(counter) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":228,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n    return product(n, identity)               =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n    return _______                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":6491,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":229,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n        total = total * term(k) =>           \r\n    total = 0                   <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    for k in range(1, n+1):\n        total = total + term(k)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for k in range(1, n+1):\n        total = total * term(k)\n    return total\n\n\n","Time":3964,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    for k in range(1, n+1):\r\n        total = total*term(k)\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":230,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n        return product(n-1,term) * term(n)     =>           \r\n        return product(n-1,term) + term(n)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n-1,term) + term(n)    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n-1,term) * term(n)    \n\n","Time":3758,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":231,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n            return term(R) * helper(R+1) =>           \r\n            return term(R) + helper(R+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper (R) :\n        if R == n :\n            return term(n)\n        else :\n            return term(R) + helper(R+1)\n    return helper(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper (R) :\n        if R == n :\n            return term(n)\n        else :\n            return term(R) * helper(R+1)\n    return helper(1)\n\n","Time":4114,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-R)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-helper), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-R), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(R) } } CallExpression(){ NameExpression(helper) Arg(){ BinaryExpression(Add){ NameExpression(R) literal(1) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":232,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)\n\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n    \n\n","Time":4221,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":233,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return 1                            =>           \r\n        return term(n) * product(n-1, term) =>           \r\n        return 0                            <=           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 0\n    else:\n        return term(n) + product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":3864,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ReturnStatement(){ literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":234,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":3584,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":235,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n                                              =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n                                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":3529,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":236,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return term(n)* product(n-1, term) =>           \r\n    return term(n)+ product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    return term(n)+ product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    return term(n)* product(n-1, term)\n\n","Time":3507,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return n\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":237,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            return term(i) * terminater(i+1) =>           \r\n            return term(i) + terminater(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def terminater(i):\n        if i == n:\n            return term(i) \n        else:\n            return term(i) + terminater(i+1)\n\n    return terminater(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def terminater(i):\n        if i == n:\n            return term(i) \n        else:\n            return term(i) * terminater(i+1)\n\n    return terminater(1)\n\n","Time":25150,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-terminater), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(terminater) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":238,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return term(n) * product(n-1, term)     =>           \r\n        return term(n) + product(n-1, term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) + product(n-1, term)    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)    \n\n","Time":6785,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":239,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return term(n) * product(n-1,term) =>           \r\n    return term(n) + product(n-1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) + product(n-1,term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1,term)\n\n","Time":3666,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":240,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n            return term_a(x) * helper_a(x+1, term) =>           \r\n            return term_a(x) + helper_a(x+1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    y = 1\n    def helper_a(x, term_a):\n        if x == n:\n            return term_a(x)\n        else:\n            return term_a(x) + helper_a(x+1, term)\n    return helper_a(y, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    y = 1\n    def helper_a(x, term_a):\n        if x == n:\n            return term_a(x)\n        else:\n            return term_a(x) * helper_a(x+1, term)\n    return helper_a(y, term)\n\n","Time":3801,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term_a), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-helper_a), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term_a) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_a) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":241,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n","Time":3611,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":242,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n        total *= term(x)        =>           \r\n    return product(n, identity) =>           \r\n    total = combiner(base, n)   =>           \r\n    x = 1                       =>           \r\n    while not x > n:            =>           \r\n        total (x)               =>           \r\n        x += 1                  =>           \r\n    return total                =>           \r\n    total = 0                   <=           \r\n        total += term(x)        <=           \r\n    return _______              <=           \r\n    \"*** YOUR CODE HERE ***\"    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    x = 1\n    while not x > n:\n        total += term(x)\n        x += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    x = 1\n    while not x > n:\n        total *= term(x)\n        x += 1\n    return total\n\n","Time":3904,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } AugmentedAssignStatement(Add){ NameExpression(x) literal(1) } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":243,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    total = 1               =>           \r\n        total=total*term(i) =>           \r\n    total = 0               <=           \r\n        total += term(i)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i<=n:\n        total += term(i)\n        i+=1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i<=n:\n        total=total*term(i)\n        i+=1\n    return total\n\n","Time":3961,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(total) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Add){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":244,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total, k = 1, 1                       =>           \r\n        total, k = total * term(k), k + 1 =>           \r\n    total, k = 0, 1                       <=           \r\n        total, k = total + term(k), k + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n\n\n","Time":9085,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":245,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    k, prod = 1, 1                      =>           \r\n        k, prod = k + 1, prod * term(k) =>           \r\n    k, prod = 1, 0                      <=           \r\n        k, prod = k + 1, prod + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1, 0\n    while k <= n:\n        k, prod = k + 1, prod + term(k)\n    return prod\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1, 1\n    while k <= n:\n        k, prod = k + 1, prod * term(k)\n    return prod\n\n\n","Time":4119,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, TupleExpression(){ literal(1) literal(0, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-prod), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, TupleExpression(){ BinaryExpression(Add){ NameExpression(k) literal(1) } BinaryExpression(Add, *){ NameExpression(prod) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":246,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total, k = 1, 1             =>           \r\n        total = total * term(k) =>           \r\n    total, k = 0, 1             <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total = total + term(k)\n        k = k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n","Time":4113,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total, k = 1, 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, BinaryExpression(Add, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":247,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n    return product(n, identity)               =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n    return _______                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":3818,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":248,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)\n\n\n\n\"\"\"\n    def sum_product(n):\n        total = 0\n        k = 1\n        while k < n:\n            total = total + term(k)\n            sum_product(n-1)\n    return sum_product(n)\"\"\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n\n\"\"\"\n    def sum_product(n):\n        total = 0\n        k = 1\n        while k < n:\n            total = total + term(k)\n            sum_product(n-1)\n    return sum_product(n)\"\"\"\n\n","Time":3766,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":249,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    result = term(1)              =>           \r\n    for i in range (1, n+1):      =>           \r\n        result = term(i) * result =>           \r\n    return result                 =>           \r\n    \"*** YOUR CODE HERE ***\"      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(1)\n    for i in range (1, n+1):\n        result = term(i) * result\n    return result \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":250,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n                                                =>           \r\n    if n == 1:                                  =>           \r\n        return term(n)                          =>           \r\n    else:                                       =>           \r\n        return term(n) * product(n-1, term)     =>           \r\n    def inner_product(n):                       <=           \r\n        if n == 1:                              <=           \r\n            return term(n)                      <=           \r\n        else:                                   <=           \r\n            return term(n) * product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def inner_product(n):\n        if n == 1:\n            return term(n)\n        else:\n            return term(n) * product(n-1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n\n","Time":3848,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(inner_product, *){ Parameter(n) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(inner_product){ Parameter(n) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } }), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(inner_product){ Parameter(n) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":251,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n            return total                              =>           \r\n        else:                                         =>           \r\n            return total_prod(x+1, total * term(x+1)) =>           \r\n    return product(n, identity)                       =>           \r\n            return total * term(x)                    <=           \r\n        #else:                                        <=           \r\n            #return product(x+1, total * term(x+1))   <=           \r\n    product()                                         <=           \r\n    return _______                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def total_prod(x, total):\n        if x == n:\n            return total * term(x)\n        #else:\n            #return product(x+1, total * term(x+1))\n    return total_prod(1, 1)\n\n# term becomes 1 instead of staying as square\n    # n goes down 1 every time you go through the code until it reaches 1, where\n    # you just return the total\n    # everytime you go through the loop, multiply the term applied to n by\n    # the term applied to (n-1) since you decrease 1 each time until you reach 1.\n    # but every time you go through the loop, you need to multiply your previous\n    # term(n) you got to total\n    #base case--> start from n and go down to 1\n    # if n is 1, return 1 * total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def total_prod(x, total):\n        if x == n:\n            return total\n        else:\n            return total_prod(x+1, total * term(x+1))\n    return total_prod(1, 1)\n\n# term becomes 1 instead of staying as square\n    # n goes down 1 every time you go through the code until it reaches 1, where\n    # you just return the total\n    # everytime you go through the loop, multiply the term applied to n by\n    # the term applied to (n-1) since you decrease 1 each time until you reach 1.\n    # but every time you go through the loop, you need to multiply your previous\n    # term(n) you got to total\n    #base case--> start from n and go down to 1\n    # if n is 1, return 1 * total\n\n","Time":3947,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total)))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(x, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-total_prod), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))))))))))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(, *){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } }), 1), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } } }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":252,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if n < 1 or not isinstance(n, int):      =>           \r\n        print(\"n is not a positive integer\") =>           \r\n        return -99                           =>           \r\n    if n == 1:                               =>           \r\n        return term(1)                       =>           \r\n    return term(n) * product(n-1, term)      =>           \r\n                                             =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1 or not isinstance(n, int):\n        print(\"n is not a positive integer\")\n        return -99\n\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":253,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    i = 1                                 =>           \r\n    def helper(n,i,term):                 =>           \r\n        if i == n:                        =>           \r\n        return term(i)*helper(n,i+1,term) =>           \r\n    return helper(n,i,term)               =>           \r\n    i, product = 1, 0                     <=           \r\n    def helper(n,i,term, product):        <=           \r\n        if n == i:                        <=           \r\n        product += term(i)                <=           \r\n        i += 1                            <=           \r\n    return helper(n,i,term,product)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, product = 1, 0\n    def helper(n,i,term, product):\n        if n == i:\n            return term(i)\n        product += term(i)\n        i += 1\n    return helper(n,i,term,product)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    def helper(n,i,term):\n        if i == n:\n            return term(i)\n        return term(i)*helper(n,i+1,term)\n    return helper(n,i,term)\n\n","Time":35927,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(, *){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } } FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ NameExpression(i, *) NameExpression(product) }), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } } FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AssignmentStatement(){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(, *){ literal(1) literal(0) } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } } FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, TupleExpression(){ literal(1, *) literal(0) }), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } } FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product, *) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(i) NameExpression(product) } TupleExpression(){ literal(1) literal(0) } } FunctionDefinition(helper, *){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n, *) NameExpression(i) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) NameExpression(i, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add, *){ NameExpression(i) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-helper), Children(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add, *){ NameExpression(i) literal(1) } })), Selected(\\x => Match(x, FunctionDefinition(helper){ Parameter(n) Parameter(i) Parameter(term) Parameter(product) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) NameExpression(i) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } AugmentedAssignStatement(Add){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(, *){ NameExpression(product) } })), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(helper) Arg(){ NameExpression(n) } Arg(){ NameExpression(i) } Arg(){ NameExpression(term) } Arg(){ NameExpression(product) } } }), InOrderSort(ast))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":254,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    return total  =>           \r\n                  =>           \r\n    if k <= n:    <=           \r\n                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    k = 1\n    if k <= n:\n        total = total * term(k)\n        k += 1\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total\n\n","Time":11135,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))), 5), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(k) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(k) literal(1) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(k) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatement(){ IfStatementTest(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } }), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(k) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":255,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    while counter<n:                   =>           \r\n        if term==identity:             =>           \r\n            total*=tracker             =>           \r\n            total*=(tracker**2)        =>           \r\n            tracker+=1                 =>           \r\n    return total                       =>           \r\n                                       =>           \r\n                                       =>           \r\n    while(counter>n):                  <=           \r\n        if term == identity:           <=           \r\n            total*=tracker*(tracker+1) <=           \r\n            n*=(n+1)**2                <=           \r\n        return total                   <=           \r\n                                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    counter=0\n    tracker=1\n    total=1\n    while(counter>n):\n        if term == identity:\n            total*=tracker*(tracker+1)\n            counter+=1\n            tracker+=1\n        elif term==square:\n            n*=(n+1)**2\n            counter+=1\n            \n        return total\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    counter=0\n    tracker=1\n    total=1\n    while counter<n:\n        if term==identity:\n            total*=tracker\n            tracker+=1\n            counter+=1\n            \n        elif term==square:\n            total*=(tracker**2)\n            tracker+=1\n            counter+=1\n\n    return total\n            \n\n\n","Time":4453,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(GreaterThan, *){ NameExpression(counter) NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Add){ NameExpression(tracker, *) literal(1) }), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-tracker)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(counter, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-counter)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(tracker, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, AugmentedAssignStatement(Multiply){ NameExpression(n, *) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-tracker)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(n, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-2)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(n) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Power, Children(LeafConstNode(NameExpression-tracker), SingleChild(LeafConstNode(literal-2))))), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(Add, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power, *){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Power){ ParenthesisExpression(, *){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) }), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-tracker), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThan, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-identity)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-tracker)))), Children(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-tracker), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(literal-1))))))))))), SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-term), SingleChild(LeafConstNode(NameExpression-square)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(ParenthesisExpression, SingleChild(ConstNode(BinaryExpression-Power, Children(LeafConstNode(NameExpression-tracker), SingleChild(LeafConstNode(literal-2))))))))), Children(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-tracker), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(literal-1))))))))))))))))))), 5), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(counter) literal(0) } AssignmentStatement(){ NameExpression(tracker) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(GreaterThan){ NameExpression(counter) NameExpression(n) } } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(counter) literal(0) } AssignmentStatement(){ NameExpression(tracker) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(, *){ ParenthesisExpression(){ BinaryExpression(GreaterThan){ NameExpression(counter) NameExpression(n) } } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } } } ReturnStatement(){ NameExpression(total) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(counter) literal(0) } AssignmentStatement(){ NameExpression(tracker) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(GreaterThan){ NameExpression(counter) NameExpression(n) } } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } } } ReturnStatement(, *){ NameExpression(total) } }), 6), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(counter) literal(0) } AssignmentStatement(){ NameExpression(tracker) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(GreaterThan){ NameExpression(counter) NameExpression(n) } } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(tracker) ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(tracker) literal(1) } } } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } AugmentedAssignStatement(Add){ NameExpression(tracker) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(n) BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } literal(2) } } AugmentedAssignStatement(Add){ NameExpression(counter) literal(1) } } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast)))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":256,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    def helper(n):                        =>           \r\n        if n > 0:                         =>           \r\n            return term(n) * helper(n-1)  =>           \r\n        else:                             =>           \r\n            return 1                      =>           \r\n    return helper(n)                      =>           \r\n    total = 0                             <=           \r\n    if n > 0:                             <=           \r\n        def helper(n):                    <=           \r\n            total = term(n) * helper(n-1) <=           \r\n    else:                                 <=           \r\n        return total                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    if n > 0:\n        def helper(n):\n            total = term(n) * helper(n-1)\n    else:\n        return total\n\n\n\n    # a = 1\n    # total = 0\n    # def helper(a):\n    #     if a < n:\n    #         b = term(a)\n    #         a = a + 1\n    #     return b * helper(a)\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n):\n        if n > 0:\n            return term(n) * helper(n-1)\n        else:\n            return 1\n    return helper(n)\n\n\n\n    # a = 1\n    # total = 0\n    # def helper(a):\n    #     if a < n:\n    #         b = term(a)\n    #         a = a + 1\n    #     return b * helper(a)\n\n\n\n","Time":9189,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":257,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    return f(n) =>           \r\n    f(n)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*g(n-1)\n    def g(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*f(n-1)\n    f(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*g(n-1)\n    def g(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*f(n-1)\n    return f(n)\n\n","Time":62838,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-f), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } FunctionDefinition(f){ Parameter(n) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(g) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } } } FunctionDefinition(g){ Parameter(n) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(f) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } } } ExpressionStatement(, *){ CallExpression(){ NameExpression(f) Arg(){ NameExpression(n) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":258,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    def helper(k, term):                             =>           \r\n        if k == n:                                   =>           \r\n            return term(k)                           =>           \r\n        else:                                        =>           \r\n            return term(k) * helper(k + 1, term)     =>           \r\n    return helper(1, term)                           =>           \r\n    def helper(k):                                   <=           \r\n        if k >= n:                                   <=           \r\n            return term(1) * product(k + 1, term(k)) <=           \r\n    helper(1)                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def helper(k):\n        if k >= n: \n            return term(1) * product(k + 1, term(k))\n    helper(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def helper(k, term):\n        if k == n: \n            return term(k)\n        else: \n            return term(k) * helper(k + 1, term)\n    return helper(1, term)\n\n","Time":16616,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, LeafConstNode(Parameter-term), 1), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(helper, *){ Parameter(k) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } } } } ExpressionStatement(){ CallExpression(){ NameExpression(helper) Arg(){ literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(GreaterThanOrEqual, *){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, Arg(){ literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-helper)), Selected(\\x => Match(x, CallExpression(){ NameExpression(product, *) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ CallExpression(, *){ NameExpression(term) Arg(){ NameExpression(k) } } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, CallExpression(){ NameExpression(term, *) Arg(){ NameExpression(k) } }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatement(){ IfStatementTest(, *){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } })), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } }), 1), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, ExpressionStatement(){ CallExpression(, *){ NameExpression(helper) Arg(){ literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-helper), Children(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(helper){ Parameter(k) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } } } } } } } } ExpressionStatement(, *){ CallExpression(){ NameExpression(helper) Arg(){ literal(1) } } } }), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":259,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            total *= t**2         =>           \r\n    return total                  =>           \r\n            total *= total*(t**2) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    t=1\n    total=1\n    while i < n:\n        if term == identity:\n            total *= t\n            i += 1\n            t += 1 \n        elif term == square:\n            total *= total*(t**2)\n            i += 1\n            t += 1\n\n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    t=1\n    total=1\n    while i < n:\n        if term == identity:\n            total *= t\n            i += 1\n            t += 1 \n        elif term == square:\n            total *= t**2\n            i += 1\n            t += 1\n    return total\n\n\n\n\n\n","Time":14305,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply, *){ NameExpression(total) ParenthesisExpression(){ BinaryExpression(Power){ NameExpression(t) literal(2) } } } })), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ BinaryExpression(Power){ NameExpression(t) literal(2) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } AugmentedAssignStatement(Add){ NameExpression(t) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, ParenthesisExpression(){ BinaryExpression(Power, *){ NameExpression(t) literal(2) } }), 1), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ BinaryExpression(Power){ NameExpression(t) literal(2) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } AugmentedAssignStatement(Add){ NameExpression(t) literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))), 5), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(i) literal(0) } AssignmentStatement(){ NameExpression(t) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThan){ NameExpression(i) NameExpression(n) } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) NameExpression(t) } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } AugmentedAssignStatement(Add){ NameExpression(t) literal(1) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(square) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ BinaryExpression(Power){ NameExpression(t) literal(2) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } AugmentedAssignStatement(Add){ NameExpression(t) literal(1) } } } } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":260,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(1)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    return product(n, mul)                  =>           \r\n    else:                                   =>           \r\n                                            =>           \r\n    return _______                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":261,"diff":"\r\nInputObject                                                   SideIndicator\r\n-----------                                                   -------------\r\nfrom functools import reduce                                  =>           \r\nimport operator                                               =>           \r\n    return reduce(operator.mul, map(term, range(1, n+1)), 1)  =>           \r\n    \"\"\"                                                       =>           \r\n    return product(n, identity)                               =>           \r\n    return _______                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                  <=           \r\n    \"\"\"                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return reduce(operator.mul, map(term, range(1, n+1)), 1) \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":262,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    if n==1:                               =>           \r\n        return 1                           =>           \r\n        return term(n) * product(n-1,term) =>           \r\n    return product(n,product)              =>           \r\n    if n==0 or n==1:                       =>           \r\n        return 1                           =>           \r\n    else:                                  =>           \r\n        n=1                                =>           \r\n        return n*factorial(n-1)            =>           \r\n    else:                                  =>           \r\n                                           =>           \r\n                                           =>           \r\n                                           =>           \r\n    \"*** YOUR CODE HERE ***\"               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n    \treturn 1\n    else:\n    \treturn term(n) * product(n-1,term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, ExpressionStatement(){ literal(*** YOUR CODE HERE ***, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(literal-1)))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":263,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    x = 1                       =>           \r\n    func = lambda y: term(y)    =>           \r\n    track = 1                   =>           \r\n    while x <= n:               =>           \r\n        track = track * func(x) =>           \r\n        x += 1                  =>           \r\n    return track                =>           \r\n                                =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    func = lambda y: term(y)\n    track = 1\n    while x <= n:\n    \ttrack = track * func(x)\n    \tx += 1\n    return track\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":264,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 1:                                                      =>           \r\n        return term(1)                                              =>           \r\n    return term(n)*product(n-1, term)                               =>           \r\n    if n == 0:                                                      =>           \r\n        return 1                                                    =>           \r\n    return product(n, identity)                                     =>           \r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return accumulate(add, 0, n, term)                              =>           \r\n                                                                    =>           \r\n    x = 1                                                           <=           \r\n    def helper_fxn(x, term):                                        <=           \r\n        if x <= n:                                                  <=           \r\n            return term(x) * helper_fxn(x+1, term)                  <=           \r\n        else:                                                       <=           \r\n            return 0                                                <=           \r\n    return _______                                                  <=           \r\n    return _______                                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    def helper_fxn(x, term):\n        if x <= n:\n            return term(x) * helper_fxn(x+1, term)\n        else:\n            return 0\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n)*product(n-1, term)\n\n","Time":15535,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(x, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(, *){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(x, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(LessThanOrEqual, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(, *){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, Arg(){ NameExpression(x, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(helper_fxn, *) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(x, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, Arg(){ BinaryExpression(Add, *){ NameExpression(x) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn, *){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ ReturnStatement(, *){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(x) literal(1) } FunctionDefinition(helper_fxn){ Parameter(x) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(helper_fxn) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } Arg(){ NameExpression(term) } } } } } } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } } } }), InOrderSort(ast)))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":265,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    k, total = 1, 1                       =>           \r\n    while k <= n:                         =>           \r\n        total, k = total * term(k), k + 1 =>           \r\n    return total                          =>           \r\n    return n * product(n - 1, identity)   =>           \r\n    return Y(________)  # Replace         =>           \r\n    return _______                        <=           \r\n    return Y(________)  # Replace         <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-total)))), SingleChild(ConstNode(TupleExpression-False, Children(LeafConstNode(literal-1), SingleChild(LeafConstNode(literal-1))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-k)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, ExpressionStatement(){ literal(*** YOUR CODE HERE ***, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":266,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if n == 1:                            =>           \r\n        return term(n)                    =>           \r\n        return term(n)*product(n-1, term) =>           \r\n    else:                                 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":267,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    if n == 1:                             =>           \r\n        return term(n)                     =>           \r\n    else:                                  =>           \r\n        return term(n)*product(n-1, term)  =>           \r\n    #if n == 1:                            <=           \r\n    #    return term(n)                    <=           \r\n    #else:                                 <=           \r\n    #    return term(n)*product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #i, total = 1, 1\n    #while i <= n:\n    #    total = total * term(i)\n    #    i += 1\n    #return total\n    #if n == 1:\n    #    return term(n)\n    #else: \n    #    return term(n)*product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #i, total = 1, 1\n    #while i <= n:\n    #    total = total * term(i)\n    #    i += 1\n    #return total\n    if n == 1:\n        return term(n)\n    else: \n        return term(n)*product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":268,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    if n == 1:                              =>           \r\n        return 1                            =>           \r\n    else:                                   =>           \r\n        return n * factorial(n-1)           =>           \r\n    else:                                   =>           \r\n    return _______                          <=           \r\n    \"*** YOUR CODE HERE ***\"                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, ExpressionStatement(){ literal(*** YOUR CODE HERE ***, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":269,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    if n <= 1:                          =>           \r\n        return term(n)                  =>           \r\n    return term(n) * product(n-1, term) =>           \r\n                                        =>           \r\n    return Y(________)  # Replace       =>           \r\n    return Y(________)  # Replace       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return term(n)\n\n    return term(n) * product(n-1, term)\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":270,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total, k = 1, 1                       =>           \r\n        total, k = total * term(k), k + 1 =>           \r\ndef identity(k):                          <=           \r\n    total, k = 0, 1                       <=           \r\n        total, k = total + term(k), k + 1 <=           \r\ndef square(x):                            <=           \r\n    total, k = 0, 1                       <=           \r\n    while k<= n:                          <=           \r\n        total, k = total + k**2, k + 1    <=           \r\n    return total                          <=           \r\n                                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\ndef identity(k):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\ndef square(x):\n    total, k = 0, 1\n    while k<= n:\n        total, k = total + k**2, k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":271,"diff":"\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    while n >= 1:                                              =>           \r\n        total = term_output(n) * total                         =>           \r\n        n-=1                                                   =>           \r\n                                                               =>           \r\n        return product(n-1, term_output(n-1)) * term_output()  =>           \r\n    total = 1                                                  =>           \r\n    return total                                               =>           \r\n                                                               =>           \r\n        return product(n-1, term_output(n-1)) * term_output(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def term_output(n):\n        return term(n)\n\n\n    if n > 1:\n        return\n    else:\n        return product(n-1, term_output(n-1)) * term_output(n)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def term_output(n):\n        return term(n)\n\n    total = 1\n    while n >= 1:\n        total = term_output(n) * total\n        n-=1\n    \n    return total\n\n\n    if n > 1:\n        return\n    else:\n        return product(n-1, term_output(n-1)) * term_output()\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":272,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if x>n:                      =>           \r\n            return 1                 =>           \r\n        return term(x)*function(x+1) =>           \r\n    return product(n,identity)       =>           \r\n    n+=1                             =>           \r\n    def function(x):                 =>           \r\n        def function_2(n):           =>           \r\n            if n==0:                 =>           \r\n                return               =>           \r\n            term(n)                  =>           \r\n            return function_2(n-1)   =>           \r\n        return function_2            =>           \r\n    return function                  =>           \r\n                                     =>           \r\n        if x<=n:                     <=           \r\n            term(x)*term(x+1)        <=           \r\n    return _______                   <=           \r\n    \"*** YOUR CODE HERE ***\"         <=           \r\n    \"*** YOUR CODE HERE ***\"         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(x):\n        if x<=n:\n            term(x)*term(x+1)\n    return function(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(x):\n        if x>n:\n            return 1\n        return term(x)*function(x+1)\n    return function(1)\n\n","Time":16286,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(LessThanOrEqual, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(literal-1)))))))))), 0), Selected(\\x => Match(x, FunctionDefinition(function){ Parameter(x) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-function)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-function), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1))))))))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(, *){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } } } } })), Selected(\\x => Match(x, FunctionDefinition(function){ Parameter(x) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(, *){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } }), 1), Selected(\\x => Match(x, FunctionDefinition(function){ Parameter(x) SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(x) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(x) literal(1) } } } } } } } } } }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":273,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n    if n == 1:                                                    =>           \r\n        return n                                                  =>           \r\n        k = term(n)                                               =>           \r\n        return product(n-1, term) * k                             =>           \r\n    return product(n, identity)                                   =>           \r\n    if n == 0:                                                    =>           \r\n        return base                                               =>           \r\n    else:                                                         =>           \r\n        k = combiner(base, term(n))                               =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), k) =>           \r\n    if n == 3:                                                    =>           \r\n        return f                                                  =>           \r\n    else:                                                         =>           \r\n        #f = compose1(f, f)                                       =>           \r\n        return repeated(compose1(f, f), n-1)                      =>           \r\n    if n <= 3:                                                    =>           \r\n        return n                                                  =>           \r\n    if n > 3:                                                     =>           \r\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)             =>           \r\n    value = 0                                                     =>           \r\n    k = 0                                                         =>           \r\n    while k < n:                                                  =>           \r\n        value += 1                                                =>           \r\n        if has_seven(value):                                      =>           \r\n            value -= 1                                            =>           \r\n        if value % 7 == 0:                                        =>           \r\n            value += 1                                            =>           \r\n        k += 1                                                    =>           \r\n    return value                                                  =>           \r\n                                                                  =>           \r\n    else:                                                         =>           \r\n                                                                  =>           \r\n    return _______                                                <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        k = term(n)\n        return product(n-1, term) * k\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, ExpressionStatement(){ literal(*** YOUR CODE HERE ***, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-n)))))))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-k), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))), SingleChild(LeafConstNode(NameExpression-k)))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":274,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            return term(i)*counter(i+1) =>           \r\n    return counter(i)                   =>           \r\n            return term(i)+counter(i+1) <=           \r\n                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i==n:\n            return term(n)\n        else:\n            return term(i)+counter(i+1)\n        \n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i==n:\n            return term(n)\n        else:\n            return term(i)*counter(i+1)\n    return counter(i)\n\n\n\n\n","Time":16291,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-counter), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Add, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(counter) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-counter), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(i) literal(1) } FunctionDefinition(counter){ Parameter(i) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Add){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(counter) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } } } } } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":275,"diff":"\r\nInputObject                                                                              SideIndicator\r\n-----------                                                                              -------------\r\n    if n == 1:                                                                           =>           \r\n        return term(1)                                                                   =>           \r\n        return term(n)*product(n-1, term)                                                =>           \r\n    if n == 0:                                                                           =>           \r\n        return 1                                                                         =>           \r\n    return product(n, identity)                                                          =>           \r\n    if n == 0:                                                                           =>           \r\n        return base                                                                      =>           \r\n    else:                                                                                =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                  =>           \r\n    return accumulate(add, 0, n, term)                                                   =>           \r\n    return accumulate(mul, 1, n, term)                                                   =>           \r\n    return accumulate(lambda x,y: combiner(x, y) if pred(term(x)) else y, base, n, term) =>           \r\n    curr_f = identity                                                                    =>           \r\n    while n > 0:                                                                         =>           \r\n        curr_f = compose1(f, curr_f)                                                     =>           \r\n        n -= 1                                                                           =>           \r\n    return curr_f                                                                        =>           \r\n    else:                                                                                =>           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, ExpressionStatement(){ literal(*** YOUR CODE HERE ***, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))))))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ literal(*** YOUR CODE HERE ***) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":276,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k = increment(k)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k = increment(k)\n    return total\n\n","Time":16692,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(k) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } AssignmentStatement(){ NameExpression(k) CallExpression(){ NameExpression(increment) Arg(){ NameExpression(k) } } } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":277,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        mul(n, term(n) - 1)                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n < 0:\n        return \n    elif n == 1:\n        return 1\n    else:\n        mul(n, term(n) - 1)\n\n\n\n\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n < 0:\n        return \n    elif n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n\n\n\n    \"*** YOUR CODE HERE ***\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":278,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    return counter(n, term, 1) =>           \r\n    counter(n, term, 1)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if(n == 1):\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\"\"\"\n\n    def counter(n, term, i):\n        if(i == n):\n            return term(n)\n        else:\n            return term(i) * counter(n, term, i+1)\n\n    counter(n, term, 1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if(n == 1):\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\"\"\"\n\n    def counter(n, term, i):\n        if(i == n):\n            return term(n)\n        else:\n            return term(i) * counter(n, term, i+1)\n\n    return counter(n, term, 1)\n\n","Time":16564,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-counter), Children(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))), Children(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if(n == 1):\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)) } FunctionDefinition(counter){ Parameter(n) Parameter(term) Parameter(i) SuiteStatement(){ IfStatement(){ IfStatementTest(){ ParenthesisExpression(){ BinaryExpression(Equals){ NameExpression(i) NameExpression(n) } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(){ NameExpression(counter) Arg(){ NameExpression(n) } Arg(){ NameExpression(term) } Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } } } } } } } ExpressionStatement(, *){ CallExpression(){ NameExpression(counter) Arg(){ NameExpression(n) } Arg(){ NameExpression(term) } Arg(){ literal(1) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":279,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":16862,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":280,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n                               =>           \r\n    if n == 0:                 <=           \r\n        return 1               <=           \r\n                               <=           \r\n        result = n * term(n-1) <=           \r\n    result = 1                 <=           \r\n    return result              <=           \r\n    else:                      <=           \r\n                               <=           \r\n                               <=           \r\n                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    if n == 0:\n        return 1\n    else:\n        \n        result = n * term(n-1)\n\n\n    return result\n\n\n    result = 1\n    \n    number = 1    \n    while n > 0:\n            result = result * term(number)\n            number = number + 1\n            n = n - 1\n\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n\n    result = 1\n    \n    number = 1    \n    while n > 0:\n            result = result * term(number)\n            number = number + 1\n            n = n - 1\n\n    return result\n\n","Time":18163,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(, *){ NameExpression(result) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(result) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(result) literal(1) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(result) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(result) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(, *){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(result) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } } } ReturnStatement(){ NameExpression(result) } AssignmentStatement(){ NameExpression(result) literal(1) } AssignmentStatement(){ NameExpression(number) literal(1) } WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(number) } } } } AssignmentStatement(){ NameExpression(number) BinaryExpression(Add){ NameExpression(number) literal(1) } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } ReturnStatement(){ NameExpression(result) } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":281,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n)*product(n - 1, term) =>           \r\n        return term(n)*term(n-1)            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n)*term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n)*product(n - 1, term)\n\n","Time":17865,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":282,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) * term(n - 1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n - 1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n\n","Time":17770,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":283,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n    if n == 1:                            =>           \r\n        return 1                          =>           \r\n        return n*factorial(n-1)           =>           \r\n    else:                                 =>           \r\n        return term(n)*term(n-1)          <=           \r\n    return _______                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":17655,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":284,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * term(n-1)                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return n * term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)\n\n","Time":18500,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":285,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return term(n) * term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":17933,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n<=1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":286,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        nextnumber =term(a+1)             =>           \r\n        result=term(a)*nextnumber         =>           \r\n        return term(a)*final_product(a+1) =>           \r\n    a=n                                   =>           \r\n    def final_factorial(a):               =>           \r\n        nextnumber=a                      =>           \r\n        result=a*nextnumber               =>           \r\n        if a==1:                          =>           \r\n            return result                 =>           \r\n        return a*final_factorial(a-1)     =>           \r\n    return final_factorial(a)             =>           \r\n        result=term(a) * term(a+1)        <=           \r\n        return final_product(a+1)         <=           \r\n    return _______                        <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    def final_product(a):\n        result=term(a) * term(a+1)\n        if a+1==n:\n            return result\n        return final_product(a+1)\n    return final_product(a)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    def final_product(a):\n        nextnumber =term(a+1)\n        result=term(a)*nextnumber\n        if a+1==n:\n            return result\n        return term(a)*final_product(a+1)\n    return final_product(a)\n\n","Time":18034,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-nextnumber)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(result, *) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-a), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(a) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(a, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(a) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-nextnumber), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-a), SingleChild(LeafConstNode(literal-1)))))))))))), 0), Selected(\\x => Match(x, FunctionDefinition(final_product){ Parameter(a) SuiteStatement(, *){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Add, *){ NameExpression(a) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Add){ NameExpression(a) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Add){ NameExpression(a, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Add){ NameExpression(a) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-result), SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-a)))))), SingleChild(LeafConstNode(NameExpression-nextnumber))))))), 1), Selected(\\x => Match(x, FunctionDefinition(final_product){ Parameter(a) SuiteStatement(, *){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(, *){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } })), Selected(\\x => Match(x, FunctionDefinition(final_product){ Parameter(a) SuiteStatement(, *){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-a)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-final_product), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-a), SingleChild(LeafConstNode(literal-1)))))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(, *){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ CallExpression(, *){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } })), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ NameExpression(result) } } } } ReturnStatement(, *){ CallExpression(){ NameExpression(final_product) Arg(){ BinaryExpression(Add){ NameExpression(a) literal(1) } } } } }), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":287,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not n:\n        return term(1)\n    else:\n        return term(n) * term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not n:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":17697,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if not n:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":288,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n)*product((n-1),term) =>           \r\n        return term(n)*term(n-1)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return n\n    else:\n        return term(n)*term(n-1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return n\n    else:\n        return term(n)*product((n-1),term)\n","Time":18312,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return n\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ParenthesisExpression, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":289,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    result = 1                             =>           \r\n            result = result * term(n)      =>           \r\n    return result                          =>           \r\n            product = term(n) * term (n-1) <=           \r\n            return product                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        while n > 1:\n            product = term(n) * term (n-1)\n            n -= 1\n            return product\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        while n > 1:\n            result = result * term(n)\n            n -= 1\n    return result\n\n\n","Time":27610,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-result), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } ReturnStatement(){ NameExpression(product) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-result)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product, *) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-result)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ CallExpression(, *){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ NameExpression(n, *) }), 0), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply, *){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n, *) literal(1) }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } ReturnStatement(, *){ NameExpression(product) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(1) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } ReturnStatement(){ NameExpression(product) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-result))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } ReturnStatement(){ NameExpression(product) } } } } } } }), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":290,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return term(n) * product(n - 1, term) =>           \r\n    return term(n) * term(n - 1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n) * term(n - 1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n - 1, term)\n\n\n","Time":19413,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":291,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==1:                             =>           \r\n        return term(n)*product(n-1,term) =>           \r\n    if n==0:                             <=           \r\n        return term(n)*term(n-1)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(n)\n    else:\n        return term(n)*term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(n)*product(n-1,term)\n\n","Time":19970,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":292,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * term(n-1)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n\n","Time":18133,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":293,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product((n-1), term) =>           \r\n        return term(n) * term(n-1)            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n-1)\n\n\n    \"\"\" without recursion\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i = i+1\n    return total\n    \"\"\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product((n-1), term)\n\n\n    \"\"\" without recursion\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i = i+1\n    return total\n    \"\"\"\n\n","Time":19063,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(1)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ParenthesisExpression, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":294,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n            return term(i)*helper(i-1) =>           \r\n    current = term(n)                  <=           \r\n            return current*term(i-1)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    current = term(n)\n    def helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return current*term(i-1)\n    return helper(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return term(i)*helper(i-1)\n    return helper(n)\n\n","Time":18646,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(, *){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } FunctionDefinition(helper){ Parameter(i) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(i) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } FunctionDefinition(helper){ Parameter(i) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(i) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(helper) Arg(){ NameExpression(n) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(current, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(current, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(current) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-helper)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(i) literal(1) } } }), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":295,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return term(n - 1) * term(n)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n - 1) * term(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return product(n - 1, term) * term(n)\n\n","Time":29133,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":296,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n            return term(count)*count_up(count-1) =>           \r\n            return term(count)*term(count-1)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def count_up(count):\n        if count == 1:\n            return 1\n        else:\n            return term(count)*term(count-1)\n    return count_up(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def count_up(count):\n        if count == 1:\n            return 1\n        else:\n            return term(count)*count_up(count-1)\n    return count_up(n)\n\n","Time":21811,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-count_up)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(count) literal(1) } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":297,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 0  or n == 1:                   =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    if n == 1:                              <=           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n \n    if n == 1:\n        return 1\n    else:\n        return term(n) * term(n-1)\n    \n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n \n    if n == 0  or n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n    \n\n\n\n\n","Time":18021,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":298,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    total, k = 1, 1                     =>           \r\n    while k<=n:                         =>           \r\n        total, k = total * term(k), k+1 =>           \r\n    return total                        =>           \r\n    # x = identity(n-1)                 =>           \r\n    # k = n * x                         =>           \r\n    # x -= 1                            =>           \r\n    # if x == 0:                        =>           \r\n    #     return                        =>           \r\n    identity(n)                         <=           \r\n    x = n                               <=           \r\n    x -= 1                              <=           \r\n    return n*x                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    identity(n)\n    x = n\n    x -= 1\n    return n*x\n    \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k<=n:\n        total, k = total * term(k), k+1\n    return total\n    # x = identity(n-1)\n    # k = n * x\n    # x -= 1\n    # if x == 0:\n    #     return\n    \n","Time":18835,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, CallExpression(){ NameExpression(identity, *) Arg(){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(TupleExpression-False, Children(LeafConstNode(literal-1), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, CallExpression(){ NameExpression(identity) Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-k)))), SingleChild(ConstNode(TupleExpression-False, Children(LeafConstNode(literal-1), SingleChild(LeafConstNode(literal-1)))))))), Selected(\\x => Match(x, ExpressionStatement(){ CallExpression(, *){ NameExpression(identity) Arg(){ NameExpression(n) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(, *){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, ExpressionStatement(){ CallExpression(, *){ NameExpression(identity) Arg(){ NameExpression(n) } } }), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(x, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(, *){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(x, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-k))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract, *){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n, *) NameExpression(x) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) NameExpression(x, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))), 1), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n) NameExpression(x, *) })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1)))))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-k)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k))))))))), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(, *){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract, *){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ CallExpression(){ NameExpression(identity) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(x) NameExpression(n) } AugmentedAssignStatement(Subtract){ NameExpression(x) literal(1) } ReturnStatement(){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(x) } } } }), InOrderSort(ast)))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":299,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return term(n)*term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)\n\n","Time":18054,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 1\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":300,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * term(n-1)                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return n * term(n-1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":19516,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return term(n)\r\n    else:\r\n        return term(n)*product(n-1, term)","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n, *) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ NameExpression(n) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":301,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        total = term(n) * product(n-1, term) =>           \r\n        return total                         =>           \r\n        total = term(n)                      <=           \r\n        return term(n-1) * total             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        total = term(n)\n        return term(n-1) * total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        total = term(n) * product(n-1, term)\n        return total \n\n\n","Time":17719,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    if n==1:\r\n        return term(n)\r\n    else:\r\n        total = term(n)\r\n        return product(n-1, term)*total","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(, *){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } })), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))))))))), 0), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))), 1), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(, *){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } })), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } NameExpression(total) } } } }), InOrderSort(ast))))))))))","UsedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":302,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    if k <= n:    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    a = 1\n    if k <= n:\n    \ta = a * term(k)\n    \tk += 1\n    return a \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    a = 1\n    while k <= n:\n    \ta = a * term(k)\n    \tk += 1\n    return a \n\n","Time":20448,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-a), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-a), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))))))), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) BinaryExpression(Multiply){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(k) literal(1) } AssignmentStatement(){ NameExpression(a) literal(1) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) BinaryExpression(Multiply){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(a) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(k) literal(1) } AssignmentStatement(){ NameExpression(a) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) BinaryExpression(Multiply){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(a) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatement(){ IfStatementTest(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) BinaryExpression(Multiply){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(k) literal(1) } AssignmentStatement(){ NameExpression(a) literal(1) } IfStatement(){ IfStatementTest(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) BinaryExpression(Multiply){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } AugmentedAssignStatement(Add){ NameExpression(k) literal(1) } } } } ReturnStatement(){ NameExpression(a) } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":303,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = 1\n    while i <= n:\n        total, i = total * term(i), i + 1\n        return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = 1\n    while i <= n:\n        total, i = total * term(i), i + 1\n    return total\n\n\n\n","Time":20665,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(AssignmentStatement, Children(ConstNode(TupleExpression-False, Children(LeafConstNode(NameExpression-total), SingleChild(LeafConstNode(NameExpression-i)))), SingleChild(ConstNode(TupleExpression-False, Children(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i))))))))), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))))))))))))), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(i) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } BinaryExpression(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(i) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } BinaryExpression(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(i) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } BinaryExpression(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } BinaryExpression(Add){ NameExpression(i) literal(1) } } } ReturnStatement(, *){ NameExpression(total) } }), 5), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(i) literal(1) } AssignmentStatement(){ NameExpression(total) literal(1) } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } BinaryExpression(Add){ NameExpression(i) literal(1) } } } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":304,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    if n == 0:                          =>           \r\n    if n == 1:                          =>           \r\n    return term(n)*product(n-1,term)    =>           \r\n    \"\"\"if term(n) == 0:                 <=           \r\n    if term(n) == 1:                    <=           \r\n    return n*product(term(n-1),term)\"\"\" <=           \r\n    return 1                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)\"\"\"\n    return 1\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn term(0)\n    if n == 1:\n    \treturn term(1)\n    return term(n)*product(n-1,term)\n\n","Time":20948,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-0))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term), *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(literal-1)))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(, *){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, SingleChild(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(, *){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(){ literal(1) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(, *){ literal(1) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ literal(1, *) })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } ExpressionStatement(){ literal(if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)) } ReturnStatement(, *){ literal(1) } }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":305,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return product(n-1, term)*term(n) =>           \r\n        return product(n-1, term)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(n)\n    else:\n        return product(n-1, term)\n  \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(n)\n    else:\n        return product(n-1, term)*term(n)\n  \n\n","Time":21670,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ CallExpression(, *){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":306,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    counter=n                           =>           \r\n    z=1                                 =>           \r\n    while 2<=counter:                   =>           \r\n        x=term(n)                       =>           \r\n        y=term(n-1)                     =>           \r\n        counter-=2                      =>           \r\n        n-=2                            =>           \r\n        z*=x*y                          =>           \r\n    return z                            =>           \r\n    if term==identity:                  <=           \r\n        n*n-1                           <=           \r\n        n**2*(n-1)**2                   <=           \r\n    if n==0:                            <=           \r\n        return 1                        <=           \r\n    else:                               <=           \r\n        return product(n-1,lambda n: x) <=           \r\n    else:                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if term==identity:\n        n*n-1\n    else:\n        n**2*(n-1)**2\n    if n==0:\n        return 1\n    else:\n        return product(n-1,lambda n: x)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter=n\n    z=1\n    while 2<=counter:\n        x=term(n)\n        y=term(n-1)\n        counter-=2\n        n-=2\n        z*=x*y\n    return z\n\n","Time":22485,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-counter)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(term, *) NameExpression(identity) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(term) NameExpression(identity, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-z)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(n) NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Subtract){ BinaryExpression(Multiply, *){ NameExpression(n) NameExpression(n) } literal(1) })), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Subtract, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(n) NameExpression(n, *) }), 0), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Subtract, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-z), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Subtract, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-2)), Selected(\\x => Match(x, BinaryExpression(Power){ NameExpression(n, *) literal(2) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-counter)), Selected(\\x => Match(x, BinaryExpression(Power){ NameExpression(n) literal(2, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(literal-2), SingleChild(LeafConstNode(NameExpression-counter))))), Selected(\\x => Match(x, BinaryExpression(Multiply){ BinaryExpression(Power, *){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n) literal(1, *) })), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))), Selected(\\x => Match(x, BinaryExpression(Power){ ParenthesisExpression(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2, *) })), Selected(\\x => Match(x, BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power, *){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-x), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))))), Selected(\\x => Match(x, BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power, *){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } }), 1), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, ExpressionStatement(){ BinaryExpression(Subtract, *){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } }), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-y)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n, *) literal(0) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, IfStatementTest(){ BinaryExpression(Equals, *){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } })), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Equals){ NameExpression(n, *) literal(0) }), 0), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Equals){ NameExpression(n) literal(0, *) }), 0), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ ReturnStatement(, *){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(, *){ ReturnStatement(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-y), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))))))))))), Selected(\\x => Match(x, IfStatement(){ IfStatementTest(, *){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-2)), Selected(\\x => Match(x, CallExpression(){ NameExpression(product, *) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-2)), Selected(\\x => Match(x, BinaryExpression(Subtract){ NameExpression(n) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-2))))), Selected(\\x => Match(x, Arg(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-z)), Selected(\\x => Match(x, FunctionDefinition(<lambda$1515>){ Parameter(n, *) ReturnStatement(){ NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-y))))), Selected(\\x => Match(x, FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(, *){ NameExpression(x) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-z), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-y)))))))), Selected(\\x => Match(x, LambdaExpression(){ FunctionDefinition(<lambda$1515>, *){ Parameter(n) ReturnStatement(){ NameExpression(x) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(literal-2), SingleChild(LeafConstNode(NameExpression-counter)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-x), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))), Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-y), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))))))))), Children(ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(literal-2)))), Children(ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-2)))), SingleChild(ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-z), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-y)))))))))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-z))), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(term) NameExpression(identity) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Subtract){ BinaryExpression(Multiply){ NameExpression(n) NameExpression(n) } literal(1) } } } } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Multiply){ BinaryExpression(Power){ NameExpression(n) literal(2) } BinaryExpression(Power){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } literal(2) } } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ LambdaExpression(){ FunctionDefinition(<lambda$1515>){ Parameter(n) ReturnStatement(){ NameExpression(x) } } } } } } } } } }), InOrderSort(ast)))))))))))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":307,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while n >0:  =>           \r\n    while n < 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    total = 1\n    while n < 0:\n        total = total * term(n)\n        n = n -1 \n\n    return total\n    \n    \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    total = 1\n    while n >0:\n        total = total * term(n)\n        n = n -1 \n\n    return total\n    \n    \n\n\n","Time":23986,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } AssignmentStatement(){ NameExpression(n) BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":308,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n    if n > 0:                                   =>           \r\n        return term(n) * product(n - 1, term)   =>           \r\n                                                =>           \r\n                                                =>           \r\n    if n < 1:                                   <=           \r\n        return term(n) * product((n - 1), term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return term(n) * product((n - 1), term)\n    else:\n        return term(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 0:\n        return term(n) * product(n - 1, term)\n    else:\n        return term(1)\n\n\n\n","Time":22662,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-0)), Selected(\\x => Match(x, BinaryExpression(LessThan){ NameExpression(n) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThan, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-0))))), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(LessThan, *){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } CallExpression(){ NameExpression(product) Arg(){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ ParenthesisExpression(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } })), Selected(\\x => Match(x, CallExpression(){ NameExpression(product) Arg(, *){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, ParenthesisExpression(){ BinaryExpression(Subtract, *){ NameExpression(n) literal(1) } }), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(product) Arg(, *){ ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } Arg(){ NameExpression(term) } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":309,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k <= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= 1:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n    \n\n","Time":23066,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = total*term(k)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(k) literal(1, *) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(k) literal(1, *) }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":310,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n            total = total * term(i)  =>           \r\n        return total                 =>           \r\n            total == total * term(i) <=           \r\n            return total             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    if n == 0 or n == 1:\n        return n\n    if n > 0:\n        while i <= n:\n            total == total * term(i)\n            i += 1\n            return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    if n == 0 or n == 1:\n        return n\n    if n > 0:\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        return total\n\n\n","Time":24333,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i))))))))))))), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Equals, *){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))))))))), 0), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } })), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(, *){ NameExpression(total) } }), 1), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":311,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return helper(n-1, acc*term(n)) =>           \r\n            return helper(n-1, acc)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, acc):\n        if n > 0:\n            return helper(n-1, acc)\n        print(acc)\n    return helper(n, 1)\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, acc):\n        if n > 0:\n            return helper(n-1, acc*term(n))\n        print(acc)\n    return helper(n, 1)\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":312,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if a == n+1: =>           \r\n        if a+1 == n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_mult(a):\n        if a+1 == n:\n            return 1\n        else:\n            return count_mult(a+1) * term(a)\n    return count_mult(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_mult(a):\n        if a == n+1:\n            return 1\n        else:\n            return count_mult(a+1) * term(a)\n    return count_mult(1)\n\n","Time":23909,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpression-a), 0), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(a, *) literal(1) }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Equals){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n, *) })), Selected(\\x => Match(x, IfStatementTest(){ BinaryExpression(Equals, *){ BinaryExpression(Add){ NameExpression(a) literal(1) } NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":313,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            return term(i) * helper_function(i + 1, n, term) =>           \r\n    return helper_function(1, n, term)                       =>           \r\n            return term(i) * term(i + 1)                     <=           \r\n    return term(1)                                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_function(i, n, term):\n        if i > n:\n            return 1\n        else:\n            return term(i) * term(i + 1)\n    return term(1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_function(i, n, term):\n        if i > n:\n            return 1\n        else:\n            return term(i) * helper_function(i + 1, n, term)\n    return helper_function(1, n, term)\n\n","Time":23312,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-helper_function)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))), 2), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 3), Selected(\\x => Match(x, BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } CallExpression(, *){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(i) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-helper_function)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))), 2), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 3), Selected(\\x => Match(x, ReturnStatement(){ CallExpression(, *){ NameExpression(term) Arg(){ literal(1) } } }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":314,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        else:                            =>           \r\n            return total                 =>           \r\n    return product_maker(n, term, total) =>           \r\n    return total                         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    def product_maker(n, term, total):\n        if n > 0:\n            total = total * (term(n))\n            return product_maker(n-1, term, total)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    def product_maker(n, term, total):\n        if n > 0:\n            total = total * (term(n))\n            return product_maker(n-1, term, total)\n        else:\n            return total\n    return product_maker(n, term, total)\n\n\n","Time":23447,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(NameExpression-total))))), 1), Selected(\\x => Match(x, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } ReturnStatement(){ CallExpression(){ NameExpression(product_maker) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } Arg(){ NameExpression(total) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product_maker), Children(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))), Children(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-total)))))))), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } FunctionDefinition(product_maker){ Parameter(n) Parameter(term) Parameter(total) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } ReturnStatement(){ CallExpression(){ NameExpression(product_maker) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } Arg(){ NameExpression(total) } } } } } } } } ReturnStatement(, *){ NameExpression(total) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, ReturnStatement(){ NameExpression(total, *) })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } FunctionDefinition(product_maker){ Parameter(n) Parameter(term) Parameter(total) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) ParenthesisExpression(){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } } ReturnStatement(){ CallExpression(){ NameExpression(product_maker) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } Arg(){ NameExpression(total) } } } } } } } } ReturnStatement(, *){ NameExpression(total) } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":315,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return 1 * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return 1 * product(n-1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n","Time":25361,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Multiply){ literal(1, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), 0), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ literal(1) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ literal(1, *) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } })), Selected(\\x => Match(x, ReturnStatement(){ BinaryExpression(Multiply, *){ literal(1) CallExpression(){ NameExpression(product) Arg(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } Arg(){ NameExpression(term) } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":316,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k <= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,multi=1,1\n    while k <= 1:\n        multi=term(k)*multi\n        k=k+1\n    return multi \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,multi=1,1\n    while k <= n:\n        multi=term(k)*multi\n        k=k+1\n    return multi \n\n","Time":23150,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    k, multi = 1, 1\r\n    while k<=n:\r\n        multi = term(k)*multi\r\n        k = k+1\r\n    return multi","IsFixed":true,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(k) literal(1, *) }), InOrderSort(ast)))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(LessThanOrEqual){ NameExpression(k) literal(1, *) }), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":317,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n            return term(k) * helper_product(k+1, term) =>           \r\n    if n==1:                                           =>           \r\n        return 1                                       =>           \r\n        return helper_product(1, term)                 =>           \r\n    else:                                              =>           \r\n                                                       =>           \r\n            return term(1) * helper_product(k+1, term) <=           \r\n    return helper_product(1, term)                     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper_product(k, term):\n        if k>n:\n            return 1\n        else:\n            return term(1) * helper_product(k+1, term)\n    return helper_product(1, term)\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper_product(k, term):\n        if k>n:\n            return 1\n        else:\n            return term(k) * helper_product(k+1, term)\n    if n==1:\n        return 1\n\n    else:\n        return helper_product(1, term)\n\n\n","Time":23514,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, Arg(){ literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(LeafConstNode(literal-1)))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-helper_product), Children(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term)))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(helper_product){ Parameter(k) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(helper_product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(helper_product) Arg(){ literal(1) } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(helper_product){ Parameter(k) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(helper_product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } ReturnStatement(, *){ CallExpression(){ NameExpression(helper_product) Arg(){ literal(1) } Arg(){ NameExpression(term) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } FunctionDefinition(helper_product){ Parameter(k) Parameter(term) SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(GreaterThan){ NameExpression(k) NameExpression(n) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } SuiteStatement(){ ReturnStatement(){ BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ literal(1) } } CallExpression(){ NameExpression(helper_product) Arg(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } Arg(){ NameExpression(term) } } } } } } } } ReturnStatement(){ CallExpression(){ NameExpression(helper_product) Arg(){ literal(1) } Arg(){ NameExpression(term) } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":318,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    return t                       =>           \r\n    return _______                 =>           \r\n    \"*** YOUR CODE HERE ***\"       =>           \r\n        return t                   <=           \r\n    return product(n, lambda x: x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n        return t\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n    return t\n\n","Time":25390,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AugmentedAssignStatement-Multiply, Children(LeafConstNode(NameExpression-t), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(t) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(t) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(t) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(t) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(t) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(t) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(, *){ NameExpression(t) } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ TupleExpression(){ NameExpression(t) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(t) } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":319,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        p *= term(i) =>           \r\n                     =>           \r\n        p *= term(p) <=           \r\n                     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p = 1\n    for i in range(1, n + 1):\n        p *= term(p)\n    return p\n    \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p = 1\n    for i in range(1, n + 1):\n        p *= term(i)\n    return p\n\n","Time":25418,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, Arg(){ NameExpression(p, *) }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":320,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n        return total\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n\n\n","Time":26969,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatement, Children(ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(NameExpression-n)))), SingleChild(ConstNode(SuiteStatement, Children(ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-i)))))))))))), SingleChild(ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))))))))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(, *){ NameExpression(total) } }), 4), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ TupleExpression(){ NameExpression(total) NameExpression(i) } TupleExpression(){ literal(1) literal(1) } } WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } AugmentedAssignStatement(Add){ NameExpression(i) literal(1) } ReturnStatement(){ NameExpression(total) } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":321,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n        total=term(n)*total  =>           \r\n        total==term(n)*total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    while n>0:\n        total==term(n)*total\n        n-=1\n    return total\n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    while n>0:\n        total=term(n)*total\n        n-=1\n    return total\n\n\n\n\n","Time":26270,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))), SingleChild(LeafConstNode(NameExpression-total)))))))), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Equals, *){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(, *){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } NameExpression(total) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } NameExpression(total) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, ExpressionStatement(){ BinaryExpression(Equals, *){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } NameExpression(total) } } }), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ ExpressionStatement(){ BinaryExpression(Equals){ NameExpression(total) BinaryExpression(Multiply){ CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } NameExpression(total) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":322,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n        product= product*term(num) =>           \r\n        num+=1                     =>           \r\n        product= product*term(n)   <=           \r\n        n+=1                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    num=2\n    product= term(1)\n    while num<=n:\n        product= product*term(n)\n        n+=1\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    num=2\n    product= term(1)\n    while num<=n:\n        product= product*term(num)\n        num+=1\n    return product\n\n","Time":24361,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-num)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-num)), Selected(\\x => Match(x, AugmentedAssignStatement(Add){ NameExpression(n, *) literal(1) }), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":323,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    final = 1                              =>           \r\n        final = final * result             =>           \r\n        counter += 1                       =>           \r\n        if n == 0:                         <=           \r\n            return 0                       <=           \r\n        if n == 1:                         <=           \r\n            return 1                       <=           \r\n        final = result * term(counter + 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    while counter != n + 1:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        result = term(counter)\n        final = result * term(counter + 1)\n    return final \n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    final = 1\n    while counter != n + 1:\n        result = term(counter)\n        final = final * result\n        counter += 1\n    return final \n\n\n\n","Time":193629,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-final), SingleChild(LeafConstNode(literal-1)))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(counter) literal(1) } WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } } ReturnStatement(){ NameExpression(final) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(, *){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-final), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-final), SingleChild(LeafConstNode(NameExpression-result))))))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-counter), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, Arg(){ BinaryExpression(Add, *){ NameExpression(counter) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(, *){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ BinaryExpression(Add, *){ NameExpression(counter) literal(1) } }), 2), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(NotEqual){ NameExpression(counter) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(0) } SuiteStatement(){ ReturnStatement(){ literal(0) } } } } IfStatement(){ IfStatementTest(){ BinaryExpression(Equals){ NameExpression(n) literal(1) } SuiteStatement(){ ReturnStatement(){ literal(1) } } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ BinaryExpression(Add){ NameExpression(counter) literal(1) } } } } } } }), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":324,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        k += 1       =>           \r\n        increment(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    summed = 1\n    k = 1\n    while k <= n:\n        summed *= term(k)\n        increment(k)\n    return summed\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    summed = 1\n    k = 1\n    while k <= n:\n        summed *= term(k)\n        k += 1\n    return summed\n\n","Time":37070,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, CallExpression(){ NameExpression(increment) Arg(, *){ NameExpression(k) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(summed) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } ExpressionStatement(, *){ CallExpression(){ NameExpression(increment) Arg(){ NameExpression(k) } } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(summed) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } ExpressionStatement(){ CallExpression(){ NameExpression(increment) Arg(){ NameExpression(k) } } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, CallExpression(){ NameExpression(increment) Arg(, *){ NameExpression(k) } }), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(k) NameExpression(n) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(summed) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } ExpressionStatement(){ CallExpression(){ NameExpression(increment) Arg(){ NameExpression(k) } } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":325,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n                                =>           \r\n    count = term(1)             =>           \r\n    for i in range(2, n+1):     =>           \r\n        num = term(i)           =>           \r\n        count = count * num     =>           \r\n    count = 1                   <=           \r\n    i = 1                       <=           \r\n    while i <= n:               <=           \r\n        count = count * term(i) <=           \r\n                                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    i = 1\n    while i <= n:\n        count = count * term(i)\n        increment(i)\n    return count\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    count = term(1)\n    for i in range(2, n+1):\n        num = term(i)\n        count = count * num\n        increment(i)\n    return count\n\n","Time":39458,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":326,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    i = 1                   =>           \r\n    while i <= n:           =>           \r\n            i += 1          =>           \r\n    for i in range(1, n+1): <=           \r\n        while i <= n:       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        while i <= n:\n            total = total * term(i)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    i = 1\n    while i <= n:\n            total = total * term(i)\n            i += 1\n    return total\n\n\n","Time":36887,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-i)), Selected(\\x => Match(x, BinaryExpression(Add){ NameExpression(n, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, Arg(){ BinaryExpression(Add, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(, *){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, Arg(){ BinaryExpression(Add, *){ NameExpression(n) literal(1) } }), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, SuiteStatement(){ WhileStatement(, *){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } }), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } ForStatement(){ NameExpression(i) CallExpression(){ NameExpression(range) Arg(){ literal(1) } Arg(){ BinaryExpression(Add){ NameExpression(n) literal(1) } } } SuiteStatement(){ WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":327,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n    k = 1                       =>           \r\n    while k <= n:               =>           \r\n        total = total * term(k) =>           \r\n        k = k + 1               =>           \r\n    return total                =>           \r\n    product = 1                 <=           \r\n    count = n                   <=           \r\n    while count>0:              <=           \r\n        product *= term(n)      <=           \r\n        n -= 1                  <=           \r\n    return product              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = n\n    while count>0:\n        product *= term(n)\n        n -= 1\n    return product\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n    \"*** YOUR CODE HERE ***\"\n\n","Time":55802,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(count, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(count) NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, BinaryExpression(GreaterThan){ NameExpression(count, *) literal(0) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(GreaterThan){ NameExpression(count) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan, *){ NameExpression(count) literal(0) } SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, AugmentedAssignStatement(Multiply){ NameExpression(product, *) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, Arg(){ NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(BinaryExpression-Multiply, Children(LeafConstNode(NameExpression-total), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-k)))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(count) literal(0) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply, *){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(count) literal(0) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-k)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(n, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-k), SingleChild(ConstNode(BinaryExpression-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(count) literal(0) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(1) } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(count) literal(0) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(product) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-total)), Selected(\\x => Match(x, ReturnStatement(){ NameExpression(product, *) }), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":328,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        counter = increment(counter) =>           \r\n        increment(counter)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    result = 1\n    while counter <= n:\n        num = term(counter)\n        result *= num\n        increment(counter)\n    return result\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    result = 1\n    while counter <= n:\n        num = term(counter)\n        result *= num\n        counter = increment(counter)\n    return result\n\n\n","Time":26504,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-counter), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-increment), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-counter)))))))))), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(num) CallExpression(){ NameExpression(term) Arg(){ NameExpression(counter) } } } AugmentedAssignStatement(Multiply){ NameExpression(result) NameExpression(num) } ExpressionStatement(, *){ CallExpression(){ NameExpression(increment) Arg(){ NameExpression(counter) } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":329,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        k+=1 =>           \r\n        k+1  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k=1\n    total=1\n    while k<n+1:\n        total=total*term(k)\n        k+1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k=1\n    total=1\n    while k<n+1:\n        total=total*term(k)\n        k+=1\n    return total\n\n","Time":37491,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-k), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, ExpressionStatement(){ BinaryExpression(Add, *){ NameExpression(k) literal(1) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } ExpressionStatement(, *){ BinaryExpression(Add){ NameExpression(k) literal(1) } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(k) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } ExpressionStatement(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } }), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, ExpressionStatement(){ BinaryExpression(Add, *){ NameExpression(k) literal(1) } }), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(k) BinaryExpression(Add){ NameExpression(n) literal(1) } } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(k) } } } } ExpressionStatement(){ BinaryExpression(Add){ NameExpression(k) literal(1) } } } }), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":330,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==1:                             =>           \r\n        return term(1)                   =>           \r\n        return product(n-1,term)*term(n) =>           \r\n    else:                                =>           \r\n    product=1                            <=           \r\n    while n>=1:                          <=           \r\n        a=term(n)                        <=           \r\n        product=product*a                <=           \r\n    return product                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    while n>=1:\n        a=term(n)\n        product=product*a\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return product(n-1,term)*term(n)\n\n","Time":37921,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(, *){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, BinaryExpression(GreaterThanOrEqual){ NameExpression(n, *) literal(1) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThanOrEqual, *){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-product)), Selected(\\x => Match(x, CallExpression(){ NameExpression(term, *) Arg(){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 0), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Arg(){ NameExpression(n, *) })), Selected(\\x => Match(x, CallExpression(){ NameExpression(term) Arg(, *){ NameExpression(n) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))), 2), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(a) CallExpression(, *){ NameExpression(term) Arg(){ NameExpression(n) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(, *){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product, *) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ NameExpression(product, *) NameExpression(a) })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply, *){ NameExpression(product) NameExpression(a) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(product) NameExpression(a, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply, *){ NameExpression(product) NameExpression(a) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(, *){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n))))))))))), 0), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(, *){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } })), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Insert(node, ConstNode(IfStatement, Children(ConstNode(IfStatementTest, Children(ConstNode(BinaryExpression-Equals, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(literal-1))))))))))))), SingleChild(ConstNode(SuiteStatement, SingleChild(ConstNode(ReturnStatement, SingleChild(ConstNode(BinaryExpression-Multiply, Children(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-product), Children(ConstNode(Arg, SingleChild(ConstNode(BinaryExpression-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))))), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-term))))))), SingleChild(ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-n)))))))))))))))), 2), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(, *){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(, *){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(, *){ NameExpression(product) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(product) literal(1) } WhileStatement(){ BinaryExpression(GreaterThanOrEqual){ NameExpression(n) literal(1) } SuiteStatement(){ AssignmentStatement(){ NameExpression(a) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } AssignmentStatement(){ NameExpression(product) BinaryExpression(Multiply){ NameExpression(product) NameExpression(a) } } } } ReturnStatement(){ NameExpression(product) } } }), InOrderSort(ast))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":331,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        i+=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1;s=1\n    while i<=n:\n        s=s*term(i)\n    return s\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1;s=1\n    while i<=n:\n        s=s*term(i)\n        i+=1\n    return s\n\n","Time":38625,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(s) BinaryExpression(Multiply){ NameExpression(s) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":332,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        n-=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n>0:\n        total *= term(n)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n>0:\n        total *= term(n)\n        n-=1\n    return total\n\n","Time":57007,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(GreaterThan){ NameExpression(n) literal(0) } SuiteStatement(, *){ AugmentedAssignStatement(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(n) } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":333,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i += 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    final = 1\n    i = 1\n    while i <= n:\n        final = final * term(i)\n    return final\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    final = 1\n    i = 1\n    while i <= n:\n        final = final * term(i)\n        i += 1\n    return final\n\n","Time":38519,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(i) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(final) BinaryExpression(Multiply){ NameExpression(final) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":334,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    x = 1                             =>           \r\n    while x <= n:                     =>           \r\n        result = term(x) * result     =>           \r\n        x += 1                        =>           \r\n    return product(n, identity(n))    =>           \r\n                                      =>           \r\n    while(n != 0):                    <=           \r\n        result = result * n * (n - 1) <=           \r\n        n -= 2                        <=           \r\n    result = term(result)             <=           \r\n    return product (n, lambda k: k)   <=           \r\n                                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    while(n != 0):\n        result = result * n * (n - 1)\n        n -= 2\n    result = term(result)\n    return result\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    x = 1\n    while x <= n:\n        result = term(x) * result\n        x += 1\n    return result\n\n","Time":1275,"SynthesizedAfter":"\r\ndef product(n, term):\r\n    result = 1\r\n    while (n!=1):\r\n        result = result*n*(n-1)\r\n        n -= 2\r\n    result = term(result)\r\n    return result","IsFixed":true,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatement, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1)))), 3), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(result) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(result) } } } ReturnStatement(){ NameExpression(result) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-x)), Selected(\\x => Match(x, BinaryExpression(NotEqual){ NameExpression(n, *) literal(0) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(NotEqual){ NameExpression(n) literal(0, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-LessThanOrEqual, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(NameExpression-n))))), Selected(\\x => Match(x, ParenthesisExpression(){ BinaryExpression(NotEqual, *){ NameExpression(n) literal(0) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, WhileStatement(){ ParenthesisExpression(, *){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } })), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(result) literal(1) } WhileStatement(, *){ ParenthesisExpression(){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(result) } } } ReturnStatement(){ NameExpression(result) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, ParenthesisExpression(){ BinaryExpression(NotEqual, *){ NameExpression(n) literal(0) } }), 0), Selected(\\x => Match(x, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(result) literal(1) } WhileStatement(, *){ ParenthesisExpression(){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(result) } } } ReturnStatement(){ NameExpression(result) } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-term)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(result, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-x)), Selected(\\x => Match(x, BinaryExpression(Multiply){ NameExpression(result) NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(CallExpression, Children(LeafConstNode(NameExpression-term), SingleChild(ConstNode(Arg, SingleChild(LeafConstNode(NameExpression-x))))))), Selected(\\x => Match(x, BinaryExpression(Multiply){ BinaryExpression(Multiply, *){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-result)), Selected(\\x => Match(x, BinaryExpression(Subtract){ NameExpression(n) literal(1, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(, *){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } })), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply, *){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Move(node, ReferenceNode(node, BinaryExpression(Subtract){ NameExpression(n) literal(1, *) }), 1), Selected(\\x => Match(x, AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply, *){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-x)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(n, *) literal(2) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-x), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract, *){ NameExpression(n) literal(2) } }), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(result) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } } AssignmentStatement(, *){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(result) } } } ReturnStatement(){ NameExpression(result) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } ExpressionStatement(){ literal(*** YOUR CODE HERE ***) } AssignmentStatement(){ NameExpression(result) literal(1) } WhileStatement(){ ParenthesisExpression(){ BinaryExpression(NotEqual){ NameExpression(n) literal(0) } } SuiteStatement(){ AssignmentStatement(){ NameExpression(result) BinaryExpression(Multiply){ BinaryExpression(Multiply){ NameExpression(result) NameExpression(n) } ParenthesisExpression(){ BinaryExpression(Subtract){ NameExpression(n) literal(1) } } } } AugmentedAssignStatement(Subtract){ NameExpression(n) literal(2) } } } AssignmentStatement(){ NameExpression(result) CallExpression(){ NameExpression(term) Arg(){ NameExpression(result) } } } ReturnStatement(){ NameExpression(result) } } }), InOrderSort(ast))))))))))))))))))))","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, literal(0, *)), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":335,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        a+=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    total=1\n    while a<=n:\n        total=total*term(a)\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    total=1\n    while a<=n:\n        total=total*term(a)\n        a+=1\n    return total\n\n","Time":28140,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-a), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThanOrEqual){ NameExpression(a) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(a) } } } } } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":336,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n                                =>           \r\n    while n  >= 1:              =>           \r\n        total = total * term(n) =>           \r\n        n -= 1                  =>           \r\n    x = 0                       <=           \r\n    while x < n:                <=           \r\n        total = total * term(x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    x = 0\n    while x < n:\n        total = total * term(x)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    \n    while n  >= 1:\n        total = total * term(n)\n        n -= 1\n    return total\n\n\n","Time":58940,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, ConcatPatch(EditMap(\\node => Delete(node, ReferenceNode(node, SuiteStatement(){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(, *){ NameExpression(x) literal(0) } WhileStatement(){ BinaryExpression(LessThan){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } ReturnStatement(){ NameExpression(total) } })), Selected(\\x => Match(x, FunctionDefinition(product){ Parameter(n) Parameter(term) SuiteStatement(, *){ ExpressionStatement(){ literal(Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ) } AssignmentStatement(){ NameExpression(total) literal(1) } AssignmentStatement(){ NameExpression(x) literal(0) } WhileStatement(){ BinaryExpression(LessThan){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } } ReturnStatement(){ NameExpression(total) } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, BinaryExpression(LessThan){ NameExpression(x, *) NameExpression(n) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(literal-1)), Selected(\\x => Match(x, BinaryExpression(LessThan){ NameExpression(x) NameExpression(n, *) }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpression-GreaterThanOrEqual, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan, *){ NameExpression(x) NameExpression(n) } SuiteStatement(){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } }), InOrderSort(ast))), ConcatPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpression-n)), Selected(\\x => Match(x, Arg(){ NameExpression(x, *) }), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatement-Subtract, Children(LeafConstNode(NameExpression-n), SingleChild(LeafConstNode(literal-1)))), 1), Selected(\\x => Match(x, WhileStatement(){ BinaryExpression(LessThan){ NameExpression(x) NameExpression(n) } SuiteStatement(, *){ AssignmentStatement(){ NameExpression(total) BinaryExpression(Multiply){ NameExpression(total) CallExpression(){ NameExpression(term) Arg(){ NameExpression(x) } } } } } }), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":337,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i += 1 =>           \r\n        i *= 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i *= 1\n    return t\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n    return t\n\n","Time":39384,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatement-Add, Children(LeafConstNode(NameExpression-i), SingleChild(LeafConstNode(literal-1))))), Selected(\\x => Match(x, SuiteStatement(){ AugmentedAssignStatement(Multiply){ NameExpression(t) CallExpression(){ NameExpression(term) Arg(){ NameExpression(i) } } } AugmentedAssignStatement(Multiply, *){ NameExpression(i) literal(1) } }), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}]