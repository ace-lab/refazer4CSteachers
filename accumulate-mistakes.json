[{"ErrorFlag":0,"Id":1,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        a = combiner(a, term(i))    =>           \r\n        a = combiner(base, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(base, term(i))\n    \ti += 1\n    return a \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(a, term(i))\n    \ti += 1\n    return a \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":2,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    return helper(n, 1) =>           \r\n    return helper(n, 2) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 2)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 1)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":3,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n<1:    =>           \r\n    if base<1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":4,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k =base, 1  =>           \r\n    total, k ==base, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k ==base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k =base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total, k ==base, 1","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":5,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term) =>           \r\n    return accumulate(add, 0, n, term)                                                      =>           \r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term) <=           \r\n    return _______                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","288","","# Error: expected","#     72","# but got","#     288","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":6,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), n)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), n)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":7,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 0:         =>           \r\n        return base    =>           \r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return term(1)\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return base + combiner(term(n), accumulate(combiner, 0, n-1, term)) if combiner == add else base * combiner(term(n), accumulate(combiner, 1, n-1, term))","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":8,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(m), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(m), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(m), accumulate(combiner, base, n-1, term))","NameError: name 'm' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":9,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n        k = 0           =>           \r\n        k = 1           =>           \r\n                        =>           \r\n    else:               =>           \r\n    k = base            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    k = base\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    if combiner == add:\n        k = 0\n    else:\n        k = 1\n    \n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":10,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":11,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":12,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return helper(0,base)              =>           \r\n    return combiner(helper(0,0), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return combiner(helper(0,0), base)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return helper(0,base)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":13,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":14,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return accumulate(combiner,base,n-1,term)                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return accumulate(combiner,base,n-1,term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":15,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n >= 1: =>           \r\n    while n > 1:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n > 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":16,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n                                                                        =>           \r\n        base += term(n)                                                 <=           \r\n        n -= 1                                                          <=           \r\n        return accumulate(combiner, base, n, term)                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base += term(n)\n        n -= 1\n        return accumulate(combiner, base, n, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":17,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    combiner = lambda f: f(x, y) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    combiner = lambda f: f(x, y)\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: <lambda>() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":18,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    total = base                           =>           \r\n    b = 1                                  =>           \r\n    while b <= n:                          =>           \r\n        total = combiner(term(b), total)   =>           \r\n        b += 1                             =>           \r\n    return total                           =>           \r\n                                           =>           \r\n    result = base                          <=           \r\n    for i in range(base, n + 1):           <=           \r\n        result = combiner(result, term(i)) <=           \r\n    return result                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    for i in range(base, n + 1):\n        result = combiner(result, term(i))\n    return result \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    b = 1\n    while b <= n:\n        total = combiner(term(b), total)\n        b += 1\n    return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":19,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n            return total * base =>           \r\n            return total + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total + base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total * base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":20,"studentId":0,"date":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n        accumulation = combiner(accumulation, term(k)) =>           \r\n        combiner(accumulation, term(k))                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        accumulation = combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":21,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                                   SideIndicator\r\n-----------                                                                                                   -------------\r\n    if n == 0:                                                                                                =>           \r\n        new_base = term(n)                                                                                    =>           \r\n    return combiner(accumulate(combiner, new_base, n-1, term), base)                                          =>           \r\n    return accumulate(combiner, base, n, term) if pred(n) else filtered_accumulate(combiner, base, n-1, term) =>           \r\n        new_base = term(n)                                                                                    =>           \r\n        return combiner(accumulate(combiner, new_base, n-1, term), base)                                      =>           \r\n'''                                                                                                           =>           \r\n    def next_pong(i, j, next):                                                                                =>           \r\n        if i == n:                                                                                            =>           \r\n            return 0                                                                                          =>           \r\n    def switch_ping():                                                                                        =>           \r\n        return 0                                                                                              =>           \r\n        return 0                                                                                              =>           \r\n    if n == 1:                                                                                                =>           \r\n        print(start, end)                                                                                     =>           \r\n    else:                                                                                                     =>           \r\n        return 0                                                                                              =>           \r\n    i = 1                                                                                                     <=           \r\n    if i == n:                                                                                                <=           \r\n        new_base = term(i)                                                                                    <=           \r\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)                                        <=           \r\n    return accumulate(combiner, base, n if pred(n) else 0, term)                                              <=           \r\n        x = term(n)                                                                                           <=           \r\n    return combiner(base, accumulate(combiner, x, n-1, term))'''                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    i = 1\n    if i == n:\n        return base\n    else:\n        new_base = term(i)\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    if n == 0:\n        return base\n    else:\n        new_base = term(n)\n    return combiner(accumulate(combiner, new_base, n-1, term), base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":22,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    i, total = 1, base                   =>           \r\n        total = combiner(term(i), total) =>           \r\n    i, total = 1, 1                      <=           \r\n        total = combiner(term(i)) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        total = combiner(term(i)) + base\n        i += 1\n    return total \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, base\n    while i <= n:\n        total = combiner(term(i), total)\n        i += 1\n    return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term(i)) + base","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":23,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":24,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    if n == 0:      =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":25,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if i > n:                         =>           \r\n            return base                   =>           \r\n        if i == n:                        <=           \r\n            return combiner(base,term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i == n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i > n:\n            return base\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    if n==0:\r\n        return base\r\n    return help(base, 1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in help","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":26,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    total, i = base, 1           =>           \r\n    return total                 =>           \r\n                                 =>           \r\n    total, i = 0, 1              <=           \r\n    return combiner(base, total) <=           \r\n                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = 0, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(base, total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":27,"studentId":0,"date":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n        total, x = combiner(total, term(x)), x + 1               =>           \r\n        total, x = total + combiner(term(x - 1), term(x)), x + 2 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    total = base \n    while x <= n:\n        total, x = total + combiner(term(x - 1), term(x)), x + 2\n    return total\n    # def count_up(x):\n    #     x = 1\n    #     if n == 0:\n    #         return n \n    #     while x <= n:\n    #         print (term(x))\n    #         x += 1\n    #     return\n\n    # # x, a = base, lambda x: lambda y: combiner(x, y) \n\n    # if n == 0:\n    #     return base\n\n    # return base + count_up(n)\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    total = base \n    while x <= n:\n        total, x = combiner(total, term(x)), x + 1\n    return total\n    # def count_up(x):\n    #     x = 1\n    #     if n == 0:\n    #         return n \n    #     while x <= n:\n    #         print (term(x))\n    #         x += 1\n    #     return\n\n    # # x, a = base, lambda x: lambda y: combiner(x, y) \n\n    # if n == 0:\n    #     return base\n\n    # return base + count_up(n)\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":28,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    elif n == 0:                =>           \r\n        return combiner(base,0) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.  The\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.  Treating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\t\"*** YOUR CODE HERE ***\"\n\tif n == 1:\n\t\treturn combiner(base,term(1)) \n\treturn combiner(base, accumulate(combiner, term(n), n-1, term))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.  The\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.  Treating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\t\"*** YOUR CODE HERE ***\"\n\tif n == 1:\n\t\treturn combiner(base,term(1)) \n\telif n == 0:\n\t\treturn combiner(base,0)\n\treturn combiner(base, accumulate(combiner, term(n), n-1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":29,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    if combiner == add:              =>           \r\n        return base + combined_terms =>           \r\n        return base * combined_terms =>           \r\n    else:                            =>           \r\n    return base + combined_terms     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    return base + combined_terms\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    if combiner == add:\n        return base + combined_terms\n    else:\n        return base * combined_terms\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":30,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return combiner(base, 0) =>           \r\n        return 0                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, 0)\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":31,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = 1          =>           \r\n    total = base       =>           \r\n    total = term(1)    <=           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = term(base)\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":32,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    k = 1                        =>           \r\n    return combiner(total, base) =>           \r\n    k = base                     <=           \r\n    return total                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(total, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":33,"studentId":0,"date":null,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return base                     =>           \r\n            base = combiner(base, term(n))  =>           \r\n    if combiner==mul:                       <=           \r\n        total=1                             <=           \r\n        total=0                             <=           \r\n            return total                    <=           \r\n            total = combiner(base, term(n)) <=           \r\n    else:                                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return total\n        else:\n            total = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return base\n        else:\n            base = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            base = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return partial_total(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in partial_total","    return total","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":34,"studentId":0,"date":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total, k = combiner(total, term(k)), k + 1  =>           \r\n    return total                                    =>           \r\n        total, k = combiner (total, term(k)), k + 1 <=           \r\n    return combiner(total)                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner (total, term(k)), k + 1\n    return combiner(total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    return combiner(total)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":35,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return combiner(base,term(1)) =>           \r\n        return combiner(base,term(0)) =>           \r\n        return base + term(1)         <=           \r\n        return base + term(0)         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base + term(1)\n    elif n == 0:\n        return base + term(0)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base,term(1))\n    elif n == 0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":36,"studentId":0,"date":null,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    counter = 1                                                      =>           \r\n    if combiner == mul:                                              =>           \r\n    while counter <= n:                                              =>           \r\n        total, counter = combiner(total, term(counter)), counter + 1 =>           \r\n    x = 1                                                            <=           \r\n    if x == mul:                                                     <=           \r\n    while x <= n:                                                    <=           \r\n        total, x = combiner(total, term(x)), x + 1                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    if x == mul:\n        total = 1\n    else:\n        total = 0\n    while x <= n:\n        total, x = combiner(total, term(x)), x + 1\n    return combiner(base, total)\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while counter <= n:\n        total, counter = combiner(total, term(counter)), counter + 1\n    return combiner(base, total)\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = base\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":37,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, n) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":38,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==0:                             =>           \r\n        return combiner(base,term(n))    =>           \r\n    elif n==1:                           =>           \r\n        return combiner(base,term(n))    =>           \r\n    if n==1:                             <=           \r\n        return term(n)                   <=           \r\n     # elif n==1:                        <=           \r\n     #     return combiner(base,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(n)\n     # elif n==1:\n     #     return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return combiner(base,term(n))\n    elif n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":39,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    def iter_accumulate(x):             =>           \r\n    return iter_accumulate(1)           =>           \r\n    def iter_accumulate(x,increment):   <=           \r\n    return iter_accumulate(1,increment) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x,increment):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1,increment)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return iter_accumulate(1,increment)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in iter_accumulate","    return combiner(term(x),iter_accumulate(increment(x)))","TypeError: iter_accumulate() missing 1 required positional argument: 'increment'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":40,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 0   =>           \r\n    i = -1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = -1\n    result = base\n    while i < n:\n        result = combiner(result, term(n))\n        n -= 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    result = base\n    while i < n:\n        result = combiner(result, term(n))\n        n -= 1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":41,"studentId":0,"date":null,"diff":"\r\nInputObject                                                     SideIndicator\r\n-----------                                                     -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    from operator import add, mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(n,accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    from operator import add, mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":42,"studentId":0,"date":null,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    i, total = 1, base         =>           \r\n    index, total = 1, base     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    index, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    while i <= n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":43,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return term(n)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":44,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n        total, k = combiner(term(k), k), k + 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), k), k + 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":45,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    k = 1                                                                           =>           \r\n    total = base                                                                    =>           \r\n    while k <= n:                                                                   =>           \r\n        total = combiner(total, term(k))                                            =>           \r\n        k += 1                                                                      =>           \r\n    return total                                                                    =>           \r\n    if n == 0:                                                                      <=           \r\n        return base                                                                 <=           \r\n    if n == 1:                                                                      <=           \r\n        return combiner(base, term(n))                                              <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":46,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumalate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumalate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumalate(combiner, base, n-1, term))","NameError: name 'accumalate' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":47,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == mul: =>           \r\n        if term == mul:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if term == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if combiner == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":48,"studentId":0,"date":null,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    for i in range(1, n+1):        =>           \r\n    base = combiner(base, term(1)) <=           \r\n    for i in range(2, n+1):        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base = combiner(base, term(1))\n    for i in range(2, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range(1, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":49,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":50,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 0 =>           \r\n            return 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 0\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, times(1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":51,"studentId":0,"date":null,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n                                                         =>           \r\n        total = base                                     =>           \r\n    return helper_product(base, n, term)                 =>           \r\n        total = 0                                        <=           \r\n    return combiner(helper_product(base, n, term), base) <=           \r\n                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        total = 0\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return combiner(helper_product(base, n, term), base)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        \n        total = base\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return helper_product(base, n, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":52,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    result, i = base, 1                                                             =>           \r\n    while i <= n:                                                                   =>           \r\n        result = combiner(result, term(i))                                          =>           \r\n        i += 1                                                                      =>           \r\n    return result                                                                   =>           \r\n    if n == 0:                                                                      <=           \r\n        return 1                                                                    <=           \r\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 1\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term)))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i <= n:\n        result = combiner(result, term(i))\n        i += 1\n    return result\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":53,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    elif n == 0:                 =>           \r\n        return combiner(0, base) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    elif n == 0:\n        return combiner(0, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return ","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":54,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return base                      =>           \r\n        return combiner(base, term(n+1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(n+1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":55,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(0))\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    if n==0:\r\n        return base\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":56,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>0:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":57,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while n+1 > i: =>           \r\n    while n > i:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n+1 > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":58,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return term(base)\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":59,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k < n:  =>           \r\n    while k <= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k <= n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k < n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k+1<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":60,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if k > 1:  =>           \r\n    if k >= 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k >= 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k > 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if n==0:\r\n        return base\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":61,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n==0:         =>           \r\n    if n==1 or n==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1 or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":62,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(add, base, n-1, term))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(add, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","63","","# Error: expected","#     72","# but got","#     63","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":63,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1, term) + term(n)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1, term) + term(n)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":64,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":65,"studentId":0,"date":null,"diff":"","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            n -= 1\n            result = combiner(result, term(n))\n        return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            result = combiner(result, term(n))\n            n -= 1\n        return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":66,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(accumulate(combiner,term(n),n-1,term),base) =>           \r\n        return combiner(accumulate(combiner,term(n),n-1,term))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term),base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":67,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":68,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":69,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(i)) =>           \r\n        base = combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(n))\n        i += 1\n    return base \n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base \n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":70,"studentId":0,"date":null,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term )) =>           \r\n        return combiner(n,accumulate(combiner,base, term(n),term ))  <=           \r\n                                                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base, term(n),term ))\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term ))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(n,accumulate(combiner,base, term(n),term ))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":71,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n==0:                           =>           \r\n    elif n==1:                         =>           \r\n        return combiner(base, term(n)) =>           \r\n    if n==1:                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(base, term(n))\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":72,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return term(n) + base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":73,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==0:                  =>           \r\n        return base           =>           \r\n    if n==1:                  <=           \r\n        return base + term(1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return base + term(1)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":74,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n        return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n    return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":75,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if combiner == add:                  =>           \r\n        total = 0                        =>           \r\n        total = 1                        =>           \r\n    for i in range(1, n+1):              =>           \r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(base, total)         =>           \r\n    else:                                =>           \r\n    return combiner(base + term(n))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return combiner(base + term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total = 0\n    else:\n        total = 1\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return combiner(base, total)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    return combiner(base + term(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":76,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    p=base                    =>           \r\n    for _ in range(1,n+1):    =>           \r\n        p=combiner(term(_),p) =>           \r\n    return p                  =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p=base\n    for _ in range(1,n+1):\n        p=combiner(term(_),p)\n    return p\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":77,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n == 0:        =>           \r\n        n_counter = 0 =>           \r\n        n_counter = 1 =>           \r\n    else:             =>           \r\n    n_counter = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        n_counter = 0\n    else:\n        n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    if n==0:\r\n        return base\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":78,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    z=base  =>           \r\n    z=n     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=n\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    z = base\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":79,"studentId":0,"date":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n            return combiner(term(n), helper(n-1, term)) =>           \r\n            return term(n)+helper(n-1, term)            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return term(n)+helper(n-1, term)\n    return combiner(base, helper(n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return combiner(term(n), helper(n-1, term))\n    return combiner(base, helper(n, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), helper(n-1, term))\r\n    return combiner(base, helper(n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","28","","# Error: expected","#     72","# but got","#     28","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":80,"studentId":0,"date":null,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n    if n==0:                                                      =>           \r\n        return base                                               =>           \r\n        base = combiner(base, term(n))                            =>           \r\n    return accumulate(combiner, base, n-1, term)                  =>           \r\n    if combiner==mul:                                             <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)*accumulate(combiner, base, n-1, term)  <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)+ accumulate(combiner, base, n-1, term) <=           \r\n                                                                  <=           \r\n                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==mul:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)*accumulate(combiner, base, n-1, term)\n    else:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        base = combiner(base, term(n))\n    return accumulate(combiner, base, n-1, term)\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if combiner==mul:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":81,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    counter=1                    =>           \r\n        while counter<=n:        =>           \r\n        return accumulateTotal   =>           \r\n    counter=0                    <=           \r\n        while counter<n:         <=           \r\n        return accumulateTotal+5 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=0\n    if n==0:\n        return base\n    else:\n        while counter<n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal+5\n        \n        \n        \n        \n        \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=1\n    if n==0:\n        return base\n    else:\n        while counter<=n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal\n        \n        \n        \n        \n        \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21","","# Error: expected","#     25","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":82,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":83,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        combiner(term(n), accumulate(combiner, base, n-1, term))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":84,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    while k <= n:                                  =>           \r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n    while k <= n:                                  <=           \r\n        total, k = term(n, k), k + 1               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1 \n    while k <= n:\n        total, k = term(n, k), k + 1 \n    return total \n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1 \n    while k <= n: \n        total, k = combiner(term(k), total), k + 1\n    return total \n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total, k = term(n, k), k + 1","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":85,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                    SideIndicator\r\n-----------                                                                                    -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))                        =>           \r\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term)))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term))))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":86,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    for i in range(1, n + 1):           =>           \r\n    for i in range(base, base + n + 1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(base, base + n + 1):\n        total = combiner(total, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","92","","# Error: expected","#     26","# but got","#     92","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":87,"studentId":0,"date":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    x = base =>           \r\n    x = 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":88,"studentId":0,"date":null,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    i = 1                                      =>           \r\n        product = combiner(product,term(i))    =>           \r\n    i = 0                                      <=           \r\n        product = combiner(product,term(base)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 0\n    while i < n+1:\n    \tproduct = combiner(product,term(base))\n    \ti +=1\n    return product\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 1\n    while i < n+1:\n    \tproduct = combiner(product,term(i))\n    \ti +=1\n    return product\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":89,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":90,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    def a(combiner,n,term):                                           =>           \r\n        if n == 1:                                                    =>           \r\n            return term(1)                                            =>           \r\n        else:                                                         =>           \r\n            return combiner(term(n), a(combiner, n-1, term))          =>           \r\n        return combiner(base, a(combiner,n,term))                     =>           \r\n        return combiner(base, combiner(term(n), combiner(n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), combiner(n-1, term)))\n\n\n\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def a(combiner,n,term):\n        if n == 1:\n            return term(1)\n        else: \n            return combiner(term(n), a(combiner, n-1, term))\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, a(combiner,n,term))\n\n\n\n    \"*** YOUR CODE HERE ***\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(base, combiner(term(n), combiner(n-1, term)))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":91,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(x)) =>           \r\n        total=term(total)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=term(total)\n        x+=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=combiner(total,term(x))\n        x+=1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":92,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def helper(i):\n    #     if i == n:\n    #         return \n    #     else:\n    #         return \n    # return helper(1)\n    if n == 1:\n        return combiner(base, term(n))  \n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def helper(i):\n    #     if i == n:\n    #         return \n    #     else:\n    #         return \n    # return helper(1)\n    if n == 1 or n == 0:\n        return combiner(base, term(n))  \n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":93,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total = base     =>           \r\n        total = base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n        \n    while n > 0:\n        total = base\n        total = combiner(total ,term(n))\n        n =  n-1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    total = base    \n    while n > 0:\n        \n        total = combiner(total ,term(n))\n        n =  n-1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        base = combiner(total, term(n))\r\n        n = n-1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":94,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(i)) =>           \r\n        total=combiner(total,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(n))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":95,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for x in range(1, n + 1):          =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n    for x in range(2, n + 1):          <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(2, n + 1):\n        base = combiner(base, term(x))\n    return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(1, n + 1):\n        base = combiner(base, term(x))\n    return base\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(1, n+1):\r\n        base = combiner(base, term(x))\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":96,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 1:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":97,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), term(n-1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), term(n-1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":98,"studentId":0,"date":null,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    return comb(term(1),base)               =>           \r\n    return combiner(base , comb(term(1),1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return combiner(base , comb(term(1),1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return comb(term(1),base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":99,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        total, k = 1, 1     =>           \r\n        total, k = 1, k + 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if combiner == add:\n        total, k = 0, 1\n        while k <= n:\n            total, k = total + term(k), k + 1\n        return total + base\n    else:\n        total, k = 1, k + 1\n        while k <= n:\n            total, k = total * term(k), k + 1\n        return total * base\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if combiner == add:\n        total, k = 0, 1\n        while k <= n:\n            total, k = total + term(k), k + 1\n        return total + base\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * term(k), k + 1\n        return total * base\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total, k = 1, k + 1","UnboundLocalError: local variable 'k' referenced before assignment","","# Error: expected","#     72","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":100,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner([term(n), accumulate(combiner, base, n-1, term)]) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner([term(n), accumulate(combiner, base, n-1, term)])\n    else:\n        return base\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":101,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    def helper(a,n):                         =>           \r\n        if n == 0:                           =>           \r\n            return a                         =>           \r\n        else:                                =>           \r\n            a = combiner(a, term(n))         =>           \r\n        return helper(a, n-1)                =>           \r\n    return helper(base, n)                   =>           \r\n    if n == 1:                               <=           \r\n        return term(1) + base                <=           \r\n    else:                                    <=           \r\n        return term(n) * combiner(n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(1) + base\n    else: \n        return term(n) * combiner(n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a \n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return term(n) * combiner(n-1, term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":102,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n    if n == 0:                                                             =>           \r\n        return base                                                        =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))    =>           \r\n    else:                                                                  =>           \r\n    if base == 0:                                                          <=           \r\n        return combiner(base, term(accumulate(combiner, base, n-1, term))) <=           \r\n                                                                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if base == 0:\n        return combiner(base, term(accumulate(combiner, base, n-1, term)))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(base, term(accumulate(combiner, base, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if base == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":103,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    total = 1                                                                       =>           \r\n    for x in range(n):                                                              =>           \r\n        total *= term(x+1)                                                          =>           \r\n    return total                                                                    =>           \r\n    return product(n, identity)                                                     =>           \r\n    total = base                                                                    =>           \r\n    for x in range (n):                                                             =>           \r\n        total = combiner(total, term(x+1))                                          =>           \r\n    return total                                                                    =>           \r\n    return accumulate(add, 0, n, term)                                              =>           \r\n    return accumulate(mul, 1, n, term)                                              =>           \r\n    #return accumulate(combiner if pred(for x in range(n): ) else ,base , n , term) =>           \r\n                                                                                    =>           \r\n                                                                                    =>           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    return _______                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                        <=           \r\n    \"*** YOUR CODE HERE ***\"                                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base \n    for x in range (n):\n        total = combiner(total, term(x+1))\n    return total\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":104,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                SideIndicator\r\n-----------                                                                                -------------\r\n    \"\"\"def f(x):                                                                           =>           \r\n    return f(n)\"\"\"                                                                         =>           \r\n    s=base                                                                                 =>           \r\n    return s                                                                               =>           \r\n    return accumulate(lambda combiner:combiner if pred else lambda x,y,:x , base, n, term) =>           \r\n    def f(x):                                                                              <=           \r\n    return f(n)                                                                            <=           \r\n    \"\"\"\"s=base                                                                             <=           \r\n    return s\"\"\"                                                                            <=           \r\n    return _______                                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\n    \"\"\"\"s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\"\"\"\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\"\"\"\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==0:\r\n            return base\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in f","    if x==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":105,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        total = base =>           \r\n        total = 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = 1\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","36","","# Error: expected","#     72","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":106,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    if n == 0:                                                                    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))           =>           \r\n        \"\"\"                                                                       =>           \r\n    total, k = base, 1                                                            =>           \r\n    return total\"\"\"                                                               =>           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(a) else b, base, n, term) =>           \r\n    \"\"\"if n == 0:                                                                 <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"        <=           \r\n    total, k = start, 1                                                           <=           \r\n    return total                                                                  <=           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(b) else b, base, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total  \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\"\"\"  \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":107,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        total = 0 =>           \r\n        total = 1 =>           \r\n    total = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = 1\n    if combiner == add:\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner == add:\n        total = 0\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        total = 1\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":108,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    i = 1                                 =>           \r\n    total = base                          =>           \r\n    while i <= n:                         =>           \r\n        total = combiner(total, term(i))  =>           \r\n        i += 1                            =>           \r\n    return total                          =>           \r\n    return ________                       =>           \r\n        return compsel(f, f)              =>           \r\n        return repeated(f, n-1)           =>           \r\n        return term(n)                    <=           \r\n    if n == 0:                            <=           \r\n        return base                       <=           \r\n        return combiner(base, term(n-1))  <=           \r\n    #i = 1                                <=           \r\n    #total = base                         <=           \r\n    #while i <= n:                        <=           \r\n    #    total = combiner(total, term(i)) <=           \r\n    #    i += 1                           <=           \r\n    #return total                         <=           \r\n    return accumulate(combiner, base, )   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    if n == 0:\n        return base\n    else:\n        return combiner(base, term(n-1))\n    #i = 1\n    #total = base\n    #while i <= n:\n    #    total = combiner(total, term(i))\n    #    i += 1\n    #return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":109,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n        k +=k  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=k\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","7","","# Error: expected","#     15","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":110,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n        elif i == 0:    =>           \r\n        elif i >= n:    =>           \r\n        if i == 0:      <=           \r\n        elif i == n:    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if i == 0:\n            return combiner(base, combine(i+1))\n        elif i == n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if n == 0:\n            return base\n        elif i == 0:\n            return combiner(base, combine(i+1))\n        elif i >= n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    if n==0:\r\n        return base\r\n    return combine(0)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in combine","    if i == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":111,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1:           =>           \r\n    elif n == 0:         =>           \r\n        return base      =>           \r\n    if n == 1 or n == 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    accumulate(combiner, base, n, term)\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    terms = [term(x) for x in range(1, n + 1)]\n    if n == 1 or n == 0:\n        return combiner(base, terms[n-1])\n    else:\n        return combiner(terms[n-1], accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    accumulate(combiner, base, n, term)\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    terms = [term(x) for x in range(1, n + 1)]\n    if n == 1:\n        return combiner(base, terms[n-1])\n    elif n == 0:\n        return base\n    else:\n        return combiner(terms[n-1], accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, terms[n-1])","IndexError: list index out of range","","# Error: expected","#     11","# but got","#     IndexError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":112,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return total           =>           \r\n    return combiner(total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return combiner(total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    return combiner(total)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":113,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #result = base\n    #for x in range(1, n+1):\n    #    result = combiner(result, term(x))\n    #return result\n\n    if n == 1:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #result = base\n    #for x in range(1, n+1):\n    #    result = combiner(result, term(x))\n    #return result\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":114,"studentId":0,"date":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    f = combiner                                                 =>           \r\n        return f(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)   <=           \r\n                                                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return term(n) + accumulate(combiner, base, n-1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    f = combiner\n    if n == 0:\n        return base\n    else: \n        return f(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":115,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n        if n == 0:                <=           \r\n            n = n -1              <=           \r\n    total = combiner(total, base) <=           \r\n    total = 0                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<=n:\n        if n == 0:\n            n = n -1\n        total = combiner(term(k), total)\n        k = k + 1\n    total = combiner(total, base)\n    return total \n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k<=n:\n        total = combiner(term(k), total)\n        k = k + 1\n    return total \n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":116,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if combiner==add:                        =>           \r\n    elif combiner != mul and combiner !=add: =>           \r\n        x,y=1,1                              =>           \r\n        res_comb= combiner(x,y)              =>           \r\n        if res_comb==1:                      =>           \r\n            i, result = 1,1                  =>           \r\n        else:                                =>           \r\n            i, result= 0,0                   =>           \r\n    combiner= combiner(x,y)                  <=           \r\n    print (combiner)                         <=           \r\n    else:                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return term(base)\n    combiner= combiner(x,y)\n    print (combiner)\n    if combiner == mul:\n        i, result = 1,1 \n    else:\n        i, result= 0,0\n    while i <= n:\n        result = combiner(result, term(i))\n        i +=1\n    return combiner(base ,result)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return term(base)\n    if combiner == mul:\n        i, result = 1,1 \n    if combiner==add:\n        i, result= 0,0\n    elif combiner != mul and combiner !=add:\n        x,y=1,1\n        res_comb= combiner(x,y)\n        if res_comb==1:\n            i, result = 1,1\n        else: \n            i, result= 0,0\n    while i <= n:\n        result = combiner(result, term(i))\n        i +=1\n    return combiner(base ,result)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner= combiner(x,y)","NameError: name 'x' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":117,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, final_value = 2, term(1)\n    while k <= n:\n        final_value = combiner(final_value, term(k))\n        k += 1\n    return combiner(base, final_value)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    k, final_value = 2, term(1)\n    while k <= n:\n        final_value = combiner(final_value, term(k))\n        k += 1\n    return combiner(base, final_value)\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    if n==0:\r\n        return base\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":118,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = start, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":119,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if combiner==add and n > 0:   =>           \r\n    elif combiner==mul and n > 0: =>           \r\n    if combiner==add and n > 1:   <=           \r\n    elif combiner==mul and n > 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==add and n > 1:\n        return term(n) + accumulate(combiner, base, n-1, term)\n    elif combiner==mul and n > 1:\n        return term(n) * accumulate(combiner,base,n-1,term)\n    else:\n        return base\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==add and n > 0:\n        return term(n) + accumulate(combiner, base, n-1, term)\n    elif combiner==mul and n > 0:\n        return term(n) * accumulate(combiner,base,n-1,term)\n    else:\n        return base\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":120,"studentId":0,"date":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\ndef accumulate(combiner, base, n, term):               =>           \r\ndef accumulate(combiner, base, n, term, pred=True):    <=           \r\n    elif pred(n) == False:                             <=           \r\n        return accumulate(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term, pred=True):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif pred(n) == False:\n        return accumulate(combiner, base, n - 1, term)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif term(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    elif pred(n) == False:","TypeError: 'bool' object is not callable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":121,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if (n < 1):                                                         =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n    if (n == 0):                                                        <=           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0):\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n < 1):\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":122,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        a = combiner(a, term(summed))    =>           \r\ndef summation_using_accumulate(n, term): =>           \r\n        a + combiner(a, term(summed))    <=           \r\ndef summaton_using_accumulate(n, term):  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = base\n    summed = 1\n    while summed <= n:\n        a + combiner(a, term(summed))\n        summed += 1\n    return a\ndef summaton_using_accumulate(n, term):\n    \"\"\"Returns the sum of TERM(1) + ... + TERM(N). The implementation\n    uses accumulate.\n\n    >>> summation_using_accumulate(5, square)\n    55\n    >>> summation_using_accumulate(5, triple)\n    45\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',\n    ...       ['Recursion', 'For', 'While'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return accumulate(add, 0, n, term)\n\ndef product_using_accumulate(n, term):\n    \"\"\"An implementation of product using accumulate.\n\n    >>> product_using_accumulate(4, square)\n    576\n    >>> product_using_accumulate(6, triple)\n    524880\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'product_using_accumulate',\n    ...       ['Recursion', 'For', 'While'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return accumulate(mul, 1, n, term)\n\ndef true(x):\n    return True\n\ndef false(x):\n    return False\n\ndef odd(x):\n    return x % 2 == 1\n\ndef filtered_accumulate(combiner, base, pred, n, term):\n    \"\"\"Return the result of combining the terms in a sequence of N terms\n    that satisfy the predicate PRED.  COMBINER is a two-argument function.\n    If v1, v2, ..., vk are the values in TERM(1), TERM(2), ..., TERM(N)\n    that satisfy PRED, then the result is\n         BASE COMBINER v1 COMBINER v2 ... COMBINER vk\n    (treating COMBINER as if it were a binary operator, like +). The\n    implementation uses accumulate.\n\n    >>> filtered_accumulate(add, 0, true, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> filtered_accumulate(add, 11, false, 5, identity) # 11\n    11\n    >>> filtered_accumulate(add, 0, odd, 5, identity)   # 0 + 1 + 3 + 5\n    9\n    >>> filtered_accumulate(mul, 1, odd, 5, square)  # 1 * 1 * 9 * 25\n    225\n    >>> # Do not use while/for loops or recursion\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'filtered_accumulate',\n    ...       ['While', 'For', 'Recursion', 'FunctionDef'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return _______\n\ndef repeated(f, n):\n    \"\"\"Return the function that computes the nth application of f.\n\n    >>> add_three = repeated(increment, 3)\n    >>> add_three(5)\n    8\n    >>> repeated(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1\n    243\n    >>> repeated(square, 2)(5) # square(square(5))\n    625\n    >>> repeated(square, 4)(5) # square(square(square(square(5))))\n    152587890625\n    >>> repeated(square, 0)(5)\n    5\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef compose1(f, g):\n    \"\"\"Return a function h, such that h(x) = f(g(x)).\"\"\"\n    def h(x):\n        return f(g(x))\n    return h\n\ndef g(n):\n    \"\"\"Return the value of G(n), computed recursively.\n\n    >>> g(1)\n    1\n    >>> g(2)\n    2\n    >>> g(3)\n    3\n    >>> g(4)\n    10\n    >>> g(5)\n    22\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef g_iter(n):\n    \"\"\"Return the value of G(n), computed iteratively.\n\n    >>> g_iter(1)\n    1\n    >>> g_iter(2)\n    2\n    >>> g_iter(3)\n    3\n    >>> g_iter(4)\n    10\n    >>> g_iter(5)\n    22\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'g_iter', ['Recursion'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef pingpong(n):\n    \"\"\"Return the nth element of the ping-pong sequence.\n\n    >>> pingpong(7)\n    7\n    >>> pingpong(8)\n    6\n    >>> pingpong(15)\n    1\n    >>> pingpong(21)\n    -1\n    >>> pingpong(22)\n    0\n    >>> pingpong(30)\n    6\n    >>> pingpong(68)\n    2\n    >>> pingpong(69)\n    1\n    >>> pingpong(70)\n    0\n    >>> pingpong(71)\n    1\n    >>> pingpong(72)\n    0\n    >>> pingpong(100)\n    2\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\ndef has_seven(k):\n    \"\"\"Returns True if at least one of the digits of k is a 7, False otherwise.\n\n    >>> has_seven(3)\n    False\n    >>> has_seven(7)\n    True\n    >>> has_seven(2734)\n    True\n    >>> has_seven(2634)\n    False\n    >>> has_seven(734)\n    True\n    >>> has_seven(7777)\n    True\n    \"\"\"\n    if k % 10 == 7:\n        return True\n    elif k < 10:\n        return False\n    else:\n        return has_seven(k // 10)\n\ndef count_change(amount):\n    \"\"\"Return the number of ways to make change for amount.\n\n    >>> count_change(7)\n    6\n    >>> count_change(10)\n    14\n    >>> count_change(20)\n    60\n    >>> count_change(100)\n    9828\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef print_move(origin, destination):\n    \"\"\"Print instructions to move a disk.\"\"\"\n    print(\"Move the top disk from rod\", origin, \"to rod\", destination)\n\ndef move_stack(n, start, end):\n    \"\"\"Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.\n\n    n -- number of disks\n    start -- a pole position, either 1, 2, or 3\n    end -- a pole position, either 1, 2, or 3\n\n    There are exactly three poles, and start and end must be different. Assume\n    that the start pole has at least n disks of increasing size, and the end\n    pole is either empty or has a top disk larger than the top n start disks.\n\n    >>> move_stack(1, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    >>> move_stack(2, 1, 3)\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 3\n    >>> move_stack(3, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 3 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 1\n    Move the top disk from rod 2 to rod 3\n    Move the top disk from rod 1 to rod 3\n    \"\"\"\n    assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, \"Bad start/end\"\n    \"*** YOUR CODE HERE ***\"\n\n###################\n# Extra Questions #\n###################\n\nfrom operator import sub, mul\n\ndef Y(f):\n    \"\"\"The Y (\"paradoxical\") combinator.\"\"\"\n    return f(lambda: Y(f))\n\n\ndef Y_tester():\n    \"\"\"\n    >>> tmp = Y_tester()\n    >>> tmp(1)\n    1\n    >>> tmp(5)\n    120\n    >>> tmp(2)\n    2\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return Y(________)  # Replace \n\ndef zero(f):\n    return lambda x: x\n\ndef successor(n):\n    return lambda f: lambda x: f(n(f)(x))\ndef one(f):\n    \"\"\"Church numeral 1: same as successor(zero)\"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef two(f):\n    \"\"\"Church numeral 2: same as successor(successor(zero))\"\"\"\n    \"*** YOUR CODE HERE ***\"\n\nthree = successor(two)\n\ndef church_to_int(n):\n    \"\"\"Convert the Church numeral n to a Python integer.\n\n    >>> church_to_int(zero)\n    0\n    >>> church_to_int(one)\n    1\n    >>> church_to_int(two)\n    2\n    >>> church_to_int(three)\n    3\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef add_church(m, n):\n    \"\"\"Return the Church numeral for m + n, for Church numerals m and n.\n\n    >>> church_to_int(add_church(two, three))\n    5\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef mul_church(m, n):\n    \"\"\"Return the Church numeral for m * n, for Church numerals m and n.\n\n    >>> four = successor(three)\n    >>> church_to_int(mul_church(two, three))\n    6\n    >>> church_to_int(mul_church(three, four))\n    12\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef pow_church(m, n):\n    \"\"\"Return the Church numeral m ** n, for Church numerals m and n.\n\n    >>> church_to_int(pow_church(two, three))\n    8\n    >>> church_to_int(pow_church(three, two))\n    9\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = base\n    summed = 1\n    while summed <= n:\n        a = combiner(a, term(summed))\n        summed += 1\n    return a\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":123,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":124,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for x in range(2, n + 1): =>           \r\n    for x in range(n):        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(n):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(2, n + 1):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":125,"studentId":0,"date":null,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return base                                         =>           \r\n        next_base = combiner(term(n), base)                 =>           \r\n        return accumulate(combiner, next_base, n - 1, term) =>           \r\n        return acc                                          <=           \r\n        next_acc = combiner(term(n), acc)                   <=           \r\n        return accumulate(combiner, next_acc, n - 1, term)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return acc\n    else:\n        next_acc = combiner(term(n), acc)\n        return accumulate(combiner, next_acc, n - 1, term)\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        next_base = combiner(term(n), base)\n        return accumulate(combiner, next_base, n - 1, term)\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    next_acc = combiner(term(n), acc)","NameError: name 'acc' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":126,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    while n >= 1:                                                           =>           \r\n        n = n - 1                                                           =>           \r\n    total , counter =  10 , 1                                               =>           \r\n    while counter < n:                                                      =>           \r\n        total , counter  = total + n + 2 * (n-1) + 3 * (n-2) , counter + 1  =>           \r\n    return total                                                            =>           \r\n    while n <= 1:                                                           <=           \r\n        n = n + 1                                                           <=           \r\n                                                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n <= 1:\n        total = combiner(total, term(n))\n        n = n + 1\n    return total\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n >= 1:\n        total = combiner(total, term(n))\n        n = n - 1\n    return total\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":127,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":128,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n        return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":129,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return accumulate(combiner, base, n-1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":130,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":131,"studentId":0,"date":null,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if combiner == add:        =>           \r\n        i = 0                  =>           \r\n    if combiner == mul:        =>           \r\n        i = 1                  =>           \r\n            return i           =>           \r\n            return term(n + 1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return term(n + 1)\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        i = 0\n    if combiner == mul:\n        i = 1\n    def helper(n, term):\n        if n == 0:\n            return i\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":132,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    result = base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n>=1: \n        result = combiner(term(n), result)\n        n -= 1 \n    return result \n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n>=1: \n        result = combiner(term(n), result)\n        n -= 1 \n    return result \n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    result = combiner(term(n), result)","UnboundLocalError: local variable 'result' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":133,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(x), total) =>           \r\n        total = combiner(term, total)    <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term, total)\n\n    return total\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term(x), total)\n    return total\n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    total = combiner(term, total)","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":134,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    for i in range(1, n+1):      =>           \r\n    for i in range(base+1, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(base+1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base>=1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":135,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":136,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":137,"studentId":0,"date":null,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n#    if n == 0:                                           =>           \r\n#        return base                                      =>           \r\n#    def accu_helper(i):                                  =>           \r\n#        if i == 1:                                       =>           \r\n#            return term(1)                               =>           \r\n#        else:                                            =>           \r\n#            return combiner(term(i), accu_helper(i - 1)) =>           \r\n#    return combiner(base, accu_helper(n - 1))            =>           \r\n    if n == 0:                                            <=           \r\n        return base                                       <=           \r\n    def accu_helper(i):                                   <=           \r\n        if i == 1:                                        <=           \r\n            return term(1)                                <=           \r\n        else:                                             <=           \r\n            return combiner(term(i), accu_helper(i - 1))  <=           \r\n    return combiner(base, accu_helper(n - 1))             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def accu_helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return combiner(term(i), accu_helper(i - 1))\n    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n#    if n == 0:\n#        return base\n#    def accu_helper(i):\n#        if i == 1:\n#            return term(1)\n#        else:\n#            return combiner(term(i), accu_helper(i - 1))\n#    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-0))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":138,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\ndef helper(i, total): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\ndef helper(i, total):\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":139,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n==0:     =>           \r\n            return 0 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if n==0:\n            return 0\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, after_base(combiner, n, term, 1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in after_base","    if i==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":140,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(k)) =>           \r\n        total = combiner(base, term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(base, term(k))\n        k+= 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(total, term(k))\n        k+= 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        base = combiner(base, term(k))\r\n        k += 1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":141,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n        x = combiner(x, term(y))                                      =>           \r\n    return accumulate(combiner, base, lambda n : pred(n)==True, term) =>           \r\n        if pred(term(y))==True:                                       <=           \r\n            x = combiner(x, term(y))                                  <=           \r\n    return accumulate(combiner, base, n, term)                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        if pred(term(y))==True:\n            x = combiner(x, term(y))\n        y -= 1\n    return x\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        x = combiner(x, term(y))\n        y -= 1\n    return x\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    if pred(term(y))==True:","NameError: name 'pred' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":142,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        #print (total)               =>           \r\n    return total                     =>           \r\n        print (total)                <=           \r\n    return combiner(total, term(n))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i+1))\n        #term(i) = total\n        print (total)\n        i += 1\n    return combiner(total, term(n)) \n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i+1))\n        #term(i) = total\n        #print (total)\n        i += 1\n    return total \n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","3","6","10","15","20","","# Error: expected","#     15","# but got","#     1","#     3","#     6","#     10","#     15","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":143,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return cominer( term(n), accumulate(combiner, base, n-1, term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return cominer( term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return cominer( term(n), accumulate(combiner, base, n-1, term))","NameError: name 'cominer' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":144,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":145,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if r >= n and combiner==add: =>           \r\n        if r >= n and combiner==mul: =>           \r\n            return 1                 =>           \r\n                                     =>           \r\n                                     =>           \r\n                                     =>           \r\n        if r >= n:                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    def counter_n(r):\n        if r >= n:\n            return 0\n        else:\n            return combiner(term(r), counter_n(r+1))\n\n    return combiner(combiner(base, counter_n(1)), term(n))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    def counter_n(r):\n        if r >= n and combiner==add:\n            return 0\n\n        if r >= n and combiner==mul:\n            return 1\n\n        else:\n            return combiner(term(r), counter_n(r+1))\n\n\n    return combiner(combiner(base, counter_n(1)), term(n))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":146,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n    total=base                                                             =>           \r\n            return totaler(combiner,base,n-1,term,combiner(total,term(n))) =>           \r\n    total=1                                                                <=           \r\n            return totaler(combiner,base,n-1,term,total*term(n))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=1\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,total*term(n))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,combiner(total,term(n)))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","120","","# Error: expected","#     15","# but got","#     120","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":147,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combine(accumulate(combiner, base, n-1, term), term(n))\n        \nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        \nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":148,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n        if n == 0:         <=           \r\n            return 1       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 0:\n            return 1\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":149,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0 :                                                           =>           \r\n        return base                                                       =>           \r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n)) =>           \r\n    if n <=1 :                                                            <=           \r\n        return combiner(base, term(1))                                    <=           \r\n        combiner(accumulate(combiner, base, n - 1, term), term(n))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <=1 :\n        return combiner(base, term(1))\n    else:\n        combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 :\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(accumulate(combiner, base, n - 1, term), term(n))","TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":150,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":151,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = term(i)               <=           \r\n    return combiner(base, total)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = term(i)\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return combiner(base, total) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":152,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n                    =>           \r\n                    =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n == 1:\n        return combiner(base, term(1))\n    base = combiner(base, term(n))\n    return accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    \n    if n == 1:\n        return combiner(base, term(1))\n    \n    base = combiner(base, term(n))\n    \n    return accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":153,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        combiner(total, term(i))         <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        combiner(total, term(i))\n    return total\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":154,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n):   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n):\n        total=combiner(total, term(i))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":155,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while y<=n: =>           \r\n    while x<=n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while x<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while y<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":156,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return combiner(base, func(x)) =>           \r\n            return base + func(x)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return base + func(x)\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return combiner(base, func(x))\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return combiner(base, func(x))\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","44","","# Error: expected","#     72","# but got","#     44","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":157,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    total = 0           <=           \r\n    return base + total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return base + total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":158,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, i = base, 1                       =>           \r\n        total = combiner(total, term(i))     =>           \r\n    return total                             =>           \r\n    total, i = 1, 0                          <=           \r\n        total = combiner(term(i), term(i+1)) <=           \r\n        total = combiner(total, term(n))     <=           \r\n    return combiner(base, total)             <=           \r\n    else:                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = 1, 0\n    while i <= n:\n        total = combiner(term(i), term(i+1))\n        i = increment(i)\n    else:\n        total = combiner(total, term(n))\n    return combiner(base, total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i = increment(i)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":159,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return 0                       <=           \r\n    if n == 1:                         <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":160,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    result = base =>           \r\n    i = base      <=           \r\n    result = 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = base\n    result = 0\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    result = base\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":161,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if n==0:            =>           \r\n    if n==base or n==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==base or n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":162,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                   SideIndicator\r\n-----------                                                                                   -------------\r\n    k=1                                                                                       =>           \r\n    while k<=n:                                                                               =>           \r\n        base = combiner(base, term(k))                                                        =>           \r\n        k +=1                                                                                 =>           \r\n    n=1                                                                                       <=           \r\n    while n<=k:                                                                               <=           \r\n        base = combiner(base, term(n))                                                        <=           \r\n        n +=1                                                                                 <=           \r\n    return accumulate((lambda combiner: combiner if pred(combiner) else None), base, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    n=1\n    while n<=k:\n        base = combiner(base, term(n))\n        n +=1\n    return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    while k<=n:\n        base = combiner(base, term(k))\n        k +=1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    while n<=k:","NameError: name 'k' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":163,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":164,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>=1: =>           \r\n    while n>=0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=0:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=1:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":165,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 0:                        =>           \r\n        if n == 0:                       =>           \r\n            return end                   =>           \r\n        else:                            =>           \r\n            end = combiner(end, term(n)) =>           \r\n            n -=1                        =>           \r\n    if n == 0:                           <=           \r\n        return end                       <=           \r\n    elif n > 0:                          <=           \r\n        end = combiner(end, term(n))     <=           \r\n        n -=1                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    if n == 0:\n        return end\n    elif n > 0:\n        end = combiner(end, term(n))\n        n -=1\n    return end\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    while n >= 0:\n        if n == 0:\n            return end\n        else:\n            end = combiner(end, term(n))\n            n -=1\n    return end\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":166,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n ==0:         =>           \r\n    if n ==0 or n==1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n ==0 or n==1:\n        return base             \n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n ==0:\n        return base             \n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":167,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    elif n == 1: <=           \r\n        return 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn 1\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==base:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":168,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    k, total = 1, base =>           \r\n    k, total = 1, 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, 0\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, base\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":169,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    # total = combiner(base, term(n))                               =>           \r\n    # def recursive_combiner(combiner, n, term):                    =>           \r\n    #    if count == 1:                                             =>           \r\n    #        return combiner(base, term(n))                         =>           \r\n    #    if count == n:                                             =>           \r\n    #        return total                                           =>           \r\n    #    return recursive_combiner(combiner, n-1, term)             =>           \r\n    #return recursive_combiner(combiner, n, term)                   =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n                                                                    =>           \r\n    total = term(n)                                                 <=           \r\n    if n == base:                                                   <=           \r\n        return total                                                <=           \r\n    return combiner(n-1, total)                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(n)\n    if n == base:\n        return total\n    return combiner(n-1, total)\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n    # total = combiner(base, term(n))\n    # def recursive_combiner(combiner, n, term):\n    #    if count == 1:\n    #        return combiner(base, term(n))\n    #    if count == n:\n    #        return total\n    #    return recursive_combiner(combiner, n-1, term)\n\n    #return recursive_combiner(combiner, n, term)\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":170,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        total, k = combiner(term(k), total), k + 1   =>           \r\n        total, k = combiner * total * term(k), k + 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner * total * term(k), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    total, k = combiner * total * term(k), k + 1","TypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":171,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term)) =>           \r\n            return term(i) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return term(i) + accumulate(combiner, base, n-1, term)\n    return helper(n)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\r\n    return helper(n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":172,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(term(i))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(term(i))\n        i += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term(i))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":173,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":174,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    elif base==0 and n==1: =>           \r\n        return term(1)     =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n==0:\n    \treturn base\n    elif base==0:\n    \treturn combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n    \treturn combiner(base,accumulate(combiner,0,n,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n==0:\n    \treturn base\n    elif base==0 and n==1:\n    \treturn term(1)\n    elif base==0:\n    \treturn combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n    \treturn combiner(base,accumulate(combiner,0,n,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==base:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":175,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return base + accumulate(combiner, base, n - 1, term)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn base + accumulate(combiner, base, n - 1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":176,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(c, term(i))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(c, term(i))\n        i=i+1\n    return total \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(total, term(i))\n        i=i+1\n    return total \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total = combiner(c, term(i))","NameError: name 'c' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":177,"studentId":0,"date":null,"diff":"\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    res = base                                                 =>           \r\n    for i in [term(x) for x in range(1, n+1)]:                 =>           \r\n        res = combiner(res, i)                                 =>           \r\n    return res                                                 =>           \r\n    return reduce([base] + map(range(1, n+1), term), combiner) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     term1 = term(1)\n    #     accum = combiner(base, term1)\n    #     k = 2\n    #     while k <= n:\n    #         terms = term(k)\n    #         accum = combiner(accum, terms)\n    #         k += 1\n    #     return accum\n    return reduce([base] + map(range(1, n+1), term), combiner)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     term1 = term(1)\n    #     accum = combiner(base, term1)\n    #     k = 2\n    #     while k <= n:\n    #         terms = term(k)\n    #         accum = combiner(accum, terms)\n    #         k += 1\n    #     return accum\n    res = base\n    for i in [term(x) for x in range(1, n+1)]:\n        res = combiner(res, i)\n    return res\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return reduce([base] + map(range(1, n+1), term), combiner)","NameError: name 'reduce' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":178,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            total = combiner(total, term(k)) =>           \r\n            total = combiner(base, term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(base, term(k))\n            k = k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(total, term(k))\r\n            k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":179,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total = base                          =>           \r\n        return total                      =>           \r\n    total = 0                             <=           \r\n        return base                       <=           \r\n    \"\"\"while i <= n:                      <=           \r\n        total == combiner(total, term(i)) <=           \r\n        i += 1                            <=           \r\n    return total\"\"\"                       <=           \r\n                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    total = 0\n    if n == 0:\n        return base\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n    \"\"\"while i <= n:\n        total == combiner(total, term(i))\n        i += 1\n    return total\"\"\"\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    total = base\n    if n == 0:\n        return total\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":180,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if n == 0:                               =>           \r\n        return term(base)                    =>           \r\n        i = 1                                =>           \r\n        total = base                         =>           \r\n        while i <= n:                        =>           \r\n            total = combiner(term(i), total) =>           \r\n            i += 1                           =>           \r\n        return total                         =>           \r\n    else:                                    =>           \r\n                                             =>           \r\n                                             =>           \r\n    i = 1                                    <=           \r\n    total = 1                                <=           \r\n    while i <= n:                            <=           \r\n        total = term(i) + total              <=           \r\n        i += 1                               <=           \r\n    return total                             <=           \r\n    \"*** YOUR CODE HERE ***\"                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        i = 1\n        total = base\n        while i <= n:\n            total = combiner(term(i), total)\n            i += 1\n        return total\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":181,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                 =>           \r\n    if pred == false:                                                                   =>           \r\n        return base                                                                     =>           \r\n        return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term) =>           \r\n    else:                                                                               =>           \r\n        return combiner(term(base), accumulate(combiner, base, n+1, term))              <=           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(base), accumulate(combiner, base, n+1, term))        \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":182,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n    73      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    73\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     73","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":183,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while i != n + 1: =>           \r\n    while i != n:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n + 1:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n+1:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":184,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    total=base                                =>           \r\n        total = combiner(total,term(counter)) =>           \r\n    return total                              =>           \r\n    total=0                                   <=           \r\n        total = combiner(base,term(counter))  <=           \r\n    return combiner(total,base)               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=0\n    counter = 1\n\n    while counter <=n:\n        total = combiner(base,term(counter))\n        counter+=1\n\n    return combiner(total,base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=base\n    counter = 1\n\n    while counter <=n:\n        total = combiner(total,term(counter))\n        counter+=1\n\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":185,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    tot = base                          =>           \r\n    i = 1                               =>           \r\n    while i <= n:                       =>           \r\n        tot = combiner(tot, term(i))    =>           \r\n        i+=1                            =>           \r\n    tot = term(base);                   <=           \r\n    base += 1                           <=           \r\n    while base <= n:                    <=           \r\n        tot = combiner(tot, term(base)) <=           \r\n        base+=1                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = term(base);\n    base += 1\n    while base <= n:\n        tot = combiner(tot, term(base))\n        base+=1\n    return tot\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = base\n    i = 1\n    while i <= n:\n        tot = combiner(tot, term(i))\n        i+=1\n    return tot\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":186,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n<=1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in combine","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":187,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return helper(n) =>           \r\n    helper(n)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":188,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":189,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                                             SideIndicator\r\n-----------                                                                                                             -------------\r\n    if n == 0:                                                                                                          =>           \r\n        return base                                                                                                     =>           \r\n    elif n == 1:                                                                                                        =>           \r\n        return combiner(term(1), base)                                                                                  =>           \r\n    else:                                                                                                               =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                 =>           \r\n    return accumulate(add, 0, n, term)                                                                                  =>           \r\n    return accumulate(mul, 1, n, term)                                                                                  =>           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)                                     =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return f                                                                                                        =>           \r\n    elif n == 0:                                                                                                        =>           \r\n        return identity                                                                                                 =>           \r\n    else:                                                                                                               =>           \r\n        return compose1(f, repeated(f, n-1))                                                                            =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)                                                                   =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n        n_minus_1, n_minus_2, n_minus_3  = 3, 2, 1                                                                      =>           \r\n        k = 4                                                                                                           =>           \r\n        while k <= n:                                                                                                   =>           \r\n            n_minus_1, n_minus_2, n_minus_3 = n_minus_2, n_minus_1, n_minus_1 + 2*n_minus_2+ 3*n_minus_3                =>           \r\n            k = k + 1                                                                                                   =>           \r\n    return n_minus_1                                                                                                    =>           \r\n    def move(k, i, forward):                                                                                            =>           \r\n        if k == n:                                                                                                      =>           \r\n            return i                                                                                                    =>           \r\n        elif forward:                                                                                                   =>           \r\n            return change(k+1, i+1, forward) #it is looking for the k(th) term in the sequence, i moves between 0 and 7 =>           \r\n        else:                                                                                                           =>           \r\n            return change(k+1, i-1, forward)#if forward is true, i will be reduced                                      =>           \r\n    def change(k, i, forward):                                                                                          =>           \r\n        if k % 7 == 0 or has_seven(k):                                                                                  =>           \r\n            return move(k, i, not forward) #move down                                                                   =>           \r\n        else:                                                                                                           =>           \r\n            return move(k, i, forward) #move forward                                                                    =>           \r\n                                                                                                                        =>           \r\n    if n < 7:                                                                                                           =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return move(7,7, False)                                                                                         =>           \r\n    else:                                                                                                               =>           \r\nfrom math import *                                                                                                      =>           \r\n    def count(n, m):                                                                                                    =>           \r\n        if m == 1:                                                                                                      =>           \r\n            return 1                                                                                                    =>           \r\n        if n < 0:                                                                                                       =>           \r\n            return 0                                                                                                    =>           \r\n        with_m = count(n - m, m)                                                                                        =>           \r\n        without_m = count(n, m//2)                                                                                      =>           \r\n        return with_m + without_m                                                                                       =>           \r\n    return count(amount, 2**highest_power(amount))                                                                      =>           \r\n#this question was done using John Denero's Fall 2015 Lecture on recursion (lec 7), where he showed how yo sol          =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return print_move(start,end)                                                                                    =>           \r\n    if start == 1 or end == 1:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 3                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 1                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 1 or end == 1:                                                                                      =>           \r\n            middle = 2                                                                                                  =>           \r\n    def move():                                                                                                         =>           \r\n        move_stack(n-1, start, middle)                                                                                  =>           \r\n        print_move(start, end)                                                                                          =>           \r\n        move_stack(n-1, middle, end)                                                                                    =>           \r\n    return move()                                                                                                       =>           \r\n                                                                                                                        =>           \r\n                                                                                                                        =>           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base \n    elif n == 1: \n        return combiner(term(1), base)\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":190,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        b,k = combiner(b,term(k)), k+1    =>           \r\n        b,k = combiner(base,term(k)), k+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(base,term(k)), k+1\n    return b\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(b,term(k)), k+1\n    return b\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":191,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, f(i))\n        i = i + 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, term(i))\n        i = i + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":192,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        return combiner(a,base) =>           \r\n        return a                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return a\n    return a\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return combiner(a,base)\n    return a\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":193,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    while k <= n:                       =>           \r\n    return total                        =>           \r\n    if k <= n:                          <=           \r\n        return combiner(total, term(k)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    if k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n        return combiner(total, term(k))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","3","","# Error: expected","#     15","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":194,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if combiner == mul and k==1: =>           \r\n        if combiner == mul:          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<= n:\n        if combiner == mul:\n                total = 1\n        total = combiner(total, term(k))\n        k = k + 1\n    return combiner(base, total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<= n:\n        if combiner == mul and k==1:\n                total = 1\n        total = combiner(total, term(k))\n        k = k + 1\n    return combiner(base, total)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":195,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    total = base                         =>           \r\n        total = combiner(total, term(i)) =>           \r\n    total = 0                            <=           \r\n        total = combiner(base, term(i))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total = combiner(base, term(i))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":196,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=1          =>           \r\n    while k<n+1: =>           \r\n    k=0          <=           \r\n    while k<n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=0\n    partial_total=base\n    while k<n:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=1\n    partial_total=base\n    while k<n+1:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":197,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner (total, term(k)) =>           \r\n                                          =>           \r\n        total = combiner (total, term(n)) <=           \r\n                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(n))\n        k += 1\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(k))\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":198,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = start, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":199,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n                    =>           \r\n    if n == 1:      <=           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":200,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    '''number = 1                          =>           \r\n    for i in [1,n]:                        =>           \r\n    return combiner(base, number)'''       =>           \r\n    number = base                          =>           \r\n    for i in range(1, n+1):                =>           \r\n        number = combiner(number, term(i)) =>           \r\n    return number                          =>           \r\n                                           =>           \r\n                                           =>           \r\n    number = 1                             <=           \r\n    for i in [0, n]:                       <=           \r\n    return combiner(base, number)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    number = 1\n    for i in [0, n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    '''number = 1\n    for i in [1,n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)'''\n\n    number = base\n    for i in range(1, n+1):\n        number = combiner(number, term(i))\n    return number\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":201,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner(total, term(k))  =>           \r\n        total = combiner(total + term(k)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total + term(k))\n        k += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total + term(k))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":202,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total, k = base, 1\n\n    while k <= n:\n        total = combiner(total,term(k))\n        k = increment(k)\n        print(total)\n\n\n    return total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total, k = base, 1\n\n    while k <= n:\n        total = combiner(total,term(k))\n        k = increment(k)\n        \n\n\n    return total\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","3","6","10","15","15","","# Error: expected","#     15","# but got","#     1","#     3","#     6","#     10","#     15","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":203,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total(n) =>           \r\n    return total(1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(1)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(n)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":204,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))","TypeError: 'int' object is not callable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":205,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n >= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n == 1:\n            n = term(n)\n        return combiner(n, accumulation)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n >= 1:\n            n = term(n)\n        return combiner(n, accumulation)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if 1==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":206,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, x = base, 1 =>           \r\n                       =>           \r\n    total, x = base, 0 <=           \r\n                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 0\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 1\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 1\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":207,"studentId":0,"date":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n            return combiner(term(i), counter(i+1))  =>           \r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n    else:                                           =>           \r\n        return combiner(base, counter(1))           =>           \r\n            return combiner(term(i), counter(i+1))  <=           \r\n    return combiner(base, counter(1))               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1)) \n    return combiner(base, counter(1))   \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1))\n    if n == 0:\n        return base\n    else:         \n        return combiner(base, counter(1))   \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, counter(1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in counter","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":208,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":209,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    counter = 1         =>           \r\n    while counter <= n: =>           \r\n    counter = 0         <=           \r\n    while counter < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    amount = base\n    if n == 0:\n        return combiner(base, 0)\n    while counter < n:\n        if term(n):\n            amount = combiner(amount, term(counter))\n            counter = counter + 1\n    return amount\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    amount = base\n    if n == 0:\n        return combiner(base, 0)\n    while counter <= n:\n        if term(n):\n            amount = combiner(amount, term(counter))\n            counter = counter + 1\n    return amount\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":210,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return sum_function(n) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n            \n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n    return sum_function(n)\n            \n        \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":211,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n                                    =>           \r\n        total, i = base, 1          =>           \r\n        while i < n:                =>           \r\n    return combiner(term(n), total) =>           \r\n                                    <=           \r\n        total, i = 0, 1             <=           \r\n        while i <= n:               <=           \r\n    return combiner(base, total)    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0: \n        return base\n    else: \n        total, i = 0, 1\n        while i <= n: \n            total = combiner(term(i), total)\n            i += 1\n    return combiner(base, total)\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0: \n        return base\n    else: \n        total, i = base, 1\n        while i < n: \n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = base, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":212,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n            return base =>           \r\n        return base     =>           \r\n            return 0    <=           \r\n        return 0        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return base\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":213,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n      return combiner (accumulate(combiner, base, n-1, term), term(n))  =>           \r\n      return accumulate(combiner, base, n-1, term)                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return accumulate(combiner, base, n-1, term) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return combiner (accumulate(combiner, base, n-1, term), term(n)) \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":214,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return combiner(together(1) , base) =>           \r\n    return together(1) + base           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return together(1) + base\n\n\n    \n   \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return combiner(together(1) , base)\n\n\n    \n   \n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return combiner(together(1), base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":215,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(1), accumulate(combiner, base, n-1, term))\n\n\n    \n \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    \n \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":216,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    answer = base       =>           \r\n    if combiner == mul: <=           \r\n        answer = 1      <=           \r\n        answer = 0      <=           \r\n    else:               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    if combiner == mul:\n        answer = 1\n    else:\n        answer = 0\n    while i < (n+1):\n        answer = combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    answer = base\n    while i < (n+1):\n        answer = combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = base\r\n    else:\r\n        answer = base\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":217,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 0:           =>           \r\n    if n == 0 or n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    total = base\n    x = 1 #start at 1 to deal with the edge case when you square 0\n    if(n == 0):\n        return identity(base)\n    while x <= n: #<= because first one is adding base\n        total = combiner(total, term(x)) \n        x += 1\n    return total\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    total = base\n    x = 1 #start at 1 to deal with the edge case when you square 0\n    if(n == 0):\n        return identity(base)\n    while x <= n: #<= because first one is adding base\n        total = combiner(total, term(x)) \n        x += 1\n    return total\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":218,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    return base    =>           \r\n    return counter <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return counter\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return base\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return counter","NameError: name 'counter' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":219,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    \n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     ","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":220,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n        return combiner(term(n), accumulate(combiner, n, n-1,term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, n, n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":221,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n ==1:        =>           \r\n            return term(1) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        elif n ==1:\n            return term(1)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":222,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return base                       =>           \r\n        return combiner(term(0), term(1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n<0:\n        return term(0)\n    else:\n        return combiner(base, accumulate(combiner,term(n),term(n-1),term))\"\"\"\n\n    if n == 0:\n        return combiner(term(0), term(1))\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n<0:\n        return term(0)\n    else:\n        return combiner(base, accumulate(combiner,term(n),term(n-1),term))\"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","1","","# Error: expected","#     11","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":223,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, f(i))\n        i += 1\n    return total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":224,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    combine = base                           =>           \r\n        combine = combiner(combine, term(i)) =>           \r\n        combine = combiner(base, term(i))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    while i < n:\n        i += 1\n        combine = combiner(base, term(i))\n    return combine\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    combine = base\n    while i < n:\n        i += 1\n        combine = combiner(combine, term(i))\n    return combine\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":225,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return base + term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":226,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if n == 0:                     =>           \r\n            return base                =>           \r\n        if i >= n:                     =>           \r\n    return help(1, term)               =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n        if i == n:                     <=           \r\n    return help(0, term)               <=           \r\n    return _______                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if i == n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(0, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if n == 0:\n            return base\n        if i >= n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":227,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result = base   =>           \r\n    result = start  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = start \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = base \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = base\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":228,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return combiner(term(n),accumulate(n-1))                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":229,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":230,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":231,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n-1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n-1):\n        total=combiner(total, term(i))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":232,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, i = combiner(total, term(i)), i + 1 =>           \r\n        total = combiner(total, term(i))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":233,"studentId":0,"date":null,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        total, k = combiner(total,term (k)), k+1 =>           \r\n        total, k = combiner(total,term (k))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term (k))\n    return total\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term (k)), k+1\n    return total\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    total, k = combiner(total,term (k))","TypeError: 'int' object is not iterable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":234,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n        return                                                          <=           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return\n    else:\n        return combiner(base, accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":235,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(n, term(accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(n, term(accumulate(combiner, base, n-1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","221592999","","# Error: expected","#     25","# but got","#     221592999","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":236,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        print (term(counter)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n        \"\"\"\n   \n    accumulate_sum = base\n    counter = 1\n    while counter <= n:\n        print (term(counter))\n        accumulate_sum = combiner(accumulate_sum, term(counter))\n        counter += 1\n    return accumulate_sum\n\n  \nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n        \"\"\"\n   \n    accumulate_sum = base\n    counter = 1\n    while counter <= n:\n        accumulate_sum = combiner(accumulate_sum, term(counter))\n        counter += 1\n    return accumulate_sum\n\n  \nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","2","3","4","5","15","","# Error: expected","#     15","# but got","#     1","#     2","#     3","#     4","#     5","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":237,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":238,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return combiner(base, term(1))       =>           \r\n        return combiner(term(base), term(1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(term(base), term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":239,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n    return _______                                                          =>           \r\n        if pred(n):                                                         <=           \r\n            return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    if not pred(n):                                                         <=           \r\n        return base                                                         <=           \r\n        return accumulate(combiner, base, n, term)                          <=           \r\n    else:                                                                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        if pred(n):\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if term(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if pred(n):","NameError: name 'pred' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":240,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        if n == 0:            =>           \r\n    return counter(n)         =>           \r\n        if n == 1:            <=           \r\n    return counter(n)         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)        \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":241,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n == 0:                        =>           \r\n        return base                   =>           \r\n    return combiner(base, indexer(1)) =>           \r\n    return base + indexer(1)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def indexer(count):\n        if count == n:\n            return term(n)\n        else:\n            return combiner(term(count) , indexer(count + 1))\n    return base + indexer(1)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    def indexer(count):\n        if count == n:\n            return term(n)\n        else:\n            return combiner(term(count) , indexer(count + 1))\n    return combiner(base, indexer(1))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in indexer","    return combiner(term(count) , indexer(count + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in indexer","    if count == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":242,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        if n >= 1 :   =>           \r\n        if n == True: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n == True:\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n >= 1 :\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==n:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":243,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total, a = base, 1            =>           \r\n    return total                  =>           \r\n    total, a = 1, 1               <=           \r\n    return combiner(base,total-1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = 1, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return combiner(base,total-1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = base, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = base, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","70","","# Error: expected","#     72","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":244,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif(n == 0):      =>           \r\n        return term(n) =>           \r\n    elif(i == n):      <=           \r\n        return term(i) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(i == n):\n        return term(i)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(n == 0):\n        return term(n)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (base==n):\r\n        return term(base)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    elif(i == n):","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":245,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        base=combiner(base,term(count))  =>           \r\n    return base                          =>           \r\n        final=combiner(base,term(count)) <=           \r\n    return final                         <=           \r\n    final=base                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    final=base\n    while count< n+1:\n        final=combiner(base,term(count))\n        count+=1\n    return final\n\n    \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    while count< n+1:\n        base=combiner(base,term(count))\n        count+=1\n    return base \n\n    \n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        base = final = combiner(base, term(count))\r\n        count += 1\r\n    return final","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":246,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        finalResult = combiner(finalResult,term(i))  =>           \r\n        finalProduct = combiner(finalResult,term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalProduct = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalResult = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalResult = finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":247,"studentId":0,"date":null,"diff":"\r\nInputObject                                                SideIndicator\r\n-----------                                                -------------\r\n    def count_comber(x):                                   =>           \r\n            return base                                    =>           \r\n            return combiner(term(x), count_comber(x+1))    =>           \r\n    return count_comber(1)                                 =>           \r\n    def count_comber(x, b):                                <=           \r\n            return combiner(base, b)                       <=           \r\n            return combiner(term(x), count_comber(x+1, b)) <=           \r\n    return count_comber(1, 0)                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x, b):\n        if x == n+1:\n            return combiner(base, b)\n        else:\n            return combiner(term(x), count_comber(x+1, b))\n    return count_comber(1, 0)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x):\n        if x == n+1:\n            return base\n        else:\n            return combiner(term(x), count_comber(x+1))\n    return count_comber(1)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return b\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":248,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        x = combiner(x, term(y))  =>           \r\n        x *= combiner(x, term(y)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x *= combiner(x, term(y))\n        y += 1\n    return x\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x = combiner(x, term(y))\n        y += 1\n    return x\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":249,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    25      =>           \r\n    225     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    225\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25","","# Error: expected","#     225","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":250,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n        total = combiner(term(n), total) =>           \r\n    if n == 1:                           <=           \r\n        return 1                         <=           \r\n        total = combiner(term(n), base)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 1:\n        return 1\n    else:\n        total = combiner(term(n), base)\n        return accumulate(combiner, total, n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return base\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":251,"studentId":0,"date":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return combiner(base,first_sequence(1)) =>           \r\n        return combiner(base,first_sequence(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(0))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":252,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n += 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n -= 1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":253,"studentId":0,"date":null,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n            return term(n)+ accumulate(combiner, base, n-1, term) =>           \r\n            return term(n)* accumulate(combiner, base, n-1, term) =>           \r\n            return n+ accumulate(combiner, base, n-1, term)       <=           \r\n            return n* accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0: \n        return base\n    else: \n        if combiner == add:\n            return n+ accumulate(combiner, base, n-1, term)\n        else: \n            return n* accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0: \n        return base\n    else: \n        if combiner == add:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n        else: \n            return term(n)* accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":254,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        amount = combiner(amount, term(x)) =>           \r\n        combiner(amount, term(x))          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        amount = combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":255,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    if n == 0:                                                        =>           \r\n        return base                                                   =>           \r\n    return accumulate(combiner, combiner(term(n), base), n - 1, term) =>           \r\n    return k                                                          =>           \r\n    def helper(combiner, n, term):                                    <=           \r\n        current, next = term(1), term(2)                              <=           \r\n        while n > 0:                                                  <=           \r\n            total += term(n)                                          <=           \r\n            n -= 1                                                    <=           \r\n            return total                                              <=           \r\n    return combiner(base, helper(combiner, n, term))                  <=           \r\n    outcomes = []                                                     <=           \r\n        k = 1                                                         <=           \r\n        outcomes.append(k)                                            <=           \r\n    return outcomes[n + 1]                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    def helper(combiner, n, term):\n        current, next = term(1), term(2) \n        while n > 0: \n            total += term(n)\n            n -= 1\n            return total\n    return combiner(base, helper(combiner, n, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    if n == 0:\n        return base\n    return accumulate(combiner, combiner(term(n), base), n - 1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 87, in accumulate","    return combiner(base, helper(combiner, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in helper","    total += term(n)","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":256,"studentId":0,"date":null,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return term(n) + accumulate(combiner, base, n-1, term) =>           \r\n            return term(n) * accumulate(combiner, base, n-1, term) =>           \r\n            return n + accumulate(combiner, base, n-1, term)       <=           \r\n            return n * accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return n + accumulate(combiner, base, n-1, term)\n        else:\n            return n * accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return term(n) + accumulate(combiner, base, n-1, term)\n        else:\n            return term(n) * accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":257,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    k = 1                                =>           \r\n    total = base                         =>           \r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n    while k <= n:                        =>           \r\n        total = combiner(total, term(k)) =>           \r\n        k += 1                           =>           \r\n    total = start                        <=           \r\n    for i in range(n):                   <=           \r\n        total = combiner(total, f(i+1))  <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = start\n    for i in range(n):\n        total = combiner(total, f(i+1))\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":258,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner,base, n - 1, term)) =>           \r\n        return accumulate(combiner, base, n - 1, term)                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n - 1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n - 1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":259,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, x = term(1), 1                    =>           \r\n    while x < n :                            =>           \r\n        total = combiner(total, term(x + 1)) =>           \r\n        x += 1                               =>           \r\n    if n == 0:                               =>           \r\n        total = 0                            =>           \r\n    return combiner(base, total)             =>           \r\n                                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = term(1), 1\n    while x < n :\n        total = combiner(total, term(x + 1))\n        x += 1\n    if n == 0:\n        total = 0\n    return combiner(base, total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":260,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":261,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))  =>           \r\n        new_base = combiner(base, term(n))                               <=           \r\n        return combiner(base, accumulate(combiner, new_base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        new_base = combiner(base, term(n))\n        return combiner(base, accumulate(combiner, new_base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","41","","# Error: expected","#     15","# but got","#     41","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":262,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n > 1:        =>           \r\n    elif n == 1:     =>           \r\n        return base  =>           \r\n    if n != 1:       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n != 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    else:\n        return combiner(base, term(1))\n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return base \n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    if n != 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":263,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    return combiner(result, base) =>           \r\n    return result + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return result + base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return combiner(result, base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return combiner(result, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":264,"studentId":0,"date":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    if n == 0:                                         =>           \r\n        return base                                    =>           \r\n    elif n == 1:                                       =>           \r\n        return combiner(base, term(n))                 =>           \r\n        base = combiner(base, term(n))                 =>           \r\n        return accumulate(combiner, base, n - 1, term) =>           \r\n    else:                                              =>           \r\n                                                       =>           \r\n    def helper(combiner, base, n, term):               <=           \r\n        if n == 0:                                     <=           \r\n            return base                                <=           \r\n        elif n == 1:                                   <=           \r\n            return combiner(base, term(n))             <=           \r\n        else:                                          <=           \r\n            return helper(combiner, base, n - 1, term) <=           \r\n    return helper(combiner, base, n, term)             <=           \r\n                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(combiner, base, n, term):\n        if n == 0:\n            return base\n        elif n == 1:\n            return combiner(base, term(n))\n        else:\n            return helper(combiner, base, n - 1, term)\n    return helper(combiner, base, n, term)\n\n    \nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), helper(combiner, base, n-1, term))\r\n    return helper(combiner, base, n, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":265,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))   =>           \r\n    # count = 0                                                       =>           \r\n    # accu_res = base                                                 =>           \r\n    # while count < len(mapped):                                      =>           \r\n    #     accu_res = combiner(accu_res, mapped[count])                =>           \r\n    #     count += 1                                                  =>           \r\n    # return accu_res                                                 =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))    =>           \r\n    count = 0                                                         =>           \r\n    while count < len(mapped):                                        =>           \r\n            accu_res = combiner(accu_res, mapped[count])              =>           \r\n            count += 1                                                =>           \r\n                                                                      =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0) <=           \r\n    i = 0                                                             <=           \r\n    while i < len(mapped):                                            <=           \r\n        accu_res = combiner(accu_res, mapped[0])                      <=           \r\n        i += 1                                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0)\n    i = 0 \n    accu_res = base\n    while i < len(mapped):\n        accu_res = combiner(accu_res, mapped[0])\n        i += 1\n    return accu_res\n    \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))\n    # count = 0 \n    # accu_res = base\n    # while count < len(mapped):\n    #     accu_res = combiner(accu_res, mapped[count])\n    #     count += 1\n    # return accu_res\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))\n    count = 0 \n    accu_res = base\n    while count < len(mapped):\n    \t\taccu_res = combiner(accu_res, mapped[count])\n    \t\tcount += 1\n    return accu_res\n    \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    accu_res = combiner(accu_res, mapped[0])","TypeError: unsupported operand type(s) for +: 'int' and 'list'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":266,"studentId":0,"date":null,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    if n == 0 and combiner == mul: <=           \r\n        base = 1                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0 and combiner == mul:\n        base = 1\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    \n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    \n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","36","","# Error: expected","#     72","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":267,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))    <=           \r\n        return combiner(term(n), accumulate(combiner, 1, n-1, term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif combiner == add:\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))\n    elif combiner == mul:\n        return combiner(term(n), accumulate(combiner, 1, n-1, term))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif combiner == add:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    elif combiner == mul:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":268,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n        elif i == n:       =>           \r\n        if i == n:         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(combiner, n, i, term):\n        if n == 1:\n            return term(1)\n        if i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(combiner, n, i + 1, term))\n    return combiner(base, helper(combiner, n, 1, term))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(combiner, n, i, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        elif i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(combiner, n, i + 1, term))\n    return combiner(base, helper(combiner, n, 1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":269,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn term(base)\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t\n","after":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn base\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":270,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":271,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                                         SideIndicator\r\n-----------                                                                                                         -------------\r\n    def le_count(combiner, i):                                                                                      =>           \r\n        if n == i:                                                                                                  =>           \r\n            return term(n)                                                                                          =>           \r\n            return combiner(term(i), le_count(combiner, i + 1))                                                     =>           \r\n    return combiner(base, le_count(combiner, 1))                                                                    =>           \r\n        else:                                                                                                       =>           \r\n        return term(n)                                                                                              <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term))) <=           \r\n    elif n == 1:                                                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return term(n)\n    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def le_count(combiner, i):\n        if n == i:\n            return term(n)\n        else:\n            return combiner(term(i), le_count(combiner, i + 1))\n    return combiner(base, le_count(combiner, 1))\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, lambda base: 1 if base == mul else 0, n-1, term)))","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":272,"studentId":0,"date":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n        return combiner(base, accumulate_helper(1)) =>           \r\n    else:                                           =>           \r\n    return combiner(base, accumulate_helper(0))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    return combiner(base, accumulate_helper(0))\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate_helper(1))\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":273,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(term(0), base) =>           \r\n    elif n == 1:                       =>           \r\n    if n == 1:                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(0), base)\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":274,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(1), base) =>           \r\n        return term(1) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return term(1) + base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":275,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":276,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if k == n+1: =>           \r\n        if k == n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n+1:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k>n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":277,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        return combiner(total, base) =>           \r\n        return total                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return combiner(total, base)\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":278,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        x = combiner(x,term(i)) =>           \r\n    return x                    =>           \r\n                                =>           \r\n        t = combiner(t,term(i)) <=           \r\n    return t                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        t = combiner(t,term(i))\n        i += 1\n    return t\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        x = combiner(x,term(i))\n        i += 1\n    return x\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    t = combiner(t,term(i))","UnboundLocalError: local variable 't' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":279,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n - 1, term))       <=           \r\n    \"*** YOUR CODE HERE ***\"                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":280,"studentId":0,"date":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    return accumulater(combiner, base, n, term, total) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n    return accumulater(combiner, base, n, term, total)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":281,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    return total       =>           \r\n    total = term(base) <=           \r\n    return total       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n    while n >= 1:\n        total = combiner(total, term(n))\n        n-=1\n    return total    \n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n-=1\n    return total\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":282,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n    assert n>=0                         =>           \r\n    assert n>0                          =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        start = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":283,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>k:  =>           \r\n    while n>=k: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>=k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k+1:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":284,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":285,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            if term == identity:  =>           \r\n                base *= i         =>           \r\n            elif term == square:  =>           \r\n                base *= square(i) =>           \r\n            if term == identity:  =>           \r\n                base += i         =>           \r\n            elif term == square:  =>           \r\n                base += square(i) =>           \r\n            base *= i             <=           \r\n            base += i             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            base *= i\n        elif combiner == add:\n            base += i\n    return base\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            if term == identity:\n                base *= i\n            elif term == square:\n                base *= square(i)\n        elif combiner == add:\n            if term == identity:\n                base += i\n            elif term == square:\n                base += square(i)\n    return base\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":286,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        answer = combiner(answer,term(i)) =>           \r\n        answer = combiner(answer,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(n))\n    return answer\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(i))\n    return answer\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for n in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":287,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==1:                  <=           \r\n        return term(n) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n==1:\n        return term(n) + base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":288,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))  =>           \r\n    return accumulate(add, 1, n, term)                                  =>           \r\n        return combiner(n, term)                                        <=           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n    return _______                                                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(n, term)\n    else:\n        return accumulate(combiner, base, n-1, term) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(n, term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":289,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                   SideIndicator\r\n-----------                                                                   -------------\r\ndef accumulate(combiner, base, n, term):###############                       =>           \r\n    total, i = base, 1                                                        =>           \r\n    while i <= n:                                                             =>           \r\n        total, i = combiner(total, term(i)) , i+1                             =>           \r\n    return total                                                              =>           \r\ndef summation_using_accumulate(n, term):##############                        =>           \r\ndef filtered_accumulate(combiner, base, pred, n, term):###################### =>           \r\ndef accumulate(combiner, base, n, term):                                      <=           \r\n    ret = 1                                                                   <=           \r\n    for i in range(1, n + 1, 1):                                              <=           \r\n        ret = combiner(ret, term(i))                                          <=           \r\n    return ret                                                                <=           \r\ndef summation_using_accumulate(n, term):                                      <=           \r\ndef filtered_accumulate(combiner, base, pred, n, term):                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    ret = 1\n    for i in range(1, n + 1, 1):\n        ret = combiner(ret, term(i))\n    return ret\n\n","after":"def accumulate(combiner, base, n, term):###############\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)) , i+1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    ret = base\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":290,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        drake = combiner(drake,term(x)) =>           \r\n        drake = term(drake,x)           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    drake = base\n    for x in range(1,n+1):\n        drake = term(drake,x)\n    return drake\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    drake = base\n    for x in range(1,n+1):\n        drake = combiner(drake,term(x))\n    return drake\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    drake = term(drake,x)","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":291,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term)) =>           \r\n        return combiner(n, accumulate(combiner, base, (n-1), term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, (n-1), term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":292,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(n)) =>           \r\n    return base                        =>           \r\n        num = combiner(base, term(n))  <=           \r\n    return num                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        num = combiner(base, term(n))\n        n -= 1\n    return num\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        base = combiner(base, term(n))\r\n        n -= 1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":293,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n            total = total + term(c) =>           \r\n        total = total + base        =>           \r\n            combiner(total,term(c)) <=           \r\n        combiner(total,base)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            combiner(total,term(c))\n            c = c + 1\n        combiner(total,base)\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            total = total + term(c)\n            c = c + 1\n        total = total + base\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":294,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 1       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total, k = 1","TypeError: 'int' object is not iterable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":295,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n                                                                    =>           \r\n        return base                                                 =>           \r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    result = combiner(base,term(n))                                 <=           \r\n        return result                                               <=           \r\n        return combiner(result,accumulate(combiner,base,n-1,term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base,term(n))\n    \n    if n==0:\n    \treturn result\n\n    else:\n    \treturn combiner(result,accumulate(combiner,base,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    \n    if n==0:\n    \treturn base\n\n    else:\n    \treturn combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","81","","# Error: expected","#     26","# but got","#     81","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":296,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n==0:                                                           =>           \r\n        return base                                                    =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                              =>           \r\n    def accumulateHelp(count):                                         <=           \r\n        if count==n+1:                                                 <=           \r\n            return base                                                <=           \r\n        return combiner(term(count), accumulateHelp(count+1))          <=           \r\n    return accumulateHelp(0)                                           <=           \r\n                                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count), accumulateHelp(count+1))\n\n    return accumulateHelp(0)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":297,"studentId":0,"date":null,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        if n == 0:                                          =>           \r\n            return 0                                        =>           \r\n    return combiner(term_combiner(combiner, 1, term), base) =>           \r\n    return combiner(term_combiner(combiner, 0, term), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 0, term), base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if n == 0:\n            return 0\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 1, term), base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":298,"studentId":0,"date":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n<2:  =>           \r\n    if n==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":299,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n    else:                                                                 =>           \r\n                                                                          =>           \r\n    def accumulator(x, total):                                            <=           \r\n        if x > n:                                                         <=           \r\n            return total                                                  <=           \r\n        else:                                                             <=           \r\n            return accumulator(x + 1, combiner(total, term(x)))           <=           \r\n    return accumulator(2, combiner(base, term(1)))                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulator(x, total):\n        if x > n:\n            return total\n        else:\n            return accumulator(x + 1, combiner(total, term(x)))\n    return accumulator(2, combiner(base, term(1)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    if n==0:\r\n        return base\r\n    return accumulator(2, combiner(base, term(1)))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":300,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        total = base       =>           \r\n        total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = term(base)\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = base\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = base\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","144","","# Error: expected","#     72","# but got","#     144","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":301,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k < n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n+1:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":302,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    if combiner == add:          =>           \r\n        return base + helper(1)  =>           \r\n        return base * helper(1)  =>           \r\n    else:                        =>           \r\n    return base * helper(1)      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    return base * helper(1) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    if combiner == add:\n        return base + helper(1)\n    else:\n        return base * helper(1) \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":303,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    i = 1                                    =>           \r\n    while i <= n:                            =>           \r\n        total = combiner(total,  term(i))    =>           \r\n        i += 1                               =>           \r\n    while base <= n:                         <=           \r\n        total = combiner(total,  term(base)) <=           \r\n        base += 1                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while base <= n:\n        total = combiner(total,  term(base))\n        base += 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total,  term(i))\n        i += 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":304,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n==0:      =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        \n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    elif n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":305,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(term(n)), accumulate(combiner, base, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n)), accumulate(combiner, base, n-1, term)\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n)), accumulate(combiner, base, n-1, term)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":306,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    total = base  =>           \r\n    total = start <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = start\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":307,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 1:                                                           =>           \r\n        return product(n-1, term) * term(n)                              =>           \r\n    return product(n, identity)                                          =>           \r\n        return base                                                      =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    return accumulate(mul, 1, n, term)                                   =>           \r\n    return accumulate(combiner, base, n, term)                           =>           \r\n    def z(x):                                                            =>           \r\n        return compose1(f,f)(x)                                          =>           \r\n    if n == 0:                                                           =>           \r\n        return z(n)                                                      =>           \r\n    return z(n-1) + z(n)                                                 =>           \r\n    else:                                                                =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n    return _______                                                       <=           \r\n        return combiner(accumulate(combiner, base, n-1, term))           <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":308,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    i=1                             =>           \r\n    y=base                          =>           \r\n    while i<=n:                     =>           \r\n        y = combiner(y, term(i))    =>           \r\n        i+=1                        =>           \r\n    return y                        =>           \r\n    while base>=0 and n>=0:         <=           \r\n        x = combiner(base, term(n)) <=           \r\n        base = term(n-1)            <=           \r\n        n-=2                        <=           \r\n    return x                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while base>=0 and n>=0:\n        x = combiner(base, term(n))\n        base = term(n-1)\n        n-=2\n    return x\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    y=base\n    while i<=n:\n        y = combiner(y, term(i))\n        i+=1\n    return y\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","3","","# Error: expected","#     15","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":309,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, helper(combiner, n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":310,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":311,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n\n    return combine(accumulate(combiner, base, n-1, term), term(n))\n    \n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n    \n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":312,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result=base     =>           \r\n    result=combiner <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=combiner\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    result=combiner(result, term(i))","TypeError: unsupported operand type(s) for +: 'builtin_function_or_method' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":313,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        total = combiner(total,term(n)) =>           \r\n        total = combiner(total,n)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,n)\n        n = n-1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,term(n))\n        n = n-1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":314,"studentId":0,"date":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            result = combiner(result, term(x))  =>           \r\n            result += combiner(result, term(x)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result += combiner(result, term(x))\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result = combiner(result, term(x))\n    return result\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result = combiner(result, term(x))\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":315,"studentId":0,"date":null,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        if(i == n):                               =>           \r\n    if(n == 0):                                   =>           \r\n        return base                               =>           \r\n        return combiner(base, take_term(1, term)) =>           \r\n    else:                                         =>           \r\n        if(i == 0):                               <=           \r\n            return 0                              <=           \r\n        elif(i == n):                             <=           \r\n    return combiner(base, take_term(1, term))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == 0):\n            return 0\n        elif(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    return combiner(base, take_term(1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    if(n == 0):\n        return base\n    else:\n        return combiner(base, take_term(1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (n==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in take_term","    if(i == 0):","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":316,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return base                          =>           \r\n        while n >= 1:                        =>           \r\n            total = combiner(total, term(n)) =>           \r\n    if n == 0:                               =>           \r\n            n -= 1                           =>           \r\n    else:                                    =>           \r\n    while n >= 0:                            <=           \r\n        total = combiner(total, term(n))     <=           \r\n        n -= 1                               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    while n >= 0:\n        total = combiner(total, term(n))\n        n -= 1\n\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    if n == 0:\n        return base\n    else:\n        while n >= 1:\n            total = combiner(total, term(n))\n            n -= 1\n\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":317,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n            result = combiner(result, combiner(term(i), term(i + 1))) =>           \r\n            i += 2                                                    =>           \r\n            result = combiner(term(result), term(i))                  <=           \r\n            i += 1                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    result = base\n    while i <= n:\n        if i == 1:\n            result = combiner(result, term(i))\n            i += 1\n        else:\n            result = combiner(term(result), term(i))\n            i += 1\n    return result\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    result = base\n    while i <= n:\n        if i == 1:\n            result = combiner(result, term(i))\n            i += 1\n        else:\n            result = combiner(result, combiner(term(i), term(i + 1)))\n            i += 2\n    return result\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i>=1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21913","","# Error: expected","#     25","# but got","#     21913","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":318,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return total         =>           \r\n            return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n            total, k = combiner(total, term(k)), k + 1\n            return total\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n            total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":319,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        elif n == 0: =>           \r\n            return 0 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return 0\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in terms","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":320,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    k = base                                                        =>           \r\n    for i in range (1, n + 1):                                      =>           \r\n        k = combiner(k, term(i))                                    =>           \r\n    return k                                                        =>           \r\n    if n == base:                                                   <=           \r\n        return term(base)                                           <=           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == base:\n        return term(base)\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    for i in range (1, n + 1):\n        k = combiner(k, term(i))\n    return k\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == base:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":321,"studentId":0,"date":null,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    acc, i = base, 1                           =>           \r\n        acc, i = combiner(acc, term(i)), i + 1 =>           \r\n    acc, i = base, 0                           <=           \r\n        acc, i = combiner(acc,term(i)), i + 1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 0\n    while i <= n:\n        acc, i = combiner(acc,term(i)), i + 1\n    return acc\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 1\n    while i <= n:\n        acc, i = combiner(acc, term(i)), i + 1\n    return acc\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 1\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":322,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner,base,(n-1),term)) =>           \r\n        sum(term(n), accumulate(combiner,base,(n-1),term))             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        sum(term(n), accumulate(combiner,base,(n-1),term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,(n-1),term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","TypeError: 'int' object is not iterable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":323,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combiner( accumulate(combiner, base, n-1, term, term(n))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term, term(n)))\n\n","after":"def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"any\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":324,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                                 SideIndicator\r\n-----------                                                                                                 -------------\r\n        return combiner(base, (combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term)))) =>           \r\n    return accumulate(combiner, base, n, lambda x: term(x) if pred(n) else 0 if combiner == add else 1)     =>           \r\n        return combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))                   <=           \r\n    return accumulate(combiner, base, n, lambda x: term if pred(n) else 0 if combiner == add else 1)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, (combiner(term(n), accumulate(combiner, abs(combiner(-1, 1)), n - 1, term))))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":325,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":326,"studentId":0,"date":null,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    if n == 1:                                                       =>           \r\n        return combiner(base, term(n))                               =>           \r\n    elif n == 0:                                                     =>           \r\n        return base                                                  =>           \r\n        return combiner(term(n), accumulate(combiner,base,n-1,term)) =>           \r\n    def helper(x):                                                   =>           \r\n        return compose1(f,f)                                         =>           \r\n    return helper(x)                                                 =>           \r\n    else:                                                            =>           \r\n    if n == 0:                                                       <=           \r\n        return term(base)                                            <=           \r\n    return combiner(term(n), accumulate(combiner,base,n-1,term))     <=           \r\n                                                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":327,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if (n == 0):           =>           \r\n    if (n == 0 or n == 1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0 or n == 1):\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0):\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or base==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":328,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, base\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":329,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return combiner(base, term(0))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":330,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x <= n:\n        Total = combiner(Total, term(x))\n        x += 1\n    return Total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x < n:\n        x += 1\n        Total = combiner(Total, term(x))\n    return Total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":331,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if n == 0:\n            return base\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_helper","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":332,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, i)\n        i += 1\n    return total\n        \n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n        \n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":333,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while  i < n:  =>           \r\n    while  i <= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    first_number = base\n    i = 0\n    while  i <= n:\n        i = i+ 1\n        first_number = combiner(term(i),first_number)\n    return first_number\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    first_number = base\n    i = 0\n    while  i < n:\n        i = i+ 1\n        first_number = combiner(term(i),first_number)\n    return first_number\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i+1<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":334,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    x = 1   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    x = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    i = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    i = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    while i<=n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":335,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))    =>           \r\n                                                                       =>           \r\n    '''if n==0:                                                        <=           \r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))''' <=           \r\n        return base                                                    <=           \r\n    total, next_term = base, 1                                         <=           \r\n    while n>0:                                                         <=           \r\n        total = total + term(next_term)                                <=           \r\n        next_term +=1                                                  <=           \r\n        n-=1                                                           <=           \r\n    return total                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    '''if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))'''\n\n    if n==0:\n        return base\n    total, next_term = base, 1\n    while n>0:\n        total = total + term(next_term)\n        next_term +=1\n        n-=1\n    return total \n    \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    \n    \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":336,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n        return base                                                                         =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))                         =>           \r\n    def cmb(x, y):                                                                          =>           \r\n        if pred(y):                                                                         =>           \r\n            return combiner(x,y)                                                            =>           \r\n        else:                                                                               =>           \r\n            return x                                                                        =>           \r\n    return accumulate(cmb, base, n, term)                                                   =>           \r\n                                                                                            =>           \r\n        return term(n)                                                                      <=           \r\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))                     <=           \r\n    return accumulate(lambda x,y: combiner(x,y) if pred(y) == True else x, base, n, term)   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":337,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":338,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return helper(1, base)       =>           \r\n    return helper(1, term(base)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, term(base))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":339,"studentId":0,"date":null,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    for i in range(1, n+1):                    =>           \r\n    return accumulate(add, base, n, term)      =>           \r\n    return accumulate(mul,1, n, term)          =>           \r\n    for i in range(0, n+1):                    <=           \r\n        #return accumulate(add, base, n, term) <=           \r\n        #return accumulate(mul,1, n, term)     <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(0, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":340,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n < 1:       =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":341,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return combiner(base, helper())       =>           \r\n    return combiner(term(base), helper()) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(term(base), helper())\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(base, helper())\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":342,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return combiner (accumulate(combiner, base, n-1, term),term(n)) =>           \r\n    if base < n:                                                        <=           \r\n        return term(base) + accumulate(combiner, base+1, n, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base < n:\n        return term(base) + accumulate(combiner, base+1, n, term)\n    else:\n        return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner (accumulate(combiner, base, n-1, term),term(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":343,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":344,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":345,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n                                                                    =>           \r\n        return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n        \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":346,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)  =>           \r\n        return accumulate(combiner, combiner(base, term(n), n-1, term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n), n-1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return accumulate(combiner, combiner(base, term(n), n-1, term))","TypeError: op_add expected 2 arguments, got 4","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":347,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    def helper(n, term):                                                  <=           \r\n        if n > 0:                                                         <=           \r\n            return combiner(n, helper(n - 1, term))                       <=           \r\n        return combiner(base, combiner(term(n), helper(n - 1, term)))     <=           \r\n                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n > 0:\n            return combiner(n, helper(n - 1, term))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), helper(n - 1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), helper(n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":348,"studentId":0,"date":null,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        base = combiner(term(n),base)       =>           \r\n        base = base + combiner(term(n),n-1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = base + combiner(term(n),n-1)\n        return accumulate(combiner,base,n-1,term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":349,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":350,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 0:      =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":351,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return acc_help(combiner, total, k, term, y) =>           \r\n        return acc_help(combiner, total, k, term)    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term)\n    return acc_help(combiner, base, 1, term, 1)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term, y)\n    return acc_help(combiner, base, 1, term, 1)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return acc_help(combiner, base, 1, term, 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in acc_help","    return acc_help(combiner, total, k, term)","TypeError: acc_help() missing 1 required positional argument: 'y'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":352,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return term(n) + base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":353,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return total                 =>           \r\n    return combiner(base, total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return combiner(base, total)\n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return total \n        \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","37","","# Error: expected","#     26","# but got","#     37","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":354,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term)) =>           \r\n        return combiner(base, accumulation_counter(combiner, 0, n, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 0, n, term))\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 1, n, term))\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":355,"studentId":0,"date":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==0: =>           \r\n    if n==1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":356,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return n                                                    <=           \r\n    return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return n\n    return combiner(base, term(n-1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":357,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n == 0 :                                                        =>           \r\n        return base                                                    =>           \r\n    else:                                                              =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1, term)) =>           \r\n    number = 0                                                         <=           \r\n    while number < n:                                                  <=           \r\n        total = combiner(base, term(number))                           <=           \r\n        number + 1                                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    number = 0 \n    while number < n:\n        total = combiner(base, term(number)) \n        number + 1\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 :\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n-1, term))\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":358,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total    =>           \r\n    return combiner <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return combiner\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        base = combiner(base, term(x))\r\n        x = x+1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","<built-in function add>","","# Error: expected","#     15","# but got","#     <built-in function add>","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":359,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n):\n        if n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper(n-1))\n    return combiner(base, helper(n))\n\t\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n):\n        if n <= 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper(n-1))\n    return combiner(base, helper(n))\n\t\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":360,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n - 1, term))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(base, n - 1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":361,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total += term(i)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total += term(i)\n        i += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":362,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n ==0:                          =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==0:\n        return combiner(base, term(0))\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":363,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        result = combiner(result,term(k)) =>           \r\n        result = combine(result,term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combine(result,term(k))\n        k += 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combiner(result,term(k))\n        k += 1\n    return result\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = combine(result,term(k))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":364,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n        return combiner(accumulate(combiner, base, n-1, term) + term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term) + term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":365,"studentId":0,"date":null,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    i = 1                                   =>           \r\n    while i <= n:                           =>           \r\n        total = combiner(total, term(i))    =>           \r\n        i +=1                               =>           \r\n    return combiner(total, base)            =>           \r\n    while base <= n:                        <=           \r\n        total = combiner(total, term(base)) <=           \r\n        base +=1                            <=           \r\n    return total                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    while base <= n:\n        total = combiner(total, term(base))\n        base +=1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i +=1\n    return combiner(total, base)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":366,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n    if term(n) == base:                                                 <=           \r\n    else:                                                               <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n) == base:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if term(n) == base:","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":367,"studentId":0,"date":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 0:                                                           =>           \r\n        return base                                                      =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1,term))    =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    if base == n:                                                        <=           \r\n        return term(base)                                                <=           \r\n        return combiner(term(base), accumulate(combiner,base+1, n,term)) <=           \r\n    return _______                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if base == n:\n        return term(base)\n    else: \n        return combiner(term(base), accumulate(combiner,base+1, n,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner,base, n-1,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if base == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":368,"studentId":0,"date":null,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    return partial_accum(1,base)   =>           \r\n    return partial_product(1,base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_product(1,base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_accum(1,base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    return partial_product(1,base)","NameError: name 'partial_product' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":369,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        return base                     =>           \r\n                                        =>           \r\n        total = combiner(term(n), base) <=           \r\n        return total                    <=           \r\n    return total                        <=           \r\n    total = 0                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n == 0:\n        return base\n    base = combiner(term(n), base)\n\n    return accumulate(combiner,base,n-1,term)\"\"\"\n    total = 0\n    count = 1\n\n    while n > 0:\n        total = combiner(term(n), base)\n        n -= 1\n    if n == 0:\n        return total\n    return total\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n == 0:\n        return base\n    base = combiner(term(n), base)\n\n    return accumulate(combiner,base,n-1,term)\"\"\"\n    count = 1\n\n    while n > 0:\n        base = combiner(term(n), base)\n        n -= 1\n    if n == 0:\n        return base\n    \n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return base\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":370,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(base, term(n-1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":371,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    total=base                        =>           \r\n        total=combiner(term(n),total) =>           \r\n        total=combiner(term(n),base)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":372,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    a = 1                                =>           \r\n    total = base                         =>           \r\n    while a <= n:                        =>           \r\n        total = combiner(total, term(a)) =>           \r\n        a += 1                           =>           \r\n    return total                         =>           \r\n    def summation(term, n):              <=           \r\n        a, total = n, 0                  <=           \r\n        while a > 0:                     <=           \r\n            total += term(a)             <=           \r\n            a -= 1                       <=           \r\n        return total                     <=           \r\n    return combiner(base, term(n))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(term, n):\n        a, total = n, 0\n        while a > 0:\n            total += term(a)\n            a -= 1\n        return total\n    return combiner(base, term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    total = base\n    while a <= n:\n        total = combiner(total, term(a))\n        a += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":373,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while n<=k: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while n<=k:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":374,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":375,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                            SideIndicator\r\n-----------                                                                            -------------\r\n    def accumulate_fuzzies(combiner, base, n, term):                                   =>           \r\n        if n == 0:                                                                     =>           \r\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))    =>           \r\n    return accumulate_fuzzies(combiner, base, n, term)                                 =>           \r\n    def accumulate_fuzzies(combiner, base, n, term, k):                                <=           \r\n        if k == n:                                                                     <=           \r\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1)) <=           \r\n    return accumulate_fuzzies(combiner, base, n, term, n)                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term, k):\n        if k == n:\n            return base\n        else:\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1))\n    return accumulate_fuzzies(combiner, base, n, term, n)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))\n    return accumulate_fuzzies(combiner, base, n, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":376,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        accumulate(combiner, base, n-1, term)                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        accumulate(combiner, base, n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":377,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return combiner(base, total) =>           \r\n    return base + total          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return base + total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(base, total)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(base, total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":378,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total, k = base, 1                             =>           \r\n    while k <= n:                                  =>           \r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n    return total                                   =>           \r\n    result, k = base, 1                            <=           \r\n    while k<=n:                                    <=           \r\n        k+=1                                       <=           \r\n        result = combiner(term(k), result)         <=           \r\n    return result                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, k = base, 1\n    while k<=n:\n        k+=1\n        result = combiner(term(k), result)\n    return result\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":379,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n    base = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    counter = 1\n    base = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":380,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = combiner (total, k) =>           \r\n        total = combiner (base, k)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (base, k)\n        counter = counter + 1\n    return total \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (total, k)\n        counter = counter + 1\n    return total \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(total, k)\r\n        counter = counter+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":381,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    i = 1                                                                   =>           \r\n    total = base                                                            =>           \r\n    while i <= n:                                                           =>           \r\n        total = combiner(total, term(i))                                    =>           \r\n        i += 1                                                              =>           \r\n    return total                                                            =>           \r\n    if n == 0:                                                              <=           \r\n        return base                                                         <=           \r\n    elif n == 1:                                                            <=           \r\n        return combiner(base, term(n))                                      <=           \r\n    else:                                                                   <=           \r\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":382,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        if n == 0:       =>           \r\n            return total =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n == 0:\n            return total\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(n), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":383,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        total = base                         =>           \r\n            total = combiner(total, term(i)) =>           \r\n        return total                         =>           \r\n        total = term(0)                      <=           \r\n            total = combiner(term(i), total) <=           \r\n        return base + total                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = term(0)\n        while i <= n:\n            total = combiner(term(i), total)\n            i = i+1\n        return base + total\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = base\n        while i <= n:\n            total = combiner(total, term(i))\n            i = i+1\n        return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":384,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n==0:                          =>           \r\n        return base                   =>           \r\n        ans=combiner(base,term(1))    =>           \r\n        i=2                           =>           \r\n        while i<=n:                   =>           \r\n            ans=combiner(ans,term(i)) =>           \r\n            i+=1                      =>           \r\n        return ans                    =>           \r\n    else:                             =>           \r\n    ans=combiner(base,term(1))        <=           \r\n    i=2                               <=           \r\n    while i<=n:                       <=           \r\n        ans=combiner(ans,term(i))     <=           \r\n        i+=1                          <=           \r\n    return ans                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        ans=combiner(base,term(1))\n        i=2\n        while i<=n:\n            ans=combiner(ans,term(i))\n            i+=1\n        return ans\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":385,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n, term))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n < 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":386,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    elif n == 1:                                                          =>           \r\n        return combiner(base, term(1))                                    =>           \r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term))) =>           \r\n    else:                                                                 =>           \r\n    else:                                                                 <=           \r\n        return accumulate(combiner(base, term(n + 1)), n, term) + base    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return accumulate(combiner(base, term(n + 1)), n, term) + base\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner(base, term(n + 1)), n, term) + base","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":387,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        a=combiner(a,term(i+1)) =>           \r\n        combiner(a,term(i+1))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        a=combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":388,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    term_total = term(1) =>           \r\n    term_total = term(i) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(i)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(1)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(1)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    term_total = term(i)","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":389,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), base)                                  =>           \r\n    elif n == 1:                                                        =>           \r\n        return combiner(term(n), base)                                  =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n        return n                                                        <=           \r\n    return combiner((term(n-1)), term(n)) * n-1                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return n\n    return combiner((term(n-1)), term(n)) * n-1\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return combiner(term(n), base)\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","44","","# Error: expected","#     15","# but got","#     44","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":390,"studentId":0,"date":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n                                          =>           \r\n        total = combiner(total,term(x))   =>           \r\n                                          =>           \r\n        total = combiner((total,term(x))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    x = 1\n    while x <= n:\n        total = combiner((total,term(x)))\n        x = x + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total,term(x))\n        x = x + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    total = combiner((total,term(x)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":391,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                              SideIndicator\r\n-----------                                                                              -------------\r\n    return base if n == 0 else combiner(term(n), accumulate(combiner, base, n -1, term)) =>           \r\n    return base if n == 0 else combiner(n, accumulate(combiner, base, n -1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     return combiner(n, accumulate(combiner))\n    return base if n == 0 else combiner(n, accumulate(combiner, base, n -1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0:\n    #     return base\n    # else:\n    #     return combiner(n, accumulate(combiner))\n    return base if n == 0 else combiner(term(n), accumulate(combiner, base, n -1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":392,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":393,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(n)) =>           \r\n        combiner(total, term(n))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \tcombiner(total, term(n))\n    \tn -= 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \ttotal = combiner(total, term(n))\n    \tn -= 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":394,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                           SideIndicator\r\n-----------                                                                           -------------\r\n        return combiner(base, reduce(combiner, map(term, [x for x in range(1,n+1)]))) =>           \r\n        return combiner(base, reduce(combiner, map(term, [x for x in range(n+1)])))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, reduce(combiner, map(term, [x for x in range(n+1)])))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, reduce(combiner, map(term, [x for x in range(1,n+1)])))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":395,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    if n == 0:    =>           \r\n    if n == base: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == base:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == base:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":396,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range (1,n+1): =>           \r\n    while x != n:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while x != n:\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range (1,n+1):\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    while x != n:","NameError: name 'x' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":397,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":398,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n > 1:                                                             =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    if n > 2:                                                             <=           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 2:\n        return combiner(term(n), term(n - 1))\n    else:\n        return combiner(term(n), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return combiner(term(n), base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":399,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        result = combiner(result, term(k)) =>           \r\n        result = combiner(result, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(n))\n        k += 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(k))\n        k += 1\n    return result\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":400,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        print(i) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        print(i)\n        if i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(i+1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(helper(1), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        if i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(i+1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(helper(1), base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","2","3","4","5","15","","# Error: expected","#     15","# but got","#     1","#     2","#     3","#     4","#     5","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":401,"studentId":0,"date":null,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return combiner(term(k), helper_accumulate(k+1, term)) =>           \r\n            return combiner(term(k), helper_accumulate(k+1), term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1), term)\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1, term))\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return helper_accumulate(1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in helper_accumulate","    return combiner(term(k), helper_accumulate(k+1), term)","TypeError: helper_accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":402,"studentId":0,"date":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n> 1: =>           \r\n    if n> 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 0:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 1:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>1:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":403,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    next_term= accumulate(combiner,term(n), n-1, term)                          =>           \r\n    return combiner(base, next_term)                                            =>           \r\n    if n<=0:                                                                    =>           \r\n    if n<1:                                                                     <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<1:\n        return base\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<=0:\n        return base\n    next_term= accumulate(combiner,term(n), n-1, term)\n    return combiner(base, next_term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":404,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return accumulate_combiner(base, n)       =>           \r\n    return accumulate_combiner(term(base), n) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(term(base), n)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(base, n)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(base, n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":405,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, 1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return combiner(base, 1)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return base\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":406,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if term(n)==0:    =>           \r\n    if term(base)==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(base)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":407,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                      SideIndicator\r\n-----------                                                                      -------------\r\n    \"\"\"Return the result of combining the first N terms in a sequence.  The      =>           \r\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a      =>           \r\n    two-argument function.  Treating COMBINER as if it were a binary operator,   =>           \r\n    the return value is                                                          =>           \r\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)              =>           \r\n#     \"\"\"Return the result of combining the first N terms in a sequence.  The    <=           \r\n#     terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a    <=           \r\n#     two-argument function.  Treating COMBINER as if it were a binary operator, <=           \r\n#     the return value is                                                        <=           \r\n#         BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n\n#     \"\"\"Return the result of combining the first N terms in a sequence.  The\n#     terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n#     two-argument function.  Treating COMBINER as if it were a binary operator,\n#     the return value is\n#         BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n#     >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n#     15\n#     >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n#     26\n#     >>> accumulate(add, 11, 0, identity) # 11\n#     11\n#     >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n#     25\n#     >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n#     72\n#     \"\"\"\n    if n == 0:\n        return base\n    elif True:\n        accumulating = combiner(term(n), base)\n        return accumulate(combiner, accumulating, n-1, term)        \n    else:\n        return accumulate(combiner, accumulating, n-1, term)  \n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n#     >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n#     15\n#     >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n#     26\n#     >>> accumulate(add, 11, 0, identity) # 11\n#     11\n#     >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n#     25\n#     >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n#     72\n#     \"\"\"\n    if n == 0:\n        return base\n    elif True:\n        accumulating = combiner(term(n), base)\n        return accumulate(combiner, accumulating, n-1, term)        \n    else:\n        return accumulate(combiner, accumulating, n-1, term)  \n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(a, accumulating, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-a)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","","-- No doctests found for accumulate --","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":408,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    total = 0                                                       <=           \r\n    while n>0:                                                      <=           \r\n        total = combiner(term(n), term(n-1))                        <=           \r\n        n-=1                                                        <=           \r\n    total = combiner(total, term(base))                             <=           \r\n    return total                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    while n>0:\n        total = combiner(term(n), term(n-1))\n        n-=1\n    total = combiner(total, term(base))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":409,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return combiner(term(n), helper(n-1, term))  =>           \r\n    return combiner(base,helper(n,term))             =>           \r\n        return combiner(n, helper(n-1,term))         <=           \r\n    return combiner(base,helper)                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(n, helper(n-1,term))\n    return combiner(base,helper)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(term(n), helper(n-1, term)) \n    return combiner(base,helper(n,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base,helper)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":410,"studentId":0,"date":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        total = combiner(total, term(counter))  =>           \r\n        total = combiner(total, counter)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, counter)  \n        counter = counter + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter)) \n        counter = counter + 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter = counter+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":411,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                        SideIndicator\r\n-----------                                                                        -------------\r\n    if n == 0:                                                                     =>           \r\n        return base                                                                =>           \r\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))              =>           \r\n    if n == 1:                                                                     <=           \r\n        return 1                                                                   <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return 1\n\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":412,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i = 1  =>           \r\n        i += 1 =>           \r\n        i = 2  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        total = combiner(base, term(i))\n        i = 2\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        i = 1\n        total = combiner(base, term(i))\n        i += 1\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(1))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = combiner(base, term(i))","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":413,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        if n > index:                                                           =>           \r\n            return helper(combiner, base, n, term, counter, index, total)       =>           \r\n        return combiner(total, term(n))                                         =>           \r\n        if n > counter or n > index:                                            <=           \r\n            return total*helper(combiner, base, n, term, counter, index, total) <=           \r\n        return total                                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    index = 2\n    total = combiner(base, term(1))\n    def helper(combiner, base, n, term, counter, index, total):\n        if n == 0: \n            return base\n        if n == 1:\n            return total\n        if n > counter or n > index:\n            total = combiner(total, term(index))\n            counter += 1\n            index += 1\n            return total*helper(combiner, base, n, term, counter, index, total)\n        return total\n    return helper(combiner, base, n, term, counter, index, total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    index = 2\n    total = combiner(base, term(1))\n    def helper(combiner, base, n, term, counter, index, total):\n        if n == 0: \n            return base\n        if n == 1:\n            return total\n        if n > index:\n            total = combiner(total, term(index))\n            counter += 1\n            index += 1\n            return helper(combiner, base, n, term, counter, index, total)\n        return combiner(total, term(n))\n    return helper(combiner, base, n, term, counter, index, total)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return 1*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","40500","","# Error: expected","#     15","# but got","#     40500","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":414,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n                k = k + 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n                k = k + 1\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     72","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":415,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    elif combiner== mul:                                                          =>           \r\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    elif combiner== mul:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":416,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        while counter>1: =>           \r\n        while counter>0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>0:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>1:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>1:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":417,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        start = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":418,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, i)\n        i += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":419,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 2 =>           \r\n            return 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner == add and term == identity:\n        if n == 0:\n            return base\n        else:\n            return n + accumulate(add, base, n-1, identity)\n    elif combiner == add and term == square:\n        if n == 0:\n            return base\n        else:\n            return n**2 + accumulate(add, base, n-1, square)\n    elif combiner == mul and term == identity:\n        if n == 0:\n            return 0\n        else:\n            return n * accumulate(mul, base, n-1, identity)\n    elif combiner == mul and term == square:\n        if n == 0:\n            return 1\n        else:\n            return combiner(n**2, accumulate(mul, base, n-1, square))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner == add and term == identity:\n        if n == 0:\n            return base\n        else:\n            return n + accumulate(add, base, n-1, identity)\n    elif combiner == add and term == square:\n        if n == 0:\n            return base\n        else:\n            return n**2 + accumulate(add, base, n-1, square)\n    elif combiner == mul and term == identity:\n        if n == 0:\n            return 0\n        else:\n            return n * accumulate(mul, base, n-1, identity)\n    elif combiner == mul and term == square:\n        if n == 0:\n            return 2\n        else:\n            return combiner(n**2, accumulate(mul, base, n-1, square))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","36","","# Error: expected","#     72","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":420,"studentId":0,"date":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    return combiner(times(n, 1 - combiner(1, 0)), base) =>           \r\n    return times(n, 1 - combiner(1, 0)) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return times(n, 1 - combiner(1, 0)) + base\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return combiner(times(n, 1 - combiner(1, 0)), base)\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":421,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n                                         =>           \r\n        total += term(i)                 <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total += term(i)\n        i += 1\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":422,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(n-1))                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(n-1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":423,"studentId":0,"date":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            total = combiner(total,term(next))  =>           \r\n            total += combiner(total,term(next)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total += combiner(total,term(next))\n            next+=1\n        return total\n\n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total = combiner(total,term(next))\n            next+=1\n        return total\n\n        \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total = combiner(total, term(next))\r\n            next += 1\r\n        return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":424,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    return Total  =>           \r\n    return Total  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        counter += 1\n        Total = combiner(Total, term(counter))\n    return Total \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        Total = combiner(Total, term(counter))\n        counter += 1\n    return Total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":425,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    while i<=n:                   =>           \r\n    return start                  =>           \r\n    return accumulate(add, start) =>           \r\n    while i<n:                    <=           \r\n    return combiner               <=           \r\n    return _______                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<n:\n        start= combiner(start, term(i))\n        i +=1\n    return combiner\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<=n:\n        start= combiner(start, term(i))\n        i +=1\n    return start\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","<built-in function add>","","# Error: expected","#     15","# but got","#     <built-in function add>","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":426,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                      SideIndicator\r\n-----------                                                                                      -------------\r\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))           =>           \r\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return awkward_accumulate(combiner, base, 1, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in awkward_accumulate","    return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":427,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    15                                 =>           \r\n    15_________                        <=           \r\n    elif n == 1:                       <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15_________ \n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     15_________","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":428,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        while i < n+1: =>           \r\n        while i < n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n+1:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n+1:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":429,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        total = combiner(total,term(k))    =>           \r\n    return accumulate(mul, 1, n, term)     =>           \r\n                                           =>           \r\n        total = combiner(total,term)       <=           \r\n    return accumulate(product, 1, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term)\n        k+=1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term(k))\n        k+=1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total = combiner(total,term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":430,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n        return total\n        \n\n        \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n    return total\n        \n\n        \n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":431,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":432,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":433,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return base                    =>           \r\n    if n == 1:                         =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 0, n, term) =>           \r\n    if n <= 1:                         <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":434,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n                      =>           \r\n    while count < n:  <=           \r\n                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count < n:\n        answer = combiner(answer, term(count) )\n        count +=1\n        \n    return answer\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count <= n:\n        answer = combiner(answer, term(count) )\n        count +=1\n\n    return answer\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n+1:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":435,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        while i >= 1: =>           \r\n        while i > 1:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i > 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i >= 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>=1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":436,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        s = combiner(s, term(i))  =>           \r\n        s += combiner(s, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s += combiner(s, term(i))\n    return s\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s = combiner(s, term(i))\n    return s\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s = combiner(s, term(i))\r\n    return s","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":437,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if combiner == mul:     =>           \r\n    while i <= n:           =>           \r\n    while i <= n:           <=           \r\n        if combiner == mul: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    while i <= n:\n        if combiner == mul:\n            total = 1\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    if combiner == mul:\n            total = 1\n    while i <= n:    \n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":438,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if base > 0: =>           \r\n    if base > n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > n:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > 0:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":439,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), combiner(n-1, term))                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), combiner(n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), combiner(n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":440,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 2:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term))\n\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 2:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-0), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":441,"studentId":0,"date":null,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        return base                                      =>           \r\n        base = combiner(term(n), base)                   =>           \r\n        return accumulate(combiner, base, n-1, term)     =>           \r\n        return acc                                       <=           \r\n        next_acc = combiner(term(n), acc)                <=           \r\n        return accumulate(combiner, next_acc, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return acc\n    else:\n        next_acc = combiner(term(n), acc)\n        return accumulate(combiner, next_acc, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    next_acc = combiner(term(n), acc)","NameError: name 'acc' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":442,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    q=term(1)               =>           \r\n    for i in range(2, n+1): =>           \r\n    q=0                     <=           \r\n    for i in range(1, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=0\n    for i in range(1, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=term(1)\n    for i in range(2, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = base\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return q","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":443,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    else:                                                           =>           \r\n                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    \n        \n    \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n        \n    \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":444,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), term(n - 1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":445,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return combiner(combiner_helper(n), base) =>           \r\n    return combiner_helper(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner_helper(n) + base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner(combiner_helper(n), base)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner(combiner_helper(n), base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":446,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n                                                                        =>           \r\n    if n ==0:                                                           =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n    total=0                                                             <=           \r\n    base>=0                                                             <=           \r\n    k=n                                                                 <=           \r\n    combiner=(term(n)+term(n-1))                                        <=           \r\n    while k>=0:                                                         <=           \r\n        total+=accumulate (combiner, base, k, term)                     <=           \r\n        k-=1                                                            <=           \r\n    return total                                                        <=           \r\n    # if n ==0:                                                         <=           \r\n    #     return combiner(base, accumulate(combiner, base, n, term))    <=           \r\n    # else:                                                             <=           \r\n    #     return accumulate(combiner, base, n-1, term)                  <=           \r\n                                                                        <=           \r\n                                                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=0 \n    base>=0\n    k=n\n    combiner=(term(n)+term(n-1))\n    while k>=0:\n        total+=accumulate (combiner, base, k, term)\n        k-=1\n    return total \n\n    # if n ==0:\n    #     return combiner(base, accumulate(combiner, base, n, term))\n    # else:\n    #     return accumulate(combiner, base, n-1, term)\n\n        \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n   \n    if n ==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    base>=0","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":447,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if combiner == add:                                                =>           \r\n        final_number = 0                                               =>           \r\n    elif combiner == mul:                                              =>           \r\n        final_number = 1                                               =>           \r\n        final_number, k = combiner(final_number, term(k)), k - 1       =>           \r\n                                                                       =>           \r\n    final_number = 0                                                   <=           \r\n        final_number, k = combiner(term(final_number), term(k)), k - 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    final_number = 0\n    while k > 0:\n        final_number, k = combiner(term(final_number), term(k)), k - 1\n    return combiner(base, final_number)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if combiner == add:\n        final_number = 0\n    elif combiner == mul:\n        final_number = 1\n    while k > 0:\n        final_number, k = combiner(final_number, term(k)), k - 1\n    return combiner(base, final_number)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","7237","","# Error: expected","#     25","# but got","#     7237","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":448,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return combiner(base, term(n))\"\"\"          =>           \r\n    return combiner(base, accumulate_helper(1))    =>           \r\n        return combiner(base, term(n))             <=           \r\n    return combiner(base, accumulate_helper(1))\"\"\" <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\n    \n    \n    \"\"\"if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\"\"\"\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\"\"\"\n    \n    \n    if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    elif n==1:\r\n        return combiner(base, term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":449,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while x<= n: =>           \r\n    while i<= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while i<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while x<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    while i<= n:","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":450,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    if combiner == add: <=           \r\n        total = 0       <=           \r\n        total = 1       <=           \r\n    return base+total   <=           \r\n    else:               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    if combiner == add:\n        total = 0\n    else:\n        total = 1\n    while i <= n:\n        total = combiner(total,term(i))\n        i += 1\n \n    return base+total \n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total,term(i))\n        i += 1\n \n    return total\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return combiner(base, total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":451,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        for x in range(1, n+1):              =>           \r\n            total = combiner(total, term(x)) =>           \r\n                                             =>           \r\n        x = range(1, n+1)                    <=           \r\n        total = combiner(total, term(x))     <=           \r\n    #     ADD VS MULTIPLY?                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return total\n    else:\n        x = range(1, n+1)\n        total = combiner(total, term(x))\n        return total\n\n    # if n == 0:\n    #     return base\n    # else:\n    #     return term(n)*accumulate(combiner, base, n-1, term)\n    #     ADD VS MULTIPLY?\n    # total, product, k = 0,1,1\n    # if n == 0:\n    #     return base\n    # while k <= n:\n    #     if combiner == add:\n    #         total, k = total+term(k), k+1\n    #     else:\n    #         product, k = product*(term(k)), k+1\n    # total = total + base\n    # product = product*base\n    # if combiner == add:\n    #     return total\n    # return product\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return total\n    else:\n        for x in range(1, n+1):\n            total = combiner(total, term(x))\n        return total\n\n    # if n == 0:\n    #     return base\n    # else:\n    #     return term(n)*accumulate(combiner, base, n-1, term)\n\n    # total, product, k = 0,1,1\n    # if n == 0:\n    #     return base\n    # while k <= n:\n    #     if combiner == add:\n    #         total, k = total+term(k), k+1\n    #     else:\n    #         product, k = product*(term(k)), k+1\n    # total = total + base\n    # product = product*base\n    # if combiner == add:\n    #     return total\n    # return product\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(total, term(x))","TypeError: unsupported operand type(s) for +: 'int' and 'range'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":452,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    return accumulate(add, 0, n, term)                                    =>           \r\n    return accumulate(mul, 1, n, term)                                    =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n    if combiner == add:                                                   <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            summation_using_accumulate                                    <=           \r\n            k += 1                                                        <=           \r\n        result1 = summation_using_accumulate                              <=           \r\n        return base + result1                                             <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            product_using_accumulate                                      <=           \r\n            k += 1                                                        <=           \r\n        result2 = product_using_accumulate                                <=           \r\n        return base * result2                                             <=           \r\n    total += term(k)                                                      <=           \r\n    total, k = 1, 1                                                       <=           \r\n    def helper(n, term):                                                  <=           \r\n        while k <= n:                                                     <=           \r\n            total, k = total * term(k), k + 1                             <=           \r\n        return total                                                      <=           \r\n    return helper                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        k = 1\n        while k <= n:\n            summation_using_accumulate\n            k += 1\n        result1 = summation_using_accumulate\n        return base + result1\n\n    else:\n        k = 1\n        while k <= n:\n            product_using_accumulate\n            k += 1\n        result2 = product_using_accumulate\n        return base * result2\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return base + result1","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":453,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        result, i = combiner(term(i), result), i + 1 =>           \r\n        total, i = combiner(term(i), result), i + 1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        total, i = combiner(term(i), result), i + 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        result, i = combiner(term(i), result), i + 1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":454,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                                                                               SideIndic\r\n                                                                                                                                          ator     \r\n-----------                                                                                                                               ---------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                                   =>       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else combiner(x, accumulate(combiner, base, n-1, term)), base, n, term) =>       \r\n                                                                                                                                          =>       \r\n    k, result = 1, base                                                                                                                   <=       \r\n    while (k <= n):                                                                                                                       <=       \r\n        result = combiner(result, term(k))                                                                                                <=       \r\n        k = next(k)                                                                                                                       <=       \r\n    return result                                                                                                                         <=       \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"                                                                <=       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else base, base, n, term)                                               <=       \r\n    \"\"\"                                                                                                                                   <=       \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, result = 1, base\n    while (k <= n):\n        result = combiner(result, term(k))\n        k = next(k)\n    return result\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    k = next(k)","TypeError: 'int' object is not an iterator","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":455,"studentId":0,"date":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    final = base                                    =>           \r\n    x = 1                                           =>           \r\n    while x <= n:                                   =>           \r\n        final = combiner(term(x), final)            =>           \r\n    # total, k = base, 1                            <=           \r\n    # while k <=n:                                  <=           \r\n    #     total, k = combiner(term(k),total), k + 1 <=           \r\n    # return total                                  <=           \r\n    # total = 1                                     <=           \r\n    # k = base                                      <=           \r\n    # while k <=n:                                  <=           \r\n    #     total = combiner(term(k),total)           <=           \r\n    #     k = k + 1                                 <=           \r\n    # return total                                  <=           \r\n    final = 1                                       <=           \r\n    x = base                                        <=           \r\n    while x <=n:                                    <=           \r\n        final = combiner(term(x),final)             <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # total, k = base, 1\n    # while k <=n:\n    #     total, k = combiner(term(k),total), k + 1\n    # return total    \n\n    # total = 1\n    # k = base\n    # while k <=n:\n    #     total = combiner(term(k),total) \n    #     k = k + 1\n    # return total\n\n\n\n    final = 1\n    x = base\n    while x <=n:\n        final = combiner(term(x),final)\n        x = x + 1\n    return final\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    final = base\n    x = 1\n    while x <= n:\n        final = combiner(term(x), final)\n        x = x + 1\n    return final\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    final = base\r\n    x = 1\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":456,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    result = combiner(base, term(n))                 =>           \r\n    while n>1:                                       =>           \r\n        result, n = combiner(result, term(n-1)), n-1 =>           \r\n    k=0                                              <=           \r\n    result = combiner(base, term(k))                 <=           \r\n    while k<n:                                       <=           \r\n        result, k = combiner(result, term(k+1)), k+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=0\n    result = combiner(base, term(k))\n    while k<n:\n        result, k = combiner(result, term(k+1)), k+1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base, term(n))\n    while n>1:\n        result, n = combiner(result, term(n-1)), n-1\n    return result\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = base\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":457,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n    total, k = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":458,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if combiner == mul and n == 0: =>           \r\n            return total               =>           \r\n                                       =>           \r\n    return total                       =>           \r\n    return total                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #func, first number, count from one to, term\n    total = base\n    while n >= 0:      \n        total = combiner(term(n), total)\n        n -= 1\n      #  if n == 0:\n            #total = combiner(base, total)\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #func, first number, count from one to, term\n    total = base\n    while n >= 0:      \n        total = combiner(term(n), total)\n        n -= 1\n        if combiner == mul and n == 0:\n            return total\n            \n      #  if n == 0:\n            #total = combiner(base, total)\n    return total \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":459,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 0:         =>           \r\n            return term(0) =>           \r\n        elif x == 1:       =>           \r\n                           =>           \r\n    if n == 0:             <=           \r\n        return term(0)     <=           \r\n        if x == 1:         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(0)\n    def helper(x, term):\n        if x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(x, term):\n        if n == 0:\n            return term(0)\n        elif x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":460,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        start += 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n        start += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":461,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        k = k + 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n    return total \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k = k + 1\n    return total \n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":462,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    if n == 0:                                                                      =>           \r\n        return base                                                                 =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))           =>           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(x) else y, base, n, term) =>           \r\n    k = 0                                                                           <=           \r\n    if k == n:                                                                      <=           \r\n        return term(n)                                                              <=           \r\n        return combiner(base, accumulate(combiner, base, k+1, term))                <=           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(y) else x, base, n, term) <=           \r\n                                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    if k == n:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, base, k+1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    if k == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":463,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 0:                                =>           \r\n        return base                           =>           \r\n        total = 1                             =>           \r\n        for i in range(2, n+1):               =>           \r\n            total = combiner(total, term(i))  =>           \r\n        return combiner(base, total)          =>           \r\n    else:                                     =>           \r\n    total = 1                                 <=           \r\n    for i in range(2, n+1):                   <=           \r\n        total = combiner(total, term(i))      <=           \r\n    return combiner(base, total)              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    for i in range(2, n+1):\n        total = combiner(total, term(i)) \n    return combiner(base, total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        total = 1\n        for i in range(2, n+1):\n            total = combiner(total, term(i)) \n        return combiner(base, total)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    if n==0:\r\n        return base\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":464,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return base + term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":465,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif n == 1:       =>           \r\n        return term(n) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if base != 0:\n        return combiner(base, accumulate(combiner, 0, n, term))\n    elif n == 0:\n        return 0\n    else:\n        return combiner(accumulate(combiner, 0, n - 1, term), term(n))\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if base != 0:\n        return combiner(base, accumulate(combiner, 0, n, term))\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return combiner(accumulate(combiner, 0, n - 1, term), term(n))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":466,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n > 0:                                                           =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    if n > 1:                                                           <=           \r\n        return combiner(term(n), accumulate(base, n-1, term(n)))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(base, n-1, term(n)))\n    else:\n        return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(base, n-1, term(n)))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":467,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n)) + accumulate(combiner, base, n-1, term)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":468,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for i in range(n):                 =>           \r\n        acc = combiner(acc, term(i+1)) =>           \r\n    for i in range(n+1):               <=           \r\n        acc = combiner(acc, term(i))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n+1):\n        acc = combiner(acc, term(i))\n    return acc\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n):\n        acc = combiner(acc, term(i+1))\n    return acc\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(1, n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":469,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":470,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n                        =>           \r\n    total, k = start, 1 <=           \r\n                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":471,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combine(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":472,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return n\n    ans = combiner(base, term(1))\n    for i in range(2, n+1):\n        ans = combiner(ans, term(i))\n    return ans\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    ans = combiner(base, term(1))\n    for i in range(2, n+1):\n        ans = combiner(ans, term(i))\n    return ans\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":473,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":474,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":475,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        if (n == 1) | (n == 0) : =>           \r\n        if n == 1:               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if (n == 1) | (n == 0) :\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in helper_function","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":476,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n        return combiner(accumulate(combiner,base,n-1,term),term(n)) =>           \r\n    else:                                                           =>           \r\n    return base + term(combiner(n))                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return base + term(combiner(n))\n\n    \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n    \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return base + term(combiner(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":477,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    def term_output(n):\n        return term(n)\n\n\n    total, i = (base), 1\n\n    while i <= n:\n        print(total)\n        total = combiner(total, term_output(i))\n        i+= 1\n        \n\n    return total\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    def term_output(n):\n        return term(n)\n\n\n    total, i = (base), 1\n\n    while i <= n:\n     \n        total = combiner(total, term_output(i))\n        i+= 1\n        \n\n    return total\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","1","3","6","10","15","","# Error: expected","#     15","# but got","#     0","#     1","#     3","#     6","#     10","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":478,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return combiner(term(n, base)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n, base))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n, base))","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":479,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        list.append(k) =>           \r\n        append.list(k) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    list = []\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        append.list(k)\n        k += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    list = []\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        list.append(k)\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    append.list(k)","NameError: name 'append' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":480,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total=combiner(term(n),base)               =>           \r\n        return accumulate(combiner,total,n-1,term) =>           \r\n        return accumulate(combiner,base,n-1,term)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        return accumulate(combiner,base,n-1,term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        total=combiner(term(n),base)\n        return accumulate(combiner,total,n-1,term)\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":2,"Id":481,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    return reduce(combiner, [base] + list(map(term, [i for i in range(1, n + 1)]))) =>           \r\n    return reduce(combiner, [base] + list(map(term, [i for i in range(n)])))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    return reduce(combiner, [base] + list(map(term, [i for i in range(n)])))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    return reduce(combiner, [base] + list(map(term, [i for i in range(1, n + 1)])))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":482,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        x = combiner(x, term(i))             =>           \r\n        total = total * combiner(x, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        total = total * combiner(x, term(i))\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        x = combiner(x, term(i))\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = total * combiner(x, term(i))","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":483,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":484,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        if combiner==add: =>           \r\n        if combiner==mul: =>           \r\n        if add:           <=           \r\n        if mul:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if add:\n            sum+=x\n        if mul:\n            sum*=x\n    return sum\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if combiner==add:\n            sum+=x\n        if combiner==mul:\n            sum*=x\n    return sum\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","645","","# Error: expected","#     15","# but got","#     645","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":485,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return base + accumulate(combiner, base, n-1, term)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return base + accumulate(combiner, base, n-1, term) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":486,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term)) =>           \r\n    if n == 1:                                                          <=           \r\n        return term(n)                                                  <=           \r\n        return combiner(base, accumulate(combiner, n, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, n, n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":487,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    a = 1   =>           \r\n    a = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 1\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":488,"studentId":0,"date":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    k=1                                                 =>           \r\n    while k<=n:                                         =>           \r\n        result,k=combiner(result,term(k)), k+1          =>           \r\n    while base<=n:                                      <=           \r\n        result,base=combiner(result,term(base)), base+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    while base<=n:\n        result,base=combiner(result,term(base)), base+1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    k=1\n    while k<=n:\n        result,k=combiner(result,term(k)), k+1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":489,"studentId":0,"date":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while n > 0:      =>           \r\n        n-=1          =>           \r\n    while count <= n: <=           \r\n        count += 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while count <= n:\n        start = combiner(start, term(n))\n        count += 1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while n > 0:\n        start = combiner(start, term(n))\n        n-=1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    k = 1\r\n    while k<=n:\r\n        start = combiner(start, term(k))\r\n        k += 1\r\n    return start","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":490,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n            return 0       =>           \r\n            return term(0) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 0:\n            return term(0)\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 1:\n            return term(1)\n        if n == 0:\n            return 0\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":491,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k <= n: =>           \r\n    k = 0         <=           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 0\n    while k < n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<n+1:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":492,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while i > 1: =>           \r\n    while i > 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 0:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 1:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>1:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":493,"studentId":0,"date":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term))       =>           \r\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21913","","# Error: expected","#     25","# but got","#     21913","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":494,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=base                  =>           \r\n    return total                =>           \r\n    total=0                     <=           \r\n    return combiner(base,total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=0\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return combiner(base,total)\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":495,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x:0)    =>           \r\n        return 0                                                                <=           \r\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term) <=           \r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x :0)   <=           \r\n    if n == 0:                                                                  <=           \r\n    else:                                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term)\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":496,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":497,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        x = y(x, term(i)) =>           \r\n        x = y(x, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(n))\n    return x\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(i))\n    return x\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for n in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":498,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n    if term == add:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    x = 1\n    y = 1\n    if term == add:\n        y = 0\n    while x <= n:\n        y = combiner(y, term(x))\n        x += 1\n    return combiner(base, y)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    x = 1\n    y = 1\n    if combiner == add:\n        y = 0\n    while x <= n:\n        y = combiner(y, term(x))\n        x += 1\n    return combiner(base, y)\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = base\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return y","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":499,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n    if n < 1:                                                                           =>           \r\n        return base                                                                     =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))                 =>           \r\n    if n == 1:                                                                          <=           \r\n        return term(n)                                                                  <=           \r\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base)\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","59","","# Error: expected","#     26","# but got","#     59","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":500,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n-1), base)                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n-1), base)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":501,"studentId":0,"date":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n == 1:                <=           \r\n        return term(1) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return term(1) + base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":502,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(total, term(n))      =>           \r\n        total = combiner(total, i)       <=           \r\n    return combiner(total, n)            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, i)\n    return combiner(total, n)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, term(i))\n    return combiner(total, term(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":503,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(accumulate(combiner, base, n-1,term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1,term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1,term)\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1,term), term(n))\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":504,"studentId":0,"date":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        a = combiner(a, term(b)) =>           \r\n        a = combiner(a, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(i))\n        b = b + 1\n    return a\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(b))\n        b = b + 1\n    return a\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(b))\r\n        b = b+1\r\n    return a","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    a = combiner(a, term(i))","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":505,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n)+accumulate(combiner, base, n-1, term)           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner, base, n-1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":506,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":507,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    counter = 0\n    total = base\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total \n\n \n'''    def value(i):\n        if n == 0:\n            return term(n)\n        if i == n:\n            return term(i)\n        else:\n            return combiner( term(i), value(i + 1))\n    \n    value = value(1)\n    return combiner(base, value)'''\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    counter = 1\n    total = base\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total \n\n \n'''    def value(i):\n        if n == 0:\n            return term(n)\n        if i == n:\n            return term(i)\n        else:\n            return combiner( term(i), value(i + 1))\n    \n    value = value(1)\n    return combiner(base, value)'''\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":508,"studentId":0,"date":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    total = base\n    while counter < n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":509,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                    SideIndicator\r\n-----------                                                                    -------------\r\n        return combiner(base, term(1))                                         =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        =>           \r\n        return combiner(base, term(n))                                         <=           \r\n        return base + combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(n))\n    if n == 0:\n        return term(base)\n    else:\n        return base + combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(1))\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return 0+combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":510,"studentId":0,"date":null,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n    if n == 0:                                                     =>           \r\n        return base                                                =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n    def summation(n,term):                                         <=           \r\n        total, k = 0,1                                             <=           \r\n        while k<=n:                                                <=           \r\n            total,k = total + term(k), k+1                         <=           \r\n            return total                                           <=           \r\n    if combiner == add:                                            <=           \r\n        return base + summation(n,term)                            <=           \r\n        return base + product (n,term)                             <=           \r\n    else:                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(n,term):\n        total, k = 0,1\n        while k<=n:\n            total,k = total + term(k), k+1\n            return total\n    if combiner == add:\n        return base + summation(n,term)\n    else:\n        return base + product (n,term)\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":511,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            sum3 = sum3 * term(p) =>           \r\n            sum3 = sum3 * term(k) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(k)\n            p += 1\n\n        return base * sum3\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(p)\n            p += 1\n\n        return base * sum3\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    k = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while k<=n:\r\n            sum3 = sum3*term(k)\r\n            k += 1\r\n        return base*sum3","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":512,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        total, k = combiner(total, term(k)), k + 1   =>           \r\n        total, k = total + combiner(term(k)), k + 1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = total + combiner(term(k)), k + 1 \n    return total\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1 \n    return total\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    total, k = total + combiner(term(k)), k + 1","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":513,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))             =>           \r\n    return accumulate(add, 1, n, identity)                                          =>           \r\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term) <=           \r\n    return _______                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":514,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, accumulate_helper(n, term, 1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate_helper","    if k==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":515,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    total=base     =>           \r\n    k=1            =>           \r\n    while k<=n:    =>           \r\n        k+=1       =>           \r\n    total=1        <=           \r\n    while base<=n: <=           \r\n        base+=1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=1\n    while base<=n:\n        total= combiner(total,term(k))\n        base+=1\n    return total    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=base\n    k=1\n    while k<=n:\n        total= combiner(total,term(k))\n        k+=1\n    return total    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total= combiner(total,term(k))","NameError: name 'k' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":516,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n    return combiner(term(n), accumulator(combiner, base, n - 1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    return combiner(term(n), accumulator(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulator(combiner, base, n - 1, term))","NameError: name 'accumulator' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":517,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":518,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":519,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n        combiner(term(n), accumulate(combiner, base, n - 1, term))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n\n","after":"def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":520,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        if combiner == add:     =>           \r\n        elif combiner == mul:   =>           \r\n        if combiner == add():   <=           \r\n        elif combiner == mul(): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add():\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul():\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add:\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul:\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if combiner == add():","TypeError: op_add expected 2 arguments, got 0","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":521,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x <= n: =>           \r\n                  =>           \r\n    while x <= 1: <=           \r\n                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= 1:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n    \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":522,"studentId":0,"date":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 2   =>           \r\n    i = 1   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    i = 1\n    final = combiner(base, term(1))\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    final = combiner(base, term(1))\n    i = 2\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = base\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":523,"studentId":0,"date":null,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n    total, k = base, 1                                    =>           \r\n        total, k = combiner(term(k), total), increment(k) =>           \r\n    total = 1                                             <=           \r\n    k = 1                                                 <=           \r\n        total = combiner(term(k), total)                  <=           \r\n        k = k + 1                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = combiner(term(k), total)\n        k = k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), increment(k)\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":524,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":525,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                               SideIndicator\r\n-----------                                                                               -------------\r\n        total = combiner(total, term(k))                                                  =>           \r\n    def f(g, h):                                                                          =>           \r\n        return g                                                                          =>           \r\n    return accumulate(lambda y,x: combiner(y,x) if pred(x) else f(y, x), base, n, term)   =>           \r\n        total = combiner(total, k)                                                        <=           \r\n    return accumulate(combiner, base, n, term)                                            <=           \r\n                                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, k)\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, term(k))\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, term(k))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":526,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    while a <= n:                          =>           \r\n        result = combiner(term(a), result) =>           \r\n    while(a <= n):                         <=           \r\n        result = combiner(base, term(a))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while(a <= n):\n        result = combiner(base, term(a))\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while a <= n:\n        result = combiner(term(a), result)\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        base = result = combiner(base, term(a))\r\n        a += 1\r\n    return result","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":527,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return combiner(x, base) // term(n+1) =>           \r\n        return combiner(x, base) / term(n+1)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) / term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) // term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72.0","","# Error: expected","#     72","# but got","#     72.0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":528,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n > 0:\n        return term(n) + accumulate(combiner, base, n-1, term)\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":529,"studentId":0,"date":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        base = combiner(base, term(term_iteration)) =>           \r\n    return base                                     =>           \r\n        t = combiner(t, term(term_iteration))       <=           \r\n    return t                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        t = combiner(t, term(term_iteration))\n        term_iteration += 1\n    return t\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        base = combiner(base, term(term_iteration))\n        term_iteration += 1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    t = combiner(t, term(term_iteration))","UnboundLocalError: local variable 't' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":530,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n-1, term))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(base, n-1, term))\n   \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n   \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(base, n-1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":531,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return \n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    \n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":532,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n <= 1:                         =>           \r\n        return term(n)                 =>           \r\n    if n <= 1:                         =>           \r\n        return combiner(term(n), base) =>           \r\n    if n == 1:                         <=           \r\n        return term(1)                 <=           \r\n    if n == 1:                         <=           \r\n        return combiner(term(1), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":533,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, term(n))                                    =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n        return combiner(total, base)                                      <=           \r\n        total = total + combiner(total, term(n))                          <=           \r\n        return accumulate(combiner, base, n - 1, term, 0)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(total, base)\n    else:\n        total = total + combiner(total, term(n))\n        return accumulate(combiner, base, n - 1, term, 0)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    total = total + combiner(total, term(n))","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":534,"studentId":0,"date":null,"diff":"","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = BASE, 1\n    while x<=n:\n        total = COMBINER(term(x), total)\n        x = x+1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = base, 1\n    while x<=n:\n        total = combiner(term(x), total)\n        x = x+1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total,x = BASE, 1","NameError: name 'BASE' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":535,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    while counter < n + 1: =>           \r\n    while counter < n:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n + 1:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":536,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":537,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return combiner( base , term(n))\n    else:\n        return combiner(term(n) , accumulate(combiner, base, n-1, term))    \nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner( base , term(n))\n    else:\n        return combiner(term(n) , accumulate(combiner, base, n-1, term))    \nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":1,"Id":538,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n==0:                                                            =>           \r\n        return base                                                     =>           \r\n    else:                                                               =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\nfrom operator import add, mul                                           <=           \r\ndef accumulate_helper(term,n):                                          <=           \r\n        if n >= 0:                                                      <=           \r\n            return term(n) * n-1                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\nfrom operator import add, mul\ndef accumulate_helper(term,n):\n        if n >= 0:\n            return term(n) * n-1\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":539,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n        if i>n: =>           \r\n        if i<n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i<n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i>n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if n<i:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":540,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = 0                     <=           \r\n    final = combiner(base, total) <=           \r\n    return final                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    x = 1\n    while not x > n:\n        total = combiner(total, term(x))\n        x += 1\n    final = combiner(base, total)\n    return final\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    x = 1\n    while not x > n:\n        total = combiner(total, term(x))\n        x += 1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        base = combiner(base, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":541,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n            return counter(i + 1, combiner(total, term(i)))         =>           \r\n        print(total)                                                <=           \r\n            return counter(i + 1, total + combiner(total, term(i))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i, total = base):\n        print(total)\n        if i == n:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total\n        else:\n            return counter(i + 1, total + combiner(total, term(i)))\n    return counter(1)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i, total = base):\n        if i == n:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total\n        else:\n            return counter(i + 1, combiner(total, term(i)))\n    return counter(1)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, \r\n            total = combiner(total, term(i)))\r\n    return counter(1)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","1","4","11","26","31","","# Error: expected","#     15","# but got","#     0","#     1","#     4","#     11","#     26","#     31","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":542,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return n\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":543,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n    if n == 1:                                                            =>           \r\n        return combiner(base, term(n))                                    =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))       =>           \r\n    if base == 0:                                                         <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   <=           \r\n    return combiner(base, term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    if base == 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    return combiner(base, term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    from operator import add, mul","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":544,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(n - 1))                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(n - 1))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(n - 1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":545,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":546,"studentId":0,"date":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<n+1:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":547,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumualte(combiner, combiner(base, term(n)), n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumualte(combiner, combiner(base, term(n)), n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return accumualte(combiner, combiner(base, term(n)), n-1, term)","NameError: name 'accumualte' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":548,"studentId":0,"date":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if combiner == mul:           =>           \r\n        v = 1                     =>           \r\n    return accumulate(n, term(x)) =>           \r\n    return _______                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    if combiner == mul:\n        v = 1\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":549,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":550,"studentId":0,"date":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), term(n - 1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":551,"studentId":0,"date":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        k = increment(k) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n    return total\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k = increment(k)\n    return total\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":552,"studentId":0,"date":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    return total       =>           \r\n    total, k = 0, 1    <=           \r\n    return c(b, total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = 0, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return c(b, total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = base, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":553,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    total, k = base, 1                               =>           \r\n    while k <= n:                                    =>           \r\n        total, k = combiner(total,term(k)), k+1      =>           \r\n    return total                                     =>           \r\n    k = 1                                            <=           \r\n    while k <= n+1:                                  <=           \r\n        total, k = combiner(term(k), term(k+1)), k+2 <=           \r\n    return combiner(total, base)                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n+1:\n    \ttotal, k = combiner(term(k), term(k+1)), k+2\n    return combiner(total, base)\n   \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n    \ttotal, k = combiner(total,term(k)), k+1\n    return total\n   \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":554,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 1:                        =>           \r\n        base = combiner(base, term(n))   =>           \r\n                                         =>           \r\n    total = 0                            <=           \r\n        total = combiner(total, term(n)) <=           \r\n    return total                         <=           \r\n        base = combiner(base, term(i))   <=           \r\n        i += 1                           <=           \r\n    while base <= n:                     <=           \r\n    i = 1                                <=           \r\n    while i <= n:                        <=           \r\n    \"\"\"                                  <=           \r\n    \"\"\"                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    while base <= n:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n    \"\"\"\n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base\n    \"\"\"\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":555,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                  SideIndicator\r\n-----------                                                                  -------------\r\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) ) =>           \r\n        return combiner( base, accumulate(combiner, 0, n, term) )            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( base, accumulate(combiner, 0, n, term) )\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) )\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":556,"studentId":0,"date":null,"diff":"\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    i = 1                                                      =>           \r\n    while i <= n:                                              =>           \r\n        base = combiner(base, term(i))                         =>           \r\n        i= i + 1                                               =>           \r\n    return base                                                =>           \r\n    if combiner == add:                                        <=           \r\n        if n == 0:                                             <=           \r\n            return base                                        <=           \r\n        if n>0:                                                <=           \r\n            return accumulate(combiner, base, term(n-1), term) <=           \r\n    if combiner == mul:                                        <=           \r\n        return base + factorial(n)                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n == 0:\n            return base\n        if n>0:\n            return accumulate(combiner, base, term(n-1), term)\n    if combiner == mul:\n        return base + factorial(n)\n\n\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i= i + 1\n    return base\n\n\n    \"*** YOUR CODE HERE ***\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":557,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if n==0: return base    =>           \r\n    if n==base: return base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==base: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n==base: return base","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":558,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":559,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        # (base, term(n))                                               =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1, term)\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        # (base, term(n))\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":560,"studentId":0,"date":null,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return base                                   =>           \r\n        base = combiner(term(n), base)                =>           \r\n        return accumulate(combiner, base, n-1, term)  =>           \r\n        return start                                  <=           \r\n        start = combiner(term(n), start)              <=           \r\n        return accumulate(combiner, start, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return start\n    else:\n        start = combiner(term(n), start)\n        return accumulate(combiner, start, n-1, term)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, start, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    start = combiner(term(n), start)","UnboundLocalError: local variable 'start' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":561,"studentId":0,"date":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n == 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n <= 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in whatever","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":562,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        print(count,base,term(count)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    while count <= n:\n        \"\"\"\n        if combiner == add:\n            base += term(count)\n            count += 1\n        if combiner == mul:\n            base *= term(count)\n            count += 1\"\"\"\n        count+=1\n        print(count,base,term(count))\n        base = combiner(base,term(count))\n\n    return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    while count <= n:\n        \"\"\"\n        if combiner == add:\n            base += term(count)\n            count += 1\n        if combiner == mul:\n            base *= term(count)\n            count += 1\"\"\"\n        base = combiner(base,term(count))\n        count+=1\n\n    return base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","2 0 2","3 2 3","4 5 4","5 9 5","6 14 6","20","","# Error: expected","#     15","# but got","#     2 0 2","#     3 2 3","#     4 5 4","#     5 9 5","#     6 14 6","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":563,"studentId":0,"date":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    total = base                                                       =>           \r\n    # if combiner == add:                                              =>           \r\n    #     total = base                                                 =>           \r\n    while n > 0:                                                       =>           \r\n            total += term(n)                                           =>           \r\n            total *= term(n)                                           =>           \r\n        n -= 1                                                         =>           \r\n    # total = base                                                     <=           \r\n    # start = 0                                                        <=           \r\n    # start1 = 1                                                       <=           \r\n    # mul = [base]                                                     <=           \r\n    # total1 = 1                                                       <=           \r\n    #     return base                                                  <=           \r\n    # elif start <= n:                                                 <=           \r\n    #     if combiner == add:                                          <=           \r\n    #         total += combiner(term(start), term(start + 1))          <=           \r\n    #         start += 2                                               <=           \r\n    # return total                                                     <=           \r\n    # elif start1 <= n:                                                <=           \r\n    #             mul = [base]                                         <=           \r\n    #             mul.append(combiner(term(start1), term(start1 + 1))) <=           \r\n    #             start1 += 2                                          <=           \r\n    #             total1 *= mul[:]                                     <=           \r\n    # return total1                                                    <=           \r\n    total = 1                                                          <=           \r\n    if combiner == add:                                                <=           \r\n        total = 0                                                      <=           \r\n    while base <= n:                                                   <=           \r\n            total += term(base)                                        <=           \r\n            base += 1                                                  <=           \r\n            total *= term(base)                                        <=           \r\n            base += 1                                                  <=           \r\n    # if n == 0:                                                       <=           \r\n                                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # total = base\n    # start = 0\n    # start1 = 1\n    # mul = [base]\n    # total1 = 1\n    # if n == 0:\n    #     return base\n    # elif start <= n:\n    #     if combiner == add:\n    #         total += combiner(term(start), term(start + 1))\n    #         start += 2\n    # return total\n    # elif start1 <= n:\n    #             mul = [base]\n    #             mul.append(combiner(term(start1), term(start1 + 1)))\n    #             start1 += 2\n    #             total1 *= mul[:]\n    # return total1\n\n    total = 1\n    if combiner == add:\n        total = 0\n    while base <= n:\n        if combiner == add:\n            total += term(base)\n            base += 1\n        if combiner == mul:\n            total *= term(base)\n            base += 1\n    return total\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    # if combiner == add:\n    #     total = base\n    while n > 0:\n        if combiner == add:\n            total += term(n)\n        if combiner == mul:\n            total *= term(n)\n        n -= 1\n    return total\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":564,"studentId":0,"date":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2  =>           \r\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","Traceback (most recent call last):","    accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","                                     ^","SyntaxError: invalid syntax","","# Error: expected","#     25","# but got","#     SyntaxError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":565,"studentId":0,"date":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n        return accumulate(combiner, base, n - 1, term)  =>           \r\n        return accumulator(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulator(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return accumulator(combiner, base, n - 1, term)","NameError: name 'accumulator' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":566,"studentId":0,"date":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total = base                                   =>           \r\n        total = combiner(term(k), total)           =>           \r\n    return accumulate(add, 0, n, term)             =>           \r\n    total = 0                                      <=           \r\n        if k == 1:                                 <=           \r\n            total = combiner(base, term(k+1))      <=           \r\n        else:                                      <=           \r\n            total = combiner(term(k+1), term(k+2)) <=           \r\n    return _______                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = 0\n    while k <= n:\n        if k == 1:\n            total = combiner(base, term(k+1))\n        else:\n            total = combiner(term(k+1), term(k+2))\n        k = k + 1\n\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(term(k), total)\n        k = k + 1\n\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":567,"studentId":0,"date":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == add: =>           \r\n            result = 0      =>           \r\n        if combiner == mul: =>           \r\n            result = 1      =>           \r\n        result = 0          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tresult = 0\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tif combiner == add:\n    \t\tresult = 0\n    \tif combiner == mul:\n    \t\tresult = 1\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":568,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        accumulation=combiner(base,term(0))   =>           \r\n        accumulutation=combiner(base,term(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return accumulation","UnboundLocalError: local variable 'accumulation' referenced before assignment","","# Error: expected","#     11","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":569,"studentId":0,"date":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n == 0:   =>           \r\n        elif n <= 1: =>           \r\n        if n <= 1:   <=           \r\n        elif n == 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n <= 1:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total \n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n == 0:\n            return total \n        elif n <= 1:\n            return combiner(total, term(i))\n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    if n==0:\r\n        return base\r\n    return helper(1, base, combiner, base, n, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":570,"studentId":0,"date":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n += 1\n    return x\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n -= 1\n    return x\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":571,"studentId":0,"date":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumulate(combiner, combiner(base, n), n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, n), n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":572,"studentId":0,"date":null,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return accumulate(combiner, total, n, term)         =>           \r\n        return accumulate(combiner, total, n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n-1, term)      \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n, term)      \n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, total, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":573,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(i), total) =>           \r\n        total = combiner(term, total)    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term, total)\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term(i), total)\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term, total)","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":574,"studentId":0,"date":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n                =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    ans = base\n    while (counter <= n):\n        counter += 1\n        ans = combiner(ans, term(counter))\n    return ans\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    ans = base\n    while (counter <= n):\n\n        ans = combiner(ans, term(counter))\n        counter += 1\n    return ans\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":575,"studentId":0,"date":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        sum, i = combiner(term(i), sum), i+1 =>           \r\n        sum, k = combiner(term(k), sum), i+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, k = combiner(term(k), sum), i+1\n    return sum\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, i = combiner(term(i), sum), i+1\n    return sum\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum, k = combiner(term(k), sum), i+1","UnboundLocalError: local variable 'k' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":576,"studentId":0,"date":null,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        acc_sum = combiner(acc_sum, term(index)) =>           \r\n        acc_sum = combiner(acc_sum, term(n))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(n))\n        index += 1 \n    return acc_sum \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(index))\n        index += 1 \n    return acc_sum \n\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    k = 1\r\n    while k<=n:\r\n        acc_sum = combiner(acc_sum, term(k))\r\n        k += 1\r\n    return acc_sum","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":577,"studentId":0,"date":null,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n    total, k = base, 1                            =>           \r\n        total, k = combiner(total, term (k)), k+1 =>           \r\n    total, k = 0, 1                               <=           \r\n        total, k = combiner(term(k), total), k+1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = 0, 1\n    while k<= n:\n        total, k = combiner(term(k), total), k+1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<= n:\n        total, k = combiner(total, term (k)), k+1\n    return total\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":578,"studentId":0,"date":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=base       =>           \r\n    k=term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=term(base)\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = base\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":579,"studentId":0,"date":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if n == 1:             =>           \r\n        return term(1)     =>           \r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n    if n == 0:             <=           \r\n        return 1           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        if n == 1:\n            return term(1)\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return base\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return sequence(combiner, n, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":580,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\nfrom operator import add, mul\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\nfrom operator import add, mul\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":581,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n            if combiner(term(a),b)==0: =>           \r\n                b=combiner(term(a),1)  =>           \r\n                b=combiner(term(a),b)  =>           \r\n                return value(a+1,b)    =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            if combiner(term(a),b)==0:\n                b=combiner(term(a),1)\n                b=combiner(term(a),b)\n                return value(a+1,b)\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":582,"studentId":0,"date":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return accumulate(combiner, base, n-1, term) =>           \r\n        return accumulate(combiner, base, n, term)   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":583,"studentId":0,"date":null,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            if n == 1:                                       =>           \r\n                return term(1)                               =>           \r\n            else:                                            =>           \r\n                return combiner(term(n), rec_n((n-1), term)) =>           \r\n            return combiner(term(n), rec_n((n-1), term))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            if n == 1:\n                return term(1)\n            else:\n                return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":584,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        print(base)                                                 <=           \r\n        print(n,term(n),combiner(n,term(n)))                        <=           \r\n        combiner(term(n),accumulate(combiner,base,n-1,term))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        print(base)\n        return base\n    else:\n        print(n,term(n),combiner(n,term(n)))\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5 5 10","4 4 8","3 3 6","2 2 4","1 1 2","0","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":585,"studentId":0,"date":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    k = 1                               =>           \r\n        base = combiner(base, term(k))  =>           \r\n    return base                         =>           \r\n    total, k = base , 1                 <=           \r\n        total = combiner(base, term(k)) <=           \r\n    return combiner( base, total)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base , 1\n    while k <= n:\n        total = combiner(base, term(k))\n        k = k + 1\n    return combiner( base, total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n:\n        base = combiner(base, term(k))\n        k = k + 1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":586,"studentId":0,"date":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        base = combiner(base, term(n))     =>           \r\n        base = combiner(base, (n ** term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, (n ** term))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    base = combiner(base, (n ** term))","TypeError: unsupported operand type(s) for ** or pow(): 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":587,"studentId":0,"date":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n        return combiner(base, accumulator(combiner, n, term, 1)) =>           \r\n        return base + accumulator(combiner, n, term, 1)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return base + accumulator(combiner, n, term, 1)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return combiner(base, accumulator(combiner, n, term, 1))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":588,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":589,"studentId":0,"date":null,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        total_choice = 0                                 =>           \r\n        total_choice = 1                                 =>           \r\n    return  counter(combiner,base,n,term,total_choice,1) =>           \r\n        count_choice = 0                                 <=           \r\n        count_choice = 1                                 <=           \r\n    return  counter(combiner,base,n,term,1,count_choice) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        count_choice = 0\n    else:\n        count_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,1,count_choice)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        total_choice = 0\n    else:\n        total_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,total_choice,1)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return total\r\n    return counter(combiner, base, n, term, base, count_choice)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":590,"studentId":0,"date":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        base= combiner(term(n),base) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base= combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":591,"studentId":0,"date":null,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n    def function(operation, n, term, total, i=1):            =>           \r\n        return function(operation, n, term, total, i+1)      =>           \r\n    if combiner == mul:                                      =>           \r\n        total = 1                                            =>           \r\n        total = 0                                            =>           \r\n    return combiner(base, function(combiner, n,term, total)) =>           \r\n    else:                                                    =>           \r\n                                                             =>           \r\n    def function(operation, n, term, i=1, total=0):          <=           \r\n        if operation == mul:                                 <=           \r\n            total=1                                          <=           \r\n        return function(operation, n, term, i+1, total)      <=           \r\n                                                             <=           \r\n    return combiner(base, function(combiner, n,term))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, i=1, total=0):\n        if operation == mul:\n            total=1\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, i+1, total)\n    \n    return combiner(base, function(combiner, n,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, total, i=1):\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, total, i+1)\n\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    return combiner(base, function(combiner, n,term, total))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":592,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n <= 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    if n <= 0:\n        return base\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, terms(term, 1))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in terms","    if m == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":593,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))       =>           \r\n    return accumulate(add, 0, n, term)                                          =>           \r\n    return accumulate(mul, 1, n, term)                                          =>           \r\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n)) <=           \r\n    return _______                                                              <=           \r\n    return _______                                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","221652553","","# Error: expected","#     25","# but got","#     221652553","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":594,"studentId":0,"date":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    return combiner(base, accumulate_func(n)) if n > 0 else base =>           \r\n    return combiner(base, accumulate_func(n))                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_func(n):\n        if(n==1):\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base, accumulate_func(n))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_func(n):\n        if(n==1):\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base, accumulate_func(n)) if n > 0 else base\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_func","    if(n==1):","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":595,"studentId":0,"date":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        x = combiner(x, term(i))    =>           \r\n        x = combiner(base, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(base, term(i))\n        i += 1\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(x, term(i))\n        i += 1\n    return x\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":596,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(count))  =>           \r\n        total = combinder(total, term(count)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combinder(total, term(count))\n        count += 1\n\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count += 1\n\n    return total\n\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count += 1\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total = combinder(total, term(count))","NameError: name 'combinder' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":597,"studentId":0,"date":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 1:                         =>           \r\n    elif n ==0:                        =>           \r\n        return combiner(term(0), base) =>           \r\n    if n == 0:                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    elif n ==0:\n        return combiner(term(0), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":598,"studentId":0,"date":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    t, i = base, 1                       =>           \r\n        t = combiner(t, term(i))         =>           \r\n    return t                             =>           \r\n    return accumulate(combiner(n, term)) =>           \r\n    t, i = 1, 1                          <=           \r\n        t = term(i)                      <=           \r\n    return t * 3                         <=           \r\n    return _______                       <=           \r\n    \"*** YOUR CODE HERE ***\"             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t = term(i)\n        i += 1\n    return t * 3\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":599,"studentId":0,"date":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(i))      =>           \r\n        total = combiner(term(i-1), term(i))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(term(i-1), term(i)) \n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i)) \n    return total\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(accumulate(combiner, base, i-1, term), term(i))\r\n    return total","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":600,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n >= 1:      =>           \r\n        return base =>           \r\n    if n >= 2:      <=           \r\n        return 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 2:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return 1\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 1:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":601,"studentId":0,"date":null,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    return accumulate(add, 0, n, term)                                            =>           \r\n    return accumulate(mul, 1, n, term)                                            =>           \r\n    return accumulate(lambda a,x: combiner(a,x) if pred(x) else a, base, n, term) =>           \r\n    term_number = 0                                                               <=           \r\n    result = base                                                                 <=           \r\n    if combiner == add:                                                           <=           \r\n        while term_number < n:                                                    <=           \r\n            result += term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    elif combiner == mul:                                                         <=           \r\n        while term_number < n:                                                    <=           \r\n            result *= term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    return accumulate(add, lambda base: base , n, term  )                         <=           \r\n    return _______                                                                <=           \r\n    return _______                                                                <=           \r\n                                                                                  <=           \r\n                                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                      <=           \r\n                                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_number = 0\n    result = base\n    if combiner == add:\n        while term_number < n:\n            result += term(term_number)\n        return result\n    elif combiner == mul:\n        while term_number < n:\n            result *= term(term_number)\n        return result\n\n\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if add:combiner==add\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":602,"studentId":0,"date":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    prev_term = base            =>           \r\n    for x in range (1, n+1):    =>           \r\n    prev_term = 0               <=           \r\n    for x in range (base, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = 0\n    for x in range (base, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = base\n    for x in range (1, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = base\r\n    for x in range(1, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":603,"studentId":0,"date":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":604,"studentId":0,"date":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        ans = combiner(ans, term(i)); =>           \r\n        ans = combiner(ans, term(n)); <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(n));\n    return ans;\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(i));\n    return ans;\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for n in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":605,"studentId":0,"date":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return accumulate(combiner,combiner(base,term(n)),n-1,term) =>           \r\n    if n==1:                                                        <=           \r\n        return combiner(base,term(n))                               <=           \r\n        return combiner(base,accumulate(combiner,n-1,term))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(base,accumulate(combiner,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,term(n)),n-1,term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":null,"UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base,accumulate(combiner,n-1,term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":606,"studentId":0,"date":null,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if n == 0:                 =>           \r\n        return base            =>           \r\n    #if n == 1:                =>           \r\n        #return base + term(1) =>           \r\n    if n == 1:                 <=           \r\n        return base + term(1)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    #if n == 1:\n        #return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"ErrorFlag":0,"Id":607,"studentId":0,"date":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","IsFixed":true,"GeneratedFix":null,"UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}]